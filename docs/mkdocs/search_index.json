{
    "docs": [
        {
            "location": "/", 
            "text": "", 
            "title": "Welcome"
        }, 
        {
            "location": "/start/", 
            "text": "Welcome to the SUPR Accept SDK Partner Documentation\n\n\nThe \nSUPR Accept SDK\n is part of Wirecard's range of mobile Point of Sale (mPOS) products and solutions. For complete information about all of Wirecard's mPOS solutions, see \nWirecard mPOS SDK Integration\n.\n\n\nThe SUPR Accept SDK enables the creation of iOS and Android app functionality that expands the number of payment methods that merchants can accept from their consumers, including Visa, Mastercard, Alipay, WeChatPay and SEPA. Cash can also be accepted and processed so that merchants can process all transactions through a single app created with the help of the SUPR Accept SDK.\n\n\n\n\nNote\n\n\nA Windows Mobile version of the SUPR Accept SDK will be available shortly. Talk to your Wirecard representative for more information.\n\n\n\n\nWho is this for?\n\n\nWirecard works with partners who use the SUPR Accept SDK to create payment acceptance app functionality for merchants. This documentation is for these partners. Partners are typically companies that specialize in software application development. Merchants are the actual end-users of the payment acceptance app functionality. Partners typically create app functionality to support payment acceptance by merchants, and this functionality is usually a subset of a larger app, so throughout this documentation we refer to the \nfunctionality\n that you create with the SDK as the \npayment acceptance app\n, even though it may not be a standalone app.\n\n\n\n\nTip\n\n\nIf you are new to the payment industry there are a lot of terms to learn. So, the terms partner, merchant, user, payment acceptance app and many others are all defined in the \nGlossary\n to help you with this task. The Glossary also has definitions for the most common acronyms you find on this documentation site, such as SEPA, mPOS and others.\n\n\n\n\nHow much is covered?\n\n\nEverything! Our goal is to provide all the information that our partners need to successfully create a payment acceptance app in the shortest possible time. So, we have introductory and overview information, architectural explanations, hardware/software setup information and detailed developer documentation, ranging from integration guides to comprehensive object class references. The \nUsing This Documentation\n chapter shows you how to use each section of this documentation site.\n\n\nHow technical is it?\n\n\nA partner team typically consists of a non-technical or semi-technical project manager and one or more developers who are technical. This documentation is for the whole team so the information here ranges from non-technical to very technical.\n\n\nWhat do I need to know?\n\n\nProject managers on the technical team do not require any specific skills. Developers should have these skills:\n\n\n\n\niOS developers\n - basic understanding of development with XCode and the programming language you choose to use (either Objective-C or Swift)\n\n\nAndroid developers\n - basic understanding of your Android development environment and the Java programming language\n\n\n\n\nFor both types of developers, a basic understanding of object-oriented design concepts and terminology is also recommended.\n\n\nWhere should I start?\n\n\nWe recommend you take a few minutes to read \nThe Basics\n chapter and then the \nUsing this Documentation\n chapter. Or, if you just want to jump in to the more technical information, you can read the \nThe mPOS Architecture\n first.\n\n\n\n\nTip\n\n\nFor developers who want to dive directly into the code which is available on Github, see the \nGithub repository for iOS\n or the \nGithub repository for Android\n.\n\n\n\n\nVersion: v011 - Aug 25", 
            "title": "Getting Started"
        }, 
        {
            "location": "/start/#welcome-to-the-supr-accept-sdk-partner-documentation", 
            "text": "The  SUPR Accept SDK  is part of Wirecard's range of mobile Point of Sale (mPOS) products and solutions. For complete information about all of Wirecard's mPOS solutions, see  Wirecard mPOS SDK Integration .  The SUPR Accept SDK enables the creation of iOS and Android app functionality that expands the number of payment methods that merchants can accept from their consumers, including Visa, Mastercard, Alipay, WeChatPay and SEPA. Cash can also be accepted and processed so that merchants can process all transactions through a single app created with the help of the SUPR Accept SDK.   Note  A Windows Mobile version of the SUPR Accept SDK will be available shortly. Talk to your Wirecard representative for more information.", 
            "title": "Welcome to the SUPR Accept SDK Partner Documentation"
        }, 
        {
            "location": "/start/#who-is-this-for", 
            "text": "Wirecard works with partners who use the SUPR Accept SDK to create payment acceptance app functionality for merchants. This documentation is for these partners. Partners are typically companies that specialize in software application development. Merchants are the actual end-users of the payment acceptance app functionality. Partners typically create app functionality to support payment acceptance by merchants, and this functionality is usually a subset of a larger app, so throughout this documentation we refer to the  functionality  that you create with the SDK as the  payment acceptance app , even though it may not be a standalone app.   Tip  If you are new to the payment industry there are a lot of terms to learn. So, the terms partner, merchant, user, payment acceptance app and many others are all defined in the  Glossary  to help you with this task. The Glossary also has definitions for the most common acronyms you find on this documentation site, such as SEPA, mPOS and others.", 
            "title": "Who is this for?"
        }, 
        {
            "location": "/start/#how-much-is-covered", 
            "text": "Everything! Our goal is to provide all the information that our partners need to successfully create a payment acceptance app in the shortest possible time. So, we have introductory and overview information, architectural explanations, hardware/software setup information and detailed developer documentation, ranging from integration guides to comprehensive object class references. The  Using This Documentation  chapter shows you how to use each section of this documentation site.", 
            "title": "How much is covered?"
        }, 
        {
            "location": "/start/#how-technical-is-it", 
            "text": "A partner team typically consists of a non-technical or semi-technical project manager and one or more developers who are technical. This documentation is for the whole team so the information here ranges from non-technical to very technical.", 
            "title": "How technical is it?"
        }, 
        {
            "location": "/start/#what-do-i-need-to-know", 
            "text": "Project managers on the technical team do not require any specific skills. Developers should have these skills:   iOS developers  - basic understanding of development with XCode and the programming language you choose to use (either Objective-C or Swift)  Android developers  - basic understanding of your Android development environment and the Java programming language   For both types of developers, a basic understanding of object-oriented design concepts and terminology is also recommended.", 
            "title": "What do I need to know?"
        }, 
        {
            "location": "/start/#where-should-i-start", 
            "text": "We recommend you take a few minutes to read  The Basics  chapter and then the  Using this Documentation  chapter. Or, if you just want to jump in to the more technical information, you can read the  The mPOS Architecture  first.   Tip  For developers who want to dive directly into the code which is available on Github, see the  Github repository for iOS  or the  Github repository for Android .   Version: v011 - Aug 25", 
            "title": "Where should I start?"
        }, 
        {
            "location": "/basics/", 
            "text": "The Basics\n\n\nThis chapter has all of the key information you need to know right away, such as which payment options are supported, what the prerequisites are before you set up the SDKs, how to find the SDK files and how to get technical support.\n\n\nWhat does it do?\n\n\nThe SUPR Accept SDK enables our partners to create payment acceptance app functionality for merchants. Merchants can then expand the range of payment acceptance options that they can offer to customers, including a variety of both cashless and cash payment methods.\n\n\nHow many versions have there been?\n\n\nThis is the second major version of the Accept SDK, which is why it is referred to as version 2.0.\n\n\nWhich payments methods are supported?\n\n\nCash\n\n\nIf you enable the Cash Management feature, you can use the SDK to create cash payment acceptance functionality.\n\n\nCard\n\n\nYou can also use the SDK to create functionality to accept payments from:\n\n\n\n\nVisa\n\n\nMastercard\n\n\n\n\nAlternative Payment Methods\n\n\nThe following alternative payment methods can also be accepted:\n\n\n\n\nAlipay\n\n\nWeChat Pay\n\n\nSEPA\n\n\n\n\nWhich transaction types are supported?\n\n\nThe following payment operations are supported:\n\n\n\n\nPurchase\n\n\nAuthorize and Pre-authorize\n\n\nCapture\n\n\nReversal\n\n\nRefund (both partial and full)\n\n\n\n\nWhat are the prerequisites for using the SDK?\n\n\nThese are the prerequisites for both iOS and Android:\n\n\n\n\niOS - v9.0 or higher\n\n\nAndroid - v4.0 or higher\n\n\nAndroid Studio\n\n\n\n\nHow do I find and install the SDK?\n\n\nThe two SDKs are available on Github:\n\n\n\n\nGithub repository for Android\n.\n\n\nGithub repository for iOS\n\n\n\n\nSetup instructions are provided on this site:\n\n\n\n\nfor Android, see the \nSet up on Android\n section of this website, starting with the \nAutomated Setup with JitPack\n chapter\n\n\nfor iOS, see the \nSet up on iOS\n section of this website, starting with the \nAutomated Setup with Cocoapods\n chapter\n\n\n\n\nIs there sample code?\n\n\nYes! We provide a wealth of sample code to help you integrate the SDK. The sample code is provided using \nGists\n, a code distribution mechanism that is part of Github. Gists are Git repositories so they can be forked and cloned in the same way as a standard Git repository. The \nIntegrating the SDK\n section of this website describes each sample code snippet in detail. Sample code is provided in the following programming languages:\n\n\n\n\niOS: Objective-C\n\n\niOS: Swift\n\n\nAndroid: Java\n\n\n\n\nIs there integration testing code?\n\n\nYes, for both Android and iOS, a complete set of integration test code is provided, from user authentication to sales transaction processing, to hardware and ERP back-end testing. See \nAndroid Integration Tests\n and \niOS Integration Tests\n. \n\n\nHow do I get technical support?\n\n\nPlease email: \n\n\nWhich hardware is supported?\n\n\nPrinters\n\n\n\n\nDatecs printer \nDPP-250\n\n\nStarMicronics \nTSP650\n\n\n\n\nCash Drawer or Multi-function Devices\n\n\n\n\nStarMicronics \nmPOP\n\n\nStarMicronics \nSMD2\n\n\n\n\nHandheld Scanners\n\n\n\n\nSocketMobile \nSeries 7\n\n\n\n\nLicense\n\n\nSUPR Accept SDK is available under the MIT license. See the LICENSE file for more info.", 
            "title": "The Basics"
        }, 
        {
            "location": "/basics/#the-basics", 
            "text": "This chapter has all of the key information you need to know right away, such as which payment options are supported, what the prerequisites are before you set up the SDKs, how to find the SDK files and how to get technical support.", 
            "title": "The Basics"
        }, 
        {
            "location": "/basics/#what-does-it-do", 
            "text": "The SUPR Accept SDK enables our partners to create payment acceptance app functionality for merchants. Merchants can then expand the range of payment acceptance options that they can offer to customers, including a variety of both cashless and cash payment methods.", 
            "title": "What does it do?"
        }, 
        {
            "location": "/basics/#how-many-versions-have-there-been", 
            "text": "This is the second major version of the Accept SDK, which is why it is referred to as version 2.0.", 
            "title": "How many versions have there been?"
        }, 
        {
            "location": "/basics/#which-payments-methods-are-supported", 
            "text": "", 
            "title": "Which payments methods are supported?"
        }, 
        {
            "location": "/basics/#cash", 
            "text": "If you enable the Cash Management feature, you can use the SDK to create cash payment acceptance functionality.", 
            "title": "Cash"
        }, 
        {
            "location": "/basics/#card", 
            "text": "You can also use the SDK to create functionality to accept payments from:   Visa  Mastercard", 
            "title": "Card"
        }, 
        {
            "location": "/basics/#alternative-payment-methods", 
            "text": "The following alternative payment methods can also be accepted:   Alipay  WeChat Pay  SEPA", 
            "title": "Alternative Payment Methods"
        }, 
        {
            "location": "/basics/#which-transaction-types-are-supported", 
            "text": "The following payment operations are supported:   Purchase  Authorize and Pre-authorize  Capture  Reversal  Refund (both partial and full)", 
            "title": "Which transaction types are supported?"
        }, 
        {
            "location": "/basics/#what-are-the-prerequisites-for-using-the-sdk", 
            "text": "These are the prerequisites for both iOS and Android:   iOS - v9.0 or higher  Android - v4.0 or higher  Android Studio", 
            "title": "What are the prerequisites for using the SDK?"
        }, 
        {
            "location": "/basics/#how-do-i-find-and-install-the-sdk", 
            "text": "The two SDKs are available on Github:   Github repository for Android .  Github repository for iOS   Setup instructions are provided on this site:   for Android, see the  Set up on Android  section of this website, starting with the  Automated Setup with JitPack  chapter  for iOS, see the  Set up on iOS  section of this website, starting with the  Automated Setup with Cocoapods  chapter", 
            "title": "How do I find and install the SDK?"
        }, 
        {
            "location": "/basics/#is-there-sample-code", 
            "text": "Yes! We provide a wealth of sample code to help you integrate the SDK. The sample code is provided using  Gists , a code distribution mechanism that is part of Github. Gists are Git repositories so they can be forked and cloned in the same way as a standard Git repository. The  Integrating the SDK  section of this website describes each sample code snippet in detail. Sample code is provided in the following programming languages:   iOS: Objective-C  iOS: Swift  Android: Java", 
            "title": "Is there sample code?"
        }, 
        {
            "location": "/basics/#is-there-integration-testing-code", 
            "text": "Yes, for both Android and iOS, a complete set of integration test code is provided, from user authentication to sales transaction processing, to hardware and ERP back-end testing. See  Android Integration Tests  and  iOS Integration Tests .", 
            "title": "Is there integration testing code?"
        }, 
        {
            "location": "/basics/#how-do-i-get-technical-support", 
            "text": "Please email:", 
            "title": "How do I get technical support?"
        }, 
        {
            "location": "/basics/#which-hardware-is-supported", 
            "text": "", 
            "title": "Which hardware is supported?"
        }, 
        {
            "location": "/basics/#printers", 
            "text": "Datecs printer  DPP-250  StarMicronics  TSP650", 
            "title": "Printers"
        }, 
        {
            "location": "/basics/#cash-drawer-or-multi-function-devices", 
            "text": "StarMicronics  mPOP  StarMicronics  SMD2", 
            "title": "Cash Drawer or Multi-function Devices"
        }, 
        {
            "location": "/basics/#handheld-scanners", 
            "text": "SocketMobile  Series 7", 
            "title": "Handheld Scanners"
        }, 
        {
            "location": "/basics/#license", 
            "text": "SUPR Accept SDK is available under the MIT license. See the LICENSE file for more info.", 
            "title": "License"
        }, 
        {
            "location": "/using/", 
            "text": "Using This Documentation\n\n\nThis topic has a brief overview of the sections of this documentation and how to use each of them. The sections display in the table of contents that always appears on the left side of the window. We refer to this as the \nOverall Table of Contents\n because there is also a table of contents on the right side of the window and this is referred to as the \nChapter Table of Contents\n. The Chapter Table of Contents lists the headings that make up each individual chapter.\n\n\n\n\nNote\n\n\nOn smaller screens and mobile devices, the Overall Table of Contents is not shown on the left side of the window. Instead, it is available through a burger-menu that displays in the upper-left corner of the window. The burger-menu looks like this: \n\n\n\n\nStart\n\n\nThe \nStart\n section helps you get oriented. After this topic, there are two more really important ones you should read:\n\n\n\n\n\n\nThe \nmPOS Architecture\n topic is for the entire project team, but in particular, it is for the project manager. It helps you understand the big picture by providing basic information about the overall mobile Point of Sale (mPOS) architecture and how the SUPR Accept SDK fits into it. It describes the full circle of the payment process, from acceptance of the consumer's payment by the merchant to processing by Wirecard's Switch back-end to the Acquiring Platform, and ultimately, to the Issuer who charges the consumer for the payment.\n\n\n\n\n\n\nThe \nSDK Architecture\n topic introduces the nine components that comprise the SUPR Accept SDK. It is non-platform-specific so project managers should find it particularly useful in terms of familiarizing themselves with the key functionality of the SDK. Developers should also find it useful for understanding the overall design which applies to both the Android code and the iOS code.\n\n\n\n\n\n\nSetup\n\n\nThe \nSetup\n section has several topics that describe how to set up your development environment for both iOS and Android, including automated and manual installs.\n\n\nIntegrate\n\n\nThe \nIntegrate\n section is useful for everyone on your project team, although it is more for developers than project managers. It explains each of the individual components and it describes key concepts related to implementing the SUPR Accept SDK, such as how Sale Requests work, how payments are configured, how purchases, returns and reversals are processed.\n\n\nIt also has information on additional features such as the Inventory Manager which is where you can set up a product catalogue, as well as the Cash Manager component. The general descriptions of the components are non-platform-specific, however, platform-specific code is available in the chapters of this section. The code is conveniently stored in \nGIST\n.  Code is available in the following languages:\n\n\n\n\nSwift for iOS\n\n\nObjective-C for iOS\n\n\nJava for Android\n\n\n\n\nReferences\n\n\nThe \nReferences\n section actually has hundreds of pages of useful information, particularly for developers. It\n\n\n\n\n\n\nThe \nReference - Android SDK\n topic, which is below the \nReferences\n section, has detailed object class, method and property information for all of the Java code. This link actually takes you to a \nsub-site\n that is auto-generated directly from the code itself. This section is for developers implementing the SDK using Java.\n\n\n\n\n\n\nThe \nReference - iOS SDK\n topic, which is below the \nReferences\n section, has detailed object class, method and property information for all of the Objective-C code and Swift code. This link actually takes you to a \nsub-site\n that is auto-generated directly from the code itself. Included are useful class inheritance diagrams and collaboration diagrams. This section is for iOS developers implementing the SDK using Objective-C or Swift.\n\n\n\n\n\n\nGlossary\n\n\nIf you are new to the world of payment transactions then you may find all the acronyms and other terminology a bit overwhelming. The \nGlossary\n addresses this by providing a complete list of acronyms and what they stand for, as well as definitions of all key terminology used in this documentation. This section is for everyone on the project team.", 
            "title": "Using this Documentation"
        }, 
        {
            "location": "/using/#using-this-documentation", 
            "text": "This topic has a brief overview of the sections of this documentation and how to use each of them. The sections display in the table of contents that always appears on the left side of the window. We refer to this as the  Overall Table of Contents  because there is also a table of contents on the right side of the window and this is referred to as the  Chapter Table of Contents . The Chapter Table of Contents lists the headings that make up each individual chapter.   Note  On smaller screens and mobile devices, the Overall Table of Contents is not shown on the left side of the window. Instead, it is available through a burger-menu that displays in the upper-left corner of the window. The burger-menu looks like this:", 
            "title": "Using This Documentation"
        }, 
        {
            "location": "/using/#start", 
            "text": "The  Start  section helps you get oriented. After this topic, there are two more really important ones you should read:    The  mPOS Architecture  topic is for the entire project team, but in particular, it is for the project manager. It helps you understand the big picture by providing basic information about the overall mobile Point of Sale (mPOS) architecture and how the SUPR Accept SDK fits into it. It describes the full circle of the payment process, from acceptance of the consumer's payment by the merchant to processing by Wirecard's Switch back-end to the Acquiring Platform, and ultimately, to the Issuer who charges the consumer for the payment.    The  SDK Architecture  topic introduces the nine components that comprise the SUPR Accept SDK. It is non-platform-specific so project managers should find it particularly useful in terms of familiarizing themselves with the key functionality of the SDK. Developers should also find it useful for understanding the overall design which applies to both the Android code and the iOS code.", 
            "title": "Start"
        }, 
        {
            "location": "/using/#setup", 
            "text": "The  Setup  section has several topics that describe how to set up your development environment for both iOS and Android, including automated and manual installs.", 
            "title": "Setup"
        }, 
        {
            "location": "/using/#integrate", 
            "text": "The  Integrate  section is useful for everyone on your project team, although it is more for developers than project managers. It explains each of the individual components and it describes key concepts related to implementing the SUPR Accept SDK, such as how Sale Requests work, how payments are configured, how purchases, returns and reversals are processed.  It also has information on additional features such as the Inventory Manager which is where you can set up a product catalogue, as well as the Cash Manager component. The general descriptions of the components are non-platform-specific, however, platform-specific code is available in the chapters of this section. The code is conveniently stored in  GIST .  Code is available in the following languages:   Swift for iOS  Objective-C for iOS  Java for Android", 
            "title": "Integrate"
        }, 
        {
            "location": "/using/#references", 
            "text": "The  References  section actually has hundreds of pages of useful information, particularly for developers. It    The  Reference - Android SDK  topic, which is below the  References  section, has detailed object class, method and property information for all of the Java code. This link actually takes you to a  sub-site  that is auto-generated directly from the code itself. This section is for developers implementing the SDK using Java.    The  Reference - iOS SDK  topic, which is below the  References  section, has detailed object class, method and property information for all of the Objective-C code and Swift code. This link actually takes you to a  sub-site  that is auto-generated directly from the code itself. Included are useful class inheritance diagrams and collaboration diagrams. This section is for iOS developers implementing the SDK using Objective-C or Swift.", 
            "title": "References"
        }, 
        {
            "location": "/using/#glossary", 
            "text": "If you are new to the world of payment transactions then you may find all the acronyms and other terminology a bit overwhelming. The  Glossary  addresses this by providing a complete list of acronyms and what they stand for, as well as definitions of all key terminology used in this documentation. This section is for everyone on the project team.", 
            "title": "Glossary"
        }, 
        {
            "location": "/mpos-architecture/", 
            "text": "The mPOS Architecture\n\n\nThis chapter describes the overall mPOS architecture to help you understand how the payment acceptance app that you create fits into the bigger picture. In particular, it examines the other Wirecard and non-Wirecard components that are involved in the overall process of processing a consumer sales transaction so that you can see how a payment comes full circle. It also examines the use of an Enterprise Resource Planning (ERP) system to augment the Switch back-end provided by Wirecard.\n\n\nPartners, Merchants and Consumers\n\n\nAs illustrated below, the \nSUPR Accept SDK\n enables our \npartners\n to create payment acceptance app functionality for \nmerchants\n.\n\n\n\n\nThe resulting app can be a standalone app or part of a larger app. When the payment acceptance app is completed and put into production at the merchant's place of business, the merchant's staff use the payment acceptance app on their iOS and Android mobile devices to accept cash, credit and Alipay payments from consumers. A terminal must be set up on mobile devices that will accept credit.\n\n\nThe cash acceptance feature of the SDK is referred to as Cash Management. Cash Management must be set up in the back-end before enabling it with the SDK. Talk to your Wirecard representative for complete information about Cash Management, and see \nSDK Architecture\n for overview information and \nCash Manager Overview\n for detailed information.\n\n\nExtensive Hardware Support\n\n\nIn addition to a terminal, the following hardware can also be paired to the mobile device that has the payment acceptance app installed and running:\n\n\n\n\na printer for printing receipts\n\n\na pistol scanner for scanning QR codes and barcodes\n\n\na cash register or cash drawer to enable the handling of cash payments\n\n\n\n\nThe SDK has extensive support for all of these devices. See the \nGetting Started\n chapter for a list of currently supported hardware devices. The \nIntegrating the SDK\n section of this website has complete information.\n\n\n\n\nTip\n\n\nFour components of the SDK architecture handle the four different types of hardware, as described in the \nnext chapter\n.\n\n\n\n\n\n\nNote\n\n\nTo enable Cash Management, you require cash drawer hardware. See the \nCash Manager Overview\n chapter for more information about Cash Management.\n\n\n\n\nSwitch, Gateway and the Acquiring Platform\n\n\nThe payment acceptance app is a front-end application. The corresponding back-end is \nSwitch\n. Each merchant must first be set up on Switch before they can use SUPR Accept SDK. There is a Switch GUI application that allows merchants to set up and change their back-end data. This is useful, for example, to set up product catalogues and products that display in front-end apps created with the SDK. Talk to your Wirecard representative for more information about Switch.\n\n\nSwitch itself is actually an intermediary proxy that connects to other Wirecard systems, starting with the \nWirecard Gateway\n. The Gateway, in turn, does the initial processing and then routes transactions to the \nAcquiring Platform\n, as illustrated below:\n\n\n\n\n\n\nNote\n\n\nThe mPOS division at Wirecard is responsible for the SUPR Accept SDK and the Switch back-end. The Payment \n Risk division oversees the Wirecard Gateway and the Acquiring Platform.\n\n\n\n\nUsing an ERP\n\n\nA key implementation decision that each merchant must make before implementing mPOS is whether or not to use an \nERP\n tool to augment the Switch back-end. For example, ERP tools, like SAP Business ByDesign, can be particularly useful because while Switch allows you to define your products and product catalogues, ByDesign lets you manage stock levels of each of your products. Indeed, if a merchant already uses an ERP they will probably want to continue using it. Another reason to choose ByDesign, for example, is to leverage the initial investment in this software made by a merchant, because it is much easier to integrate into a system then to replace it with a new one.\n\n\nFor example, a merchant user at a shop that is using your payment acceptance app might run out of a certain item in their store. With an ERP connected, you can set up the app to check product stock levels at other stores.\n\n\n\n\nTip\n\n\nGetting \nProduct Stocks (ERP)\n information is covered later in this documentation, along with getting \nProduct Prices (ERP)\n. Both are part of the Inventory Manager component. The Customer Manager component also provides ERP-related functionality as described in \nCustomer Manager (ERP)\n.\n\n\n\n\nIf a merchant chooses to augment their back-end with an ERP, the architecture looks like this:\n\n\n\n\nCard Schemes and the Issuer\n\n\nThe \nAcquiring Platform\n handles the communication with the various \nCard Schemes\n. The Card Schemes process transactions through the Issuing Bank of the \nIssuer\n. Ultimately, the Issuer completes the circle by charging the consumer for the payment and, in turn, the consumer pays the Issuer.\n\n\n\n\nUltimately, payment acceptance is about helping merchants generate more sales from their consumers by giving them more options for accepting payments. As the diagram above illustrates, Wirecard provides everything you need to do just this.", 
            "title": "The mPOS Architecture"
        }, 
        {
            "location": "/mpos-architecture/#the-mpos-architecture", 
            "text": "This chapter describes the overall mPOS architecture to help you understand how the payment acceptance app that you create fits into the bigger picture. In particular, it examines the other Wirecard and non-Wirecard components that are involved in the overall process of processing a consumer sales transaction so that you can see how a payment comes full circle. It also examines the use of an Enterprise Resource Planning (ERP) system to augment the Switch back-end provided by Wirecard.", 
            "title": "The mPOS Architecture"
        }, 
        {
            "location": "/mpos-architecture/#partners-merchants-and-consumers", 
            "text": "As illustrated below, the  SUPR Accept SDK  enables our  partners  to create payment acceptance app functionality for  merchants .   The resulting app can be a standalone app or part of a larger app. When the payment acceptance app is completed and put into production at the merchant's place of business, the merchant's staff use the payment acceptance app on their iOS and Android mobile devices to accept cash, credit and Alipay payments from consumers. A terminal must be set up on mobile devices that will accept credit.  The cash acceptance feature of the SDK is referred to as Cash Management. Cash Management must be set up in the back-end before enabling it with the SDK. Talk to your Wirecard representative for complete information about Cash Management, and see  SDK Architecture  for overview information and  Cash Manager Overview  for detailed information.", 
            "title": "Partners, Merchants and Consumers"
        }, 
        {
            "location": "/mpos-architecture/#extensive-hardware-support", 
            "text": "In addition to a terminal, the following hardware can also be paired to the mobile device that has the payment acceptance app installed and running:   a printer for printing receipts  a pistol scanner for scanning QR codes and barcodes  a cash register or cash drawer to enable the handling of cash payments   The SDK has extensive support for all of these devices. See the  Getting Started  chapter for a list of currently supported hardware devices. The  Integrating the SDK  section of this website has complete information.   Tip  Four components of the SDK architecture handle the four different types of hardware, as described in the  next chapter .    Note  To enable Cash Management, you require cash drawer hardware. See the  Cash Manager Overview  chapter for more information about Cash Management.", 
            "title": "Extensive Hardware Support"
        }, 
        {
            "location": "/mpos-architecture/#switch-gateway-and-the-acquiring-platform", 
            "text": "The payment acceptance app is a front-end application. The corresponding back-end is  Switch . Each merchant must first be set up on Switch before they can use SUPR Accept SDK. There is a Switch GUI application that allows merchants to set up and change their back-end data. This is useful, for example, to set up product catalogues and products that display in front-end apps created with the SDK. Talk to your Wirecard representative for more information about Switch.  Switch itself is actually an intermediary proxy that connects to other Wirecard systems, starting with the  Wirecard Gateway . The Gateway, in turn, does the initial processing and then routes transactions to the  Acquiring Platform , as illustrated below:    Note  The mPOS division at Wirecard is responsible for the SUPR Accept SDK and the Switch back-end. The Payment   Risk division oversees the Wirecard Gateway and the Acquiring Platform.", 
            "title": "Switch, Gateway and the Acquiring Platform"
        }, 
        {
            "location": "/mpos-architecture/#using-an-erp", 
            "text": "A key implementation decision that each merchant must make before implementing mPOS is whether or not to use an  ERP  tool to augment the Switch back-end. For example, ERP tools, like SAP Business ByDesign, can be particularly useful because while Switch allows you to define your products and product catalogues, ByDesign lets you manage stock levels of each of your products. Indeed, if a merchant already uses an ERP they will probably want to continue using it. Another reason to choose ByDesign, for example, is to leverage the initial investment in this software made by a merchant, because it is much easier to integrate into a system then to replace it with a new one.  For example, a merchant user at a shop that is using your payment acceptance app might run out of a certain item in their store. With an ERP connected, you can set up the app to check product stock levels at other stores.   Tip  Getting  Product Stocks (ERP)  information is covered later in this documentation, along with getting  Product Prices (ERP) . Both are part of the Inventory Manager component. The Customer Manager component also provides ERP-related functionality as described in  Customer Manager (ERP) .   If a merchant chooses to augment their back-end with an ERP, the architecture looks like this:", 
            "title": "Using an ERP"
        }, 
        {
            "location": "/mpos-architecture/#card-schemes-and-the-issuer", 
            "text": "The  Acquiring Platform  handles the communication with the various  Card Schemes . The Card Schemes process transactions through the Issuing Bank of the  Issuer . Ultimately, the Issuer completes the circle by charging the consumer for the payment and, in turn, the consumer pays the Issuer.   Ultimately, payment acceptance is about helping merchants generate more sales from their consumers by giving them more options for accepting payments. As the diagram above illustrates, Wirecard provides everything you need to do just this.", 
            "title": "Card Schemes and the Issuer"
        }, 
        {
            "location": "/sdk-architecture/", 
            "text": "The SDK Architecture\n\n\nThe SUPR Accept SDK is designed to be platform-non-specific so that the apps you build using the SDK can also be largely designed in a platform-non-specific way. The architecture is comprised of nine main components, as illustrated below:\n\n\n\n\n\n\nNote\n\n\nWhile the actual component and object class names in the code vary slightly from the picture, based on the platform and programming language, the component names are all very similar. For example, the Sales Manager component is implemented as \nsalesManager\n in the Objective-C code and \nsales()\n in the Java code.\n\n\n\n\nEach component is essentially an Application Programming Interface (API) with public calls that greatly simplify your job of creating payment acceptance app functionality. The Integration Guide walks you through each component in detail and presents platform-specific code to show you exactly how to implement. Let's look at each component in more detail.\n\n\n\n\nNote\n\n\nAll nine components are fully implemented on iOS, however, some of the components are not yet fully implemented on Android. Talk to your Wirecard representative for more information.\n\n\n\n\nSales Manager\n\n\nSales are the lifeblood of any merchant so the \nSales Manager\n component is the centerpiece of the SDK.\n\n\n\n\nA sale consists of a Sales Request and a Sales Response. The Sales Request is essentially what the consumer wants, which is typically a purchase (but it can also be a Return or Refund). A Sales Response is the post-processed information from the back-end, essentially indicating if the payment was successful or not.\n\n\n\n\nCaution\n\n\nA sale is not the same thing as a transaction. This is because a sale may involve more than one transaction, for example, if a consumer pays for a single sale with a card and cash.\n\n\n\n\nInventory Manager\n\n\nInventory Manager\n enables you to:\n\n\n\n\nmaintain product catalogues\n\n\nmaintain product categories\n\n\nmaintain products\n\n\nmaintain product images\n\n\n\n\nIn addition, if the merchant uses an ERP system, it also enables:\n\n\n\n\nuse of product stock information stored in the ERP\n\n\nuse of product price information stored in the ERP\n\n\n\n\nThe Inventory Manager component is highlighted below:\n\n\n\n\nCash Management Components\n\n\nThe SUPR Accept SDK is a comprehensive solution for merchants, so Cash Management is a key feature that merchants can choose to use. Cash Management is a feature that is enabled by two components:\n\n\n\n\nThe \nCash Manager\n component handles all of the cash-related operations that take place in a merchant's shop, such as opening and closing of shifts, paying in and out, and so forth.\n\n\nThe \nCash Drawer Manager\n component is one of four components that handles hardware that may be paired with the merchant user's mobile device. Specifically, it handles any cash drawer hardware or cash register hardware that may be paired.\n\n\n\n\nThese two components are highlighted below:\n\n\n\n\nHardware Components\n\n\nFour of the nine components in the SDK architecture enable the management of hardware. They are highlighted below:\n\n\n\n\nTerminal Manager\n\n\nThe \nTerminal Manager\n component enables the discovery and usage of paired terminal devices, as well as the updating of firmware.\n\n\nCash Drawer Manager\n\n\nAs described earlier, the \nCash Drawer Manager\n component enables the discovery and usage of paired cash drawers and cash registers.\n\n\nPrinter Manager\n\n\nThe \nPrinter Manager\n component enables the discovery and usage of paired printer devices, primarily for the printing of receipts.\n\n\nScanner Manager\n\n\nThis \nScanner Manager\n component enables the discovery and usage of paired scanning devices, which are used to scan QR codes and barcodes.\n\n\nCustomer and User Management\n\n\nTwo supplementary components assist with handling customers and users.\n\n\n\n\nCustomer Manager (ERP)\n\n\nERP systems store a wide variety of useful information about a merchant's customers, such as pricing discounts and so forth. The \nCustomer Manager\n component enables the use of this information.\n\n\nUser Manager\n\n\nApps created with the SDK are typically part of a larger app, so you may not need to handle authentication of users, passwords and so forth. But if you do need to handle these things, the \nUser Manager\n component has a variety of useful functionality, including:\n\n\n\n\nPassword Policy checks\n\n\nPassword Resets\n\n\nReminder User of Password\n\n\nChange Password", 
            "title": "The SDK Architecture"
        }, 
        {
            "location": "/sdk-architecture/#the-sdk-architecture", 
            "text": "The SUPR Accept SDK is designed to be platform-non-specific so that the apps you build using the SDK can also be largely designed in a platform-non-specific way. The architecture is comprised of nine main components, as illustrated below:    Note  While the actual component and object class names in the code vary slightly from the picture, based on the platform and programming language, the component names are all very similar. For example, the Sales Manager component is implemented as  salesManager  in the Objective-C code and  sales()  in the Java code.   Each component is essentially an Application Programming Interface (API) with public calls that greatly simplify your job of creating payment acceptance app functionality. The Integration Guide walks you through each component in detail and presents platform-specific code to show you exactly how to implement. Let's look at each component in more detail.   Note  All nine components are fully implemented on iOS, however, some of the components are not yet fully implemented on Android. Talk to your Wirecard representative for more information.", 
            "title": "The SDK Architecture"
        }, 
        {
            "location": "/sdk-architecture/#sales-manager", 
            "text": "Sales are the lifeblood of any merchant so the  Sales Manager  component is the centerpiece of the SDK.   A sale consists of a Sales Request and a Sales Response. The Sales Request is essentially what the consumer wants, which is typically a purchase (but it can also be a Return or Refund). A Sales Response is the post-processed information from the back-end, essentially indicating if the payment was successful or not.   Caution  A sale is not the same thing as a transaction. This is because a sale may involve more than one transaction, for example, if a consumer pays for a single sale with a card and cash.", 
            "title": "Sales Manager"
        }, 
        {
            "location": "/sdk-architecture/#inventory-manager", 
            "text": "Inventory Manager  enables you to:   maintain product catalogues  maintain product categories  maintain products  maintain product images   In addition, if the merchant uses an ERP system, it also enables:   use of product stock information stored in the ERP  use of product price information stored in the ERP   The Inventory Manager component is highlighted below:", 
            "title": "Inventory Manager"
        }, 
        {
            "location": "/sdk-architecture/#cash-management-components", 
            "text": "The SUPR Accept SDK is a comprehensive solution for merchants, so Cash Management is a key feature that merchants can choose to use. Cash Management is a feature that is enabled by two components:   The  Cash Manager  component handles all of the cash-related operations that take place in a merchant's shop, such as opening and closing of shifts, paying in and out, and so forth.  The  Cash Drawer Manager  component is one of four components that handles hardware that may be paired with the merchant user's mobile device. Specifically, it handles any cash drawer hardware or cash register hardware that may be paired.   These two components are highlighted below:", 
            "title": "Cash Management Components"
        }, 
        {
            "location": "/sdk-architecture/#hardware-components", 
            "text": "Four of the nine components in the SDK architecture enable the management of hardware. They are highlighted below:", 
            "title": "Hardware Components"
        }, 
        {
            "location": "/sdk-architecture/#terminal-manager", 
            "text": "The  Terminal Manager  component enables the discovery and usage of paired terminal devices, as well as the updating of firmware.", 
            "title": "Terminal Manager"
        }, 
        {
            "location": "/sdk-architecture/#cash-drawer-manager", 
            "text": "As described earlier, the  Cash Drawer Manager  component enables the discovery and usage of paired cash drawers and cash registers.", 
            "title": "Cash Drawer Manager"
        }, 
        {
            "location": "/sdk-architecture/#printer-manager", 
            "text": "The  Printer Manager  component enables the discovery and usage of paired printer devices, primarily for the printing of receipts.", 
            "title": "Printer Manager"
        }, 
        {
            "location": "/sdk-architecture/#scanner-manager", 
            "text": "This  Scanner Manager  component enables the discovery and usage of paired scanning devices, which are used to scan QR codes and barcodes.", 
            "title": "Scanner Manager"
        }, 
        {
            "location": "/sdk-architecture/#customer-and-user-management", 
            "text": "Two supplementary components assist with handling customers and users.", 
            "title": "Customer and User Management"
        }, 
        {
            "location": "/sdk-architecture/#customer-manager-erp", 
            "text": "ERP systems store a wide variety of useful information about a merchant's customers, such as pricing discounts and so forth. The  Customer Manager  component enables the use of this information.", 
            "title": "Customer Manager (ERP)"
        }, 
        {
            "location": "/sdk-architecture/#user-manager", 
            "text": "Apps created with the SDK are typically part of a larger app, so you may not need to handle authentication of users, passwords and so forth. But if you do need to handle these things, the  User Manager  component has a variety of useful functionality, including:   Password Policy checks  Password Resets  Reminder User of Password  Change Password", 
            "title": "User Manager"
        }, 
        {
            "location": "/int-setup-android-gradle/", 
            "text": "Automated Setup with Jitpack\n\n\nHassle-free setup on Android is now available with v2.0 of the SDK, using \nJitpack\n. Jitpack is a package repository tool specifically designed to work with Github. So all you have to do is add some lines to your gradle file and the appropriate Android SDK files from Github are included in your build. \n\n\n\n\nCaution\n\n\nThe minimum API level supported by this library is API 14 (Ice Cream Sandwich). \n\n\n\n\nAdd the following lines to your root \nbuild.gradle\n file to include the SDK in your Android Studio project:\n\n\nallprojects {\n    repositories {\n        maven { url \nhttps://jitpack.io\n }\n    }\n}\n\n//...\n\ndefaultConfig {\n    multiDexEnabled true\n}\n\ndependencies {\n    //main AcceptSDK2 dependency\n    compile \ncom.github.mposSVK:AcceptSDK2-Android:2.0.0\n\n\n    //AcceptSDL2 Extension for Datecs printer\n    compile \ncom.github.mposSVK:AcceptExtensionDatecs-Android:2.0.0\n\n\n    //multidex\n    compile \ncom.android.support:multidex:1.0.1\n\n}", 
            "title": "Automated Setup with Jitpack"
        }, 
        {
            "location": "/int-setup-android-gradle/#automated-setup-with-jitpack", 
            "text": "Hassle-free setup on Android is now available with v2.0 of the SDK, using  Jitpack . Jitpack is a package repository tool specifically designed to work with Github. So all you have to do is add some lines to your gradle file and the appropriate Android SDK files from Github are included in your build.    Caution  The minimum API level supported by this library is API 14 (Ice Cream Sandwich).    Add the following lines to your root  build.gradle  file to include the SDK in your Android Studio project:  allprojects {\n    repositories {\n        maven { url  https://jitpack.io  }\n    }\n}\n\n//...\n\ndefaultConfig {\n    multiDexEnabled true\n}\n\ndependencies {\n    //main AcceptSDK2 dependency\n    compile  com.github.mposSVK:AcceptSDK2-Android:2.0.0 \n\n    //AcceptSDL2 Extension for Datecs printer\n    compile  com.github.mposSVK:AcceptExtensionDatecs-Android:2.0.0 \n\n    //multidex\n    compile  com.android.support:multidex:1.0.1 \n}", 
            "title": "Automated Setup with Jitpack"
        }, 
        {
            "location": "/int-setup-android-manual/", 
            "text": "Set up Manually\n\n\nFollow the steps listed below to set up the SUPR Accept SDK for Android manually:\n\n\n\n\nDownload the SDK from the \nGithub repository for Android\n.\n\n\nManually add the .aar files which are stored in the \n/build\n directory.", 
            "title": "Set up Manually"
        }, 
        {
            "location": "/int-setup-android-manual/#set-up-manually", 
            "text": "Follow the steps listed below to set up the SUPR Accept SDK for Android manually:   Download the SDK from the  Github repository for Android .  Manually add the .aar files which are stored in the  /build  directory.", 
            "title": "Set up Manually"
        }, 
        {
            "location": "/int-tests-a/", 
            "text": "Android Integration Tests\n\n\nA variety of integration tests are provided in the \nexamples\n directory, as shown below:\n\n\n\n\nEach of these is described briefly below.\n\n\nAuthenticationTest.java\n\n\nProvides sample code with a variety of functionality from the User Manager component that you can use for testing, including:\n\n\n\n\nget the current user\n\n\nget active cashiers\n\n\nchange a password\n\n\nobtain the password policy\n\n\nPIN validation\n\n\n\n\nBaseDemoTest.java\n\n\nProvides a basic test of the demo application. \n\n\nCashTests.java\n\n\nProvides comprehensive code for testing the Cash Management feature, which is implemented in the Sales Manager and Cash Drawer components (the latter is also known as the Cash Register component). This includes:\n\n\n\n\nrequest user and cash register information\n\n\nshift management including opening a new shift\n\n\nshift reporting for any closed shifts\n\n\npay in/out reporting for shifts\n\n\nexecution of a cash sale\n\n\n\n\nCatalogueTests.java\n\n\nDemonstrates how to use a variety of functionality provided by the Inventory Manager to manage your catalogues, product categories and products, including:\n\n\n\n\nobtaining catalogue data\n\n\nidentifying changes in the data\n\n\n\n\nThis includes obtaining image data that you can use to display a visual catalogue in your payment acceptance app.\n\n\nInitializationTest.java\n\n\nDemonstrates how the SDK can be initialized, including adding extensions for hardware. Also shows how to update credentials using the \nupdateUserCredentials\n method. \n\n\nOtherTests.java\n\n\nMiscellaneous tests including getting the server time and date.\n\n\nPrinterTest.java\n\n\nEnables you to test the Printer Manager component, including:\n\n\n\n\ndetecting available printers\n\n\nprinting a receipt\n\n\n\n\nSalesTest.java\n\n\nIllustrates basic usage of the Sales Manager and User Manager components, including a basic login to get the current user followed by a simple retrieval of sales using the \ngetSales()\n method. \n\n\nStatsTest.java\n\n\nDemonstrates how to use the Sales Manager component to obtain sales statistics, based on a time period that you define, including:\n\n\n\n\nmaximum sale\n\n\nminimum sale\n\n\nsales turnover\n\n\n\n\nTerminalTest.java\n\n\nHelps you test features of the Terminal Manager component, including:\n\n\n\n\ndiscovery of terminals\n\n\ncheck for updates for the terminals\n\n\ncarry out a card sale with a Spire terminal\n\n\n\n\nUserTest.java\n\n\nShows how to use the User Manager component to:\n\n\n\n\ntest credentials and get a user\n\n\nremind the user of their password\n\n\nhelp a user reset their password", 
            "title": "Android Integration Tests"
        }, 
        {
            "location": "/int-tests-a/#android-integration-tests", 
            "text": "A variety of integration tests are provided in the  examples  directory, as shown below:   Each of these is described briefly below.", 
            "title": "Android Integration Tests"
        }, 
        {
            "location": "/int-tests-a/#authenticationtestjava", 
            "text": "Provides sample code with a variety of functionality from the User Manager component that you can use for testing, including:   get the current user  get active cashiers  change a password  obtain the password policy  PIN validation", 
            "title": "AuthenticationTest.java"
        }, 
        {
            "location": "/int-tests-a/#basedemotestjava", 
            "text": "Provides a basic test of the demo application.", 
            "title": "BaseDemoTest.java"
        }, 
        {
            "location": "/int-tests-a/#cashtestsjava", 
            "text": "Provides comprehensive code for testing the Cash Management feature, which is implemented in the Sales Manager and Cash Drawer components (the latter is also known as the Cash Register component). This includes:   request user and cash register information  shift management including opening a new shift  shift reporting for any closed shifts  pay in/out reporting for shifts  execution of a cash sale", 
            "title": "CashTests.java"
        }, 
        {
            "location": "/int-tests-a/#cataloguetestsjava", 
            "text": "Demonstrates how to use a variety of functionality provided by the Inventory Manager to manage your catalogues, product categories and products, including:   obtaining catalogue data  identifying changes in the data   This includes obtaining image data that you can use to display a visual catalogue in your payment acceptance app.", 
            "title": "CatalogueTests.java"
        }, 
        {
            "location": "/int-tests-a/#initializationtestjava", 
            "text": "Demonstrates how the SDK can be initialized, including adding extensions for hardware. Also shows how to update credentials using the  updateUserCredentials  method.", 
            "title": "InitializationTest.java"
        }, 
        {
            "location": "/int-tests-a/#othertestsjava", 
            "text": "Miscellaneous tests including getting the server time and date.", 
            "title": "OtherTests.java"
        }, 
        {
            "location": "/int-tests-a/#printertestjava", 
            "text": "Enables you to test the Printer Manager component, including:   detecting available printers  printing a receipt", 
            "title": "PrinterTest.java"
        }, 
        {
            "location": "/int-tests-a/#salestestjava", 
            "text": "Illustrates basic usage of the Sales Manager and User Manager components, including a basic login to get the current user followed by a simple retrieval of sales using the  getSales()  method.", 
            "title": "SalesTest.java"
        }, 
        {
            "location": "/int-tests-a/#statstestjava", 
            "text": "Demonstrates how to use the Sales Manager component to obtain sales statistics, based on a time period that you define, including:   maximum sale  minimum sale  sales turnover", 
            "title": "StatsTest.java"
        }, 
        {
            "location": "/int-tests-a/#terminaltestjava", 
            "text": "Helps you test features of the Terminal Manager component, including:   discovery of terminals  check for updates for the terminals  carry out a card sale with a Spire terminal", 
            "title": "TerminalTest.java"
        }, 
        {
            "location": "/int-tests-a/#usertestjava", 
            "text": "Shows how to use the User Manager component to:   test credentials and get a user  remind the user of their password  help a user reset their password", 
            "title": "UserTest.java"
        }, 
        {
            "location": "/int-initialization-android/", 
            "text": "Android SDK Initialization\n\n\nAfter you install the SDK in your own project, you can start to use the component functionality (i.e. the public APIs) of the SDK, but first, you need to initialize the SDK as shown in this chapter. Before looking at the code though, you should understand how the Public Test environment works.\n\n\nUsing the Public Test Environment\n\n\nAll Wirecard partners who develop with the SDK are provided with:\n\n\n\n\na Wirecard card reader hardware device that can be used for testing purposes\n\n\na user name and password that can be used to access the \nPublic Test\n back-end testing environment\n\n\n\n\nAs part of your initialization code (a sample of which is shown below), you must \npoint\n the SDK to a back-end \nenvironment\n. An environment essentially means a Switch back-end, as described in the \nmPOS Architecture\n. Eventually, you will point to the live/production environment of the merchant for whom you are developing the payment acceptance app. However, during development, you can take advantage of our Public Test environment. This is a fully-functional back-end that you can use throughout development and testing.\n\n\n\n\nNote\n\n\nTalk to your project manager if you do not yet have a user name and password for accessing Public Test. If your project manager does not yet have this information, email \n with a request to obtain a user name and password and include the relevant data from your partnership agreement. They will be happy to help you.\n\n\n\n\n\n\nTip\n\n\nWe often use the term \ncredentials\n to refer to both the user name and the password.\n\n\n\n\nThe AcceptSDK Class\n\n\nThe highest-level class in the object hierarchy for both platforms is the AcceptSDK class. The first step in using AcceptSDK is to instantiate this object class using the \nnew AcceptSdkBuilder\n method. It is recommended that you have only one instance of the \nAcceptSDK\n interface. \n\n\nThe Sample Code\n\n\nAs part of the instantiation, notice in the code below that the \nEnv\n is set to \nPUBLIC_TEST\n. This points your payment app to the Public Test Switch back-end. To work properly, valid credentials must be passed so substitute in your actual user name instead of \nusername\n and use your actual password instead of \npassword\n in the \nsetCredentials\n method. Also note that the extensions that you should include will depend on the hardware that you will use with the payment app. The Spire \nSpm2\n terminal is Wirecard's standard card reader device. \nDatecs\n is a commonly used printer. \n\n\n// imports of the SDK files\n\n\nimport\n \nde.wirecard.acceptsdk2.AcceptSDK\n;\n\n\nimport\n \nde.wirecard.acceptsdk2.AcceptSdkBuilder\n;\n\n\n\nimport\n \nde.wirecard.acceptsdk2.extension.datecs.DatecsPrinterExtension\n;\n\n\nimport\n \nde.wirecard.acceptsdk2.extension.spire.spm2.Spm2SpireTerminalExtension\n;\n\n\n\n//AcceptSdkBuilder provides convient way to create SDK by builder pattern with all required or optional parameters. \n\n\n//Best practice is keep this variable as singleton.\n\n\nAcceptSDK\n \naccept\n \n=\n \nnew\n \nAcceptSdkBuilder\n(\ngetContext\n(),\n \nEnv\n.\nPUBLIC_TEST\n)\n  \n//mandatory context and backend environment\n\n    \n.\nsetCredentials\n(\nnew\n \nUserCredentials\n(\nusername\n,\n \npassword\n))\n        \n//credentials are mandatory, but can be changed later\n\n    \n.\naddExtension\n(\nDatecsPrinterExtension\n.\ngetInstance\n())\n                 \n//extensions which will be used by SDK\n\n    \n.\naddExtension\n(\nSpm2SpireTerminalExtension\n.\ngetInstance\n())\n\n    \n.\naddExtension\n(\n/*another extension*/\n)\n\n    \n.\nbuild\n();\n                                                           \n//returns instance of AcceptSDK", 
            "title": "Android SDK Initialization"
        }, 
        {
            "location": "/int-initialization-android/#android-sdk-initialization", 
            "text": "After you install the SDK in your own project, you can start to use the component functionality (i.e. the public APIs) of the SDK, but first, you need to initialize the SDK as shown in this chapter. Before looking at the code though, you should understand how the Public Test environment works.", 
            "title": "Android SDK Initialization"
        }, 
        {
            "location": "/int-initialization-android/#using-the-public-test-environment", 
            "text": "All Wirecard partners who develop with the SDK are provided with:   a Wirecard card reader hardware device that can be used for testing purposes  a user name and password that can be used to access the  Public Test  back-end testing environment   As part of your initialization code (a sample of which is shown below), you must  point  the SDK to a back-end  environment . An environment essentially means a Switch back-end, as described in the  mPOS Architecture . Eventually, you will point to the live/production environment of the merchant for whom you are developing the payment acceptance app. However, during development, you can take advantage of our Public Test environment. This is a fully-functional back-end that you can use throughout development and testing.   Note  Talk to your project manager if you do not yet have a user name and password for accessing Public Test. If your project manager does not yet have this information, email   with a request to obtain a user name and password and include the relevant data from your partnership agreement. They will be happy to help you.    Tip  We often use the term  credentials  to refer to both the user name and the password.", 
            "title": "Using the Public Test Environment"
        }, 
        {
            "location": "/int-initialization-android/#the-acceptsdk-class", 
            "text": "The highest-level class in the object hierarchy for both platforms is the AcceptSDK class. The first step in using AcceptSDK is to instantiate this object class using the  new AcceptSdkBuilder  method. It is recommended that you have only one instance of the  AcceptSDK  interface.", 
            "title": "The AcceptSDK Class"
        }, 
        {
            "location": "/int-initialization-android/#the-sample-code", 
            "text": "As part of the instantiation, notice in the code below that the  Env  is set to  PUBLIC_TEST . This points your payment app to the Public Test Switch back-end. To work properly, valid credentials must be passed so substitute in your actual user name instead of  username  and use your actual password instead of  password  in the  setCredentials  method. Also note that the extensions that you should include will depend on the hardware that you will use with the payment app. The Spire  Spm2  terminal is Wirecard's standard card reader device.  Datecs  is a commonly used printer.   // imports of the SDK files  import   de.wirecard.acceptsdk2.AcceptSDK ;  import   de.wirecard.acceptsdk2.AcceptSdkBuilder ;  import   de.wirecard.acceptsdk2.extension.datecs.DatecsPrinterExtension ;  import   de.wirecard.acceptsdk2.extension.spire.spm2.Spm2SpireTerminalExtension ;  //AcceptSdkBuilder provides convient way to create SDK by builder pattern with all required or optional parameters.   //Best practice is keep this variable as singleton.  AcceptSDK   accept   =   new   AcceptSdkBuilder ( getContext (),   Env . PUBLIC_TEST )    //mandatory context and backend environment \n     . setCredentials ( new   UserCredentials ( username ,   password ))          //credentials are mandatory, but can be changed later \n     . addExtension ( DatecsPrinterExtension . getInstance ())                   //extensions which will be used by SDK \n     . addExtension ( Spm2SpireTerminalExtension . getInstance ()) \n     . addExtension ( /*another extension*/ ) \n     . build ();                                                             //returns instance of AcceptSDK", 
            "title": "The Sample Code"
        }, 
        {
            "location": "/int-ov-a/", 
            "text": "Android SDK Design Principles\n\n\nAcceptSDK heavily relies on RxJava2 reactive principles. To learn more about the observer pattern and RxJava, consult the documentation on \nRxJava's github\n or the official \nReactiveX webpage\n. Every call to AcceptSDK returns an object which extends the observer pattern. It allows you to:\n\n\n\n\nchoose between synchronous or asynchronous results\n\n\nmanage execution and result threads\n\n\nmanage a chain of methods by operators \n\n\nand much more\n\n\n\n\nCompletable, Single, Observable\n\n\nMost methods return \nCompletable\n or \nSingle\n object. They fulfil the observer pattern and can be used as regular RxJava observables. The result of a Completable object is a simple 'complete' answer, which indicates if everything was performed correctly. Single objects return as a response exactly one result, which is defined with generics. These two are used for most calls to SDK.\nObservable objects can return object defined by generics multiple times.\n\n\nCompletableParallel and SingleParallel\n\n\nThese two objects are special because they contain two separate rx streams:\n\n\n\n\nMain stream contains final result of request and \n\n\nSecond stream contains information update events, some progress information or even requests from the user. Second stream can be accessed using the subscribeParallel( ) method.\n\n\n\n\nHere is a recommended usage: \n\n\nimport\n \ncom.jakewharton.rxrelay2.BehaviorRelay\n;\n\n\nimport\n \ncom.jakewharton.rxrelay2.Relay\n;\n\n\nimport\n \nio.reactivex.android.schedulers.AndroidSchedulers\n;\n\n\n\n\nRelay\nEvent\n \neventObservable\n \n=\n \nBehaviorRelay\n.\ncreate\n();\n\n\n\naccept\n.\nmethodReturnsSingleParallel\n()\n\n    \n.\nsubscribeParallel\n(\neventObservable\n)\n\n    \n.\nobserveOn\n(\nAndroidSchedulers\n.\nmainThread\n())\n\n    \n.\nsubscribe\n(\nonSuccess\n \n-\n \n{\n\n            \n//do something on success\n\n        \n},\n \nonError\n \n-\n \n{\n\n            \n//show error\n\n        \n}\n\n    \n);\n\n\n\neventObservable\n\n    \n.\nobserveOn\n(\nAndroidSchedulers\n.\nmainThread\n())\n\n    \n.\nsubscribe\n(\nevent\n \n-\n \n{\n\n        \n//do something on event\n\n    \n});\n                                      \n\n\n\n\nSynchronous vs Asynchronous\n\n\nYou can choose which principle suits your algorithms best for every method call. \n\n\nSynchronous Methods\n\n\nA synchronous response can be achieved by calling one of these methods:\n\n\n//completable\n\n\naccept\n.\nmethodReturnsCompletable\n().\nblockingAwait\n()\n    \n//returns void or rethrows any exception emitted\n\n\naccept\n.\nmethodReturnsCompletable\n().\nblockingGet\n()\n      \n//returns null or the emitted exception if any\n\n\n\n//single\n\n\naccept\n.\nmethodReturnsSingle\n().\nblockingGet\n()\n           \n//returns success object or rethrows any exception emitted                                  \n\n\n\n\n\nAsynchronous Methods\n\n\nAn asynchronous response can be achieved by calling the \nsubscribe\n method with various parameters. Every subscribe method returns Disposable, and this can be used to cancel the subscription. The result comes as an asynchronous callback. You can manage threads where the response came. \n\n\n//completable\n\n\naccept\n.\nmethodReturnsCompletable\n().\nsubscribe\n()\n                                                        \n//returns disposable, ignores all responses\n\n\naccept\n.\nmethodReturnsCompletable\n().\nsubscribe\n(\nCompletableObserver\n \ns\n)\n                                   \n//returns disposable, all responses came in given CompletableObserver\n\n\naccept\n.\nmethodReturnsCompletable\n().\nsubscribe\n(\nAction\n \nonComplete\n,\n \nConsumer\n?\n \nsuper\n \nThrowable\n \nonError\n)\n  \n//returns disposable, successful responses came in onComplete Action and error in onError\n\n\naccept\n.\nmethodReturnsCompletable\n().\nsubscribe\n(\nAction\n \nonComplete\n)\n                                       \n//returns disposable, successful response came in given Action, error is ignored\n\n\n\n//single\n\n\naccept\n.\nmethodReturnsSingle\n().\nsubscribe\n()\n                                                                     \n//returns disposable, ignores all responses\n\n\naccept\n.\nmethodReturnsSingle\n().\nsubscribe\n(\nBiConsumer\n?\n \nsuper\n \nT\n,\n \n?\n \nsuper\n \nThrowable\n \nonCallback\n)\n                  \n//returns disposable, all responses came in given composite BiConsumer callback\n\n\naccept\n.\nmethodReturnsSingle\n().\nsubscribe\n(\nConsumer\n?\n \nsuper\n \nT\n \nonSuccess\n)\n                                        \n//returns disposable, successful response came in given Consumer callback, error is ignored\n\n\naccept\n.\nmethodReturnsSingle\n().\nsubscribe\n(\nConsumer\n?\n \nsuper\n \nT\n \nonSuccess\n,\n \nConsumer\n?\n \nsuper\n \nThrowable\n \nonError\n)\n   \n//returns disposable, successful or error response came in given onSuccess or onError Consumer\n\n\naccept\n.\nmethodReturnsSingle\n().\nsubscribe\n(\nSingleObserver\n?\n \nsuper\n \nT\n \nsubscriber\n)\n                                 \n//returns disposable, all responses came in given SingleObserver                                     \n\n\n\n\n\nThreads\n\n\nThere is no need for you to take care of execution of SDK methods. All executions are properly executed on threads, provided by the SDK. However, if you choose the asynchronous approach, you should take care of the result thread using rx schedulers. By default, responses will come in the SDK thread, which cannot manipulate Android Views. For more information, consult the rx documentation related to \nschedulers\n and \nRxAndroid\n. \n\n\nYou can change the result thread by calling observeOn method, as shown:\n\n\naccept\n.\nanyObservableMethod\n()\n\n  \n.\nobserveOn\n(\nAndroidSchedulers\n.\nmainThread\n())\n\n  \n.\nsubscribe\n(...);\n                                     \n\n\n\n\nOperators\n\n\nOperators are a very powerful RxJava mechanism. See this \npage\n for more information about them. The code below illustrates a simple example of a chain of sdk calls that use the \nandThen\n and \nflatMap\n operators. \n\n\naccept\n.\nmethodReturnsCompletable\n()\n\n    \n.\nandThen\n(\naccept\n.\nmethodReturnsAnotherCompletable\n())\n\n    \n.\nandThen\n(\naccept\n.\nmethodReturnsSingle\n())\n\n    \n.\nflatMap\n(\npreviousResult\n \n-\n \naccept\n.\nmethodReturnsAnotherSingle\n())\n\n    \n.\nsubscribe\n(...);", 
            "title": "Android SDK Design Principles"
        }, 
        {
            "location": "/int-ov-a/#android-sdk-design-principles", 
            "text": "AcceptSDK heavily relies on RxJava2 reactive principles. To learn more about the observer pattern and RxJava, consult the documentation on  RxJava's github  or the official  ReactiveX webpage . Every call to AcceptSDK returns an object which extends the observer pattern. It allows you to:   choose between synchronous or asynchronous results  manage execution and result threads  manage a chain of methods by operators   and much more", 
            "title": "Android SDK Design Principles"
        }, 
        {
            "location": "/int-ov-a/#completable-single-observable", 
            "text": "Most methods return  Completable  or  Single  object. They fulfil the observer pattern and can be used as regular RxJava observables. The result of a Completable object is a simple 'complete' answer, which indicates if everything was performed correctly. Single objects return as a response exactly one result, which is defined with generics. These two are used for most calls to SDK.\nObservable objects can return object defined by generics multiple times.", 
            "title": "Completable, Single, Observable"
        }, 
        {
            "location": "/int-ov-a/#completableparallel-and-singleparallel", 
            "text": "These two objects are special because they contain two separate rx streams:   Main stream contains final result of request and   Second stream contains information update events, some progress information or even requests from the user. Second stream can be accessed using the subscribeParallel( ) method.   Here is a recommended usage:   import   com.jakewharton.rxrelay2.BehaviorRelay ;  import   com.jakewharton.rxrelay2.Relay ;  import   io.reactivex.android.schedulers.AndroidSchedulers ;  Relay Event   eventObservable   =   BehaviorRelay . create ();  accept . methodReturnsSingleParallel () \n     . subscribeParallel ( eventObservable ) \n     . observeOn ( AndroidSchedulers . mainThread ()) \n     . subscribe ( onSuccess   -   { \n             //do something on success \n         },   onError   -   { \n             //show error \n         } \n     );  eventObservable \n     . observeOn ( AndroidSchedulers . mainThread ()) \n     . subscribe ( event   -   { \n         //do something on event \n     });", 
            "title": "CompletableParallel and SingleParallel"
        }, 
        {
            "location": "/int-ov-a/#synchronous-vs-asynchronous", 
            "text": "You can choose which principle suits your algorithms best for every method call.", 
            "title": "Synchronous vs Asynchronous"
        }, 
        {
            "location": "/int-ov-a/#synchronous-methods", 
            "text": "A synchronous response can be achieved by calling one of these methods:  //completable  accept . methodReturnsCompletable (). blockingAwait ()      //returns void or rethrows any exception emitted  accept . methodReturnsCompletable (). blockingGet ()        //returns null or the emitted exception if any  //single  accept . methodReturnsSingle (). blockingGet ()             //returns success object or rethrows any exception emitted", 
            "title": "Synchronous Methods"
        }, 
        {
            "location": "/int-ov-a/#asynchronous-methods", 
            "text": "An asynchronous response can be achieved by calling the  subscribe  method with various parameters. Every subscribe method returns Disposable, and this can be used to cancel the subscription. The result comes as an asynchronous callback. You can manage threads where the response came.   //completable  accept . methodReturnsCompletable (). subscribe ()                                                          //returns disposable, ignores all responses  accept . methodReturnsCompletable (). subscribe ( CompletableObserver   s )                                     //returns disposable, all responses came in given CompletableObserver  accept . methodReturnsCompletable (). subscribe ( Action   onComplete ,   Consumer ?   super   Throwable   onError )    //returns disposable, successful responses came in onComplete Action and error in onError  accept . methodReturnsCompletable (). subscribe ( Action   onComplete )                                         //returns disposable, successful response came in given Action, error is ignored  //single  accept . methodReturnsSingle (). subscribe ()                                                                       //returns disposable, ignores all responses  accept . methodReturnsSingle (). subscribe ( BiConsumer ?   super   T ,   ?   super   Throwable   onCallback )                    //returns disposable, all responses came in given composite BiConsumer callback  accept . methodReturnsSingle (). subscribe ( Consumer ?   super   T   onSuccess )                                          //returns disposable, successful response came in given Consumer callback, error is ignored  accept . methodReturnsSingle (). subscribe ( Consumer ?   super   T   onSuccess ,   Consumer ?   super   Throwable   onError )     //returns disposable, successful or error response came in given onSuccess or onError Consumer  accept . methodReturnsSingle (). subscribe ( SingleObserver ?   super   T   subscriber )                                   //returns disposable, all responses came in given SingleObserver", 
            "title": "Asynchronous Methods"
        }, 
        {
            "location": "/int-ov-a/#threads", 
            "text": "There is no need for you to take care of execution of SDK methods. All executions are properly executed on threads, provided by the SDK. However, if you choose the asynchronous approach, you should take care of the result thread using rx schedulers. By default, responses will come in the SDK thread, which cannot manipulate Android Views. For more information, consult the rx documentation related to  schedulers  and  RxAndroid .   You can change the result thread by calling observeOn method, as shown:  accept . anyObservableMethod () \n   . observeOn ( AndroidSchedulers . mainThread ()) \n   . subscribe (...);", 
            "title": "Threads"
        }, 
        {
            "location": "/int-ov-a/#operators", 
            "text": "Operators are a very powerful RxJava mechanism. See this  page  for more information about them. The code below illustrates a simple example of a chain of sdk calls that use the  andThen  and  flatMap  operators.   accept . methodReturnsCompletable () \n     . andThen ( accept . methodReturnsAnotherCompletable ()) \n     . andThen ( accept . methodReturnsSingle ()) \n     . flatMap ( previousResult   -   accept . methodReturnsAnotherSingle ()) \n     . subscribe (...);", 
            "title": "Operators"
        }, 
        {
            "location": "/int-setup-ios-cocoa/", 
            "text": "Automated Setup with Cocoapods\n\n\nThe setup process for the SUPR Accept SDK has been simplified on both platforms. On iOS, installation using Cocoapods is now available, but you still have the ability to \nset up the SDK manually\n because all setup files are available on the \nGithub repository for iOS\n. \n\n\nBefore starting, ensure that Cocoapods is installed on your Mac. For more information about installing and using Cocoapods, see the \nCocoaPods site\n. \n\n\nTo add the SUPR Accept SDK to your application, create a Podfile and then:\n\n\n\n\nOpen the Podfile in a text editor.\n\n\nAdd \npod \nAcceptSDK2/All\n to the Podfile. That's it. Only this line is required to install the SDK into your app. Note: If you want to use more than one target than you must explicitly state this in your Podfile. \n\n\nIn the folder where your podfile is stored, run \npod install\n to install a new pod. Or run \npod update\n to update your current one. \n\n\n\n\nThis downloads and installs the SDK from Cocoapods and it creates the workspace for your application. \n\n\nThe \nExample\n folder is below the main project folder and it contains Integration Tests that you can use to check the usage of each public API. The \niOS Integration Tests\n chapter has more information. \n\n\n\n\nNote\n\n\nThe workspace for the Example app can be installed using cocoapods, however, the podfile is pointing to the local pod which is AcceptSDK in the path in the directory one level above the current Example app project.", 
            "title": "Automated Setup with Cocoapods"
        }, 
        {
            "location": "/int-setup-ios-cocoa/#automated-setup-with-cocoapods", 
            "text": "The setup process for the SUPR Accept SDK has been simplified on both platforms. On iOS, installation using Cocoapods is now available, but you still have the ability to  set up the SDK manually  because all setup files are available on the  Github repository for iOS .   Before starting, ensure that Cocoapods is installed on your Mac. For more information about installing and using Cocoapods, see the  CocoaPods site .   To add the SUPR Accept SDK to your application, create a Podfile and then:   Open the Podfile in a text editor.  Add  pod  AcceptSDK2/All  to the Podfile. That's it. Only this line is required to install the SDK into your app. Note: If you want to use more than one target than you must explicitly state this in your Podfile.   In the folder where your podfile is stored, run  pod install  to install a new pod. Or run  pod update  to update your current one.    This downloads and installs the SDK from Cocoapods and it creates the workspace for your application.   The  Example  folder is below the main project folder and it contains Integration Tests that you can use to check the usage of each public API. The  iOS Integration Tests  chapter has more information.    Note  The workspace for the Example app can be installed using cocoapods, however, the podfile is pointing to the local pod which is AcceptSDK in the path in the directory one level above the current Example app project.", 
            "title": "Automated Setup with Cocoapods"
        }, 
        {
            "location": "/int-setup-ios-manual/", 
            "text": "Set up Manually\n\n\nTo manually install:\n\n\n\n\nDownload the SDK from \nSUPR Accept SDK for iOS repository on Github\n.\n\n\nAdd the necessary frameworks into your XCode project: \nAccept.framework\n\n\nAdd: \nacceptResources.bundle\n\n\nAdd one or all of the Terminal Extension frameworks that add support for terminals, printers, cash registers and scanners:\n\n\nSpire_SDK.framework [SPm2, SPm20]\n\n\nStario_SDK.framework [StarMicronics , mPOP]\n\n\nBBPOS_SDK.framework [uEMVSwiper]\n\n\nDatecs_SDK.framework [DPP-250]\n\n\nMiura_SDK.framework [M010]\n\n\nSocket_SDK.framework [SocketScanner]", 
            "title": "Set up Manually"
        }, 
        {
            "location": "/int-setup-ios-manual/#set-up-manually", 
            "text": "To manually install:   Download the SDK from  SUPR Accept SDK for iOS repository on Github .  Add the necessary frameworks into your XCode project:  Accept.framework  Add:  acceptResources.bundle  Add one or all of the Terminal Extension frameworks that add support for terminals, printers, cash registers and scanners:  Spire_SDK.framework [SPm2, SPm20]  Stario_SDK.framework [StarMicronics , mPOP]  BBPOS_SDK.framework [uEMVSwiper]  Datecs_SDK.framework [DPP-250]  Miura_SDK.framework [M010]  Socket_SDK.framework [SocketScanner]", 
            "title": "Set up Manually"
        }, 
        {
            "location": "/int-tests-i/", 
            "text": "iOS Integration Tests\n\n\nA variety of integration tests are provided with the SDK, in both Objective-C and Swift. They are stored in the \nExample\n folder below your project folder. \n\n\nThese tests useful for testing your hardware and back-end connection as well as familiarizing yourself with typical application code that uses the SDK. \n\n\nEach Test file has detailed comments that walk you through the code. Each Test is described briefly below. \n\n\nCashTests\n\n\nDemonstrates a complete usage of the Cash Management feature including how to:\n\n\n\n\nlogin and request user data\n\n\ncheck for available cash registers and get one\n\n\ndeal with various shift-related activities, such as open and close\n\n\npay in and pay out\n\n\n\n\nThe code also demonstrates how to process: \n\n\n\n\na complete cash sale with a basket full of items\n\n\na refund of a sale\n\n\n\n\nCatalogueTests\n\n\nIllustrates how to request:\n\n\n\n\nproduct catalogues\n\n\nproduct categories\n\n\nproducts\n\n\nproduct images\n\n\n\n\nThis data can then be used to display a product catalogue within your payment acceptance app, including images of each product.\n\n\nDatecsPrinterTest\n\n\nEnables you to test a Datecs printer, including:\n\n\n\n\nget a sale\n\n\ndetect a printer\n\n\nprint a receipt\n\n\n\n\nThe Datecs printer only works with the AcceptReceipt object. The StarIO printer works with:\n\n\n\n\nPDF\n\n\nUIImage\n\n\n\n\nERP Tests\n\n\nThis test helps you validate queries directed at an SAP back-end ERP. For more information about using an ERP as part of your back-end, consult \nUsing an ERP\n. \n\n\nBefore using this test, you must:\n\n\n\n\nhave ERP enabled in your back-end\n\n\nensure that you have actual data, such as product catalogue, members, products and so forth in your ERP\n\n\n\n\n\n\nNote\n\n\nMembers is another term for Customers in some ERP systems.\n\n\n\n\nThe code demonstrates how to:\n\n\n\n\nsearch for members\n\n\nrequest discount prices for specific members\n\n\nrequest stock levels for specific products\n\n\n\n\n\n\nNote\n\n\nStock level refers to the quantity of products in inventory. \n\n\n\n\nSee \nProduct Stocks (ERP)\n for more information about retrieving and using product stock levels from your ERP system. \n\n\nSalesTests\n\n\nProvides a basic test of a sale, including:\n\n\n\n\nlogin and request user data\n\n\nrequest a sale from the current user\n\n\nsave the sale response so it can be used by other tests, such as the Printer tests\n\n\nquery the sale\n\n\n\n\n\n\nTip\n\n\nIf you dive in and start reading the code, note that objects are named with a prefix of \nWDAccept\n. \nWD\n is short for Wirecard. So to read the object name, ignore this prefix. For example, \nWDAcceptSalesQuery\n is the Sales Query object. \nWDAcceptMerchantUser\n is the Merchant User object. \n\n\n\n\nSocketScannerTests\n\n\nThe SDK supports the SocketMobile Series 7 scanner. This Test allows you to test it, including:\n\n\n\n\ndiscover paired scanners\n\n\nlisten for activity on the paired scanner\n\n\nprocess a scanned barcode\n\n\nhandle battery level changes\n\n\n\n\nTo use this test, a \nbarcode-example.png\n image file is provided in the \nAcceptDemo\n folder, as shown:\n\n\n\n\nScan this barcode when running this test to validate that your scanner is functioning properly.\n\n\nSpireTests\n\n\nThe SDK supports the Spire PosMate card reader terminal. This test allows you to validate that it functions properly withe SDK. To use this test, you must: \n\n\n\n\nhave an actual iOS device because device simulators do not work for this test\n\n\nhave a Spire terminal paired to your iOS device through your iOS device settings\n\n\n\n\nOnce your hardware is ready, you can use the code to:\n\n\n\n\ndiscover paired iOS device\n\n\ncheck for updates for the device\n\n\nhandle firmware updates\n\n\nprocess a card sale\n\n\nrefund a sale\n\n\n\n\n\n\nTip\n\n\nThe refund code is particularly useful if you are using an actual credit card to test because you will want to refund any purchases you make on a real card. \n\n\n\n\nThe code also demonstrates how to add a tip and a discount. And there is additional code to help you with Cash Management if you have this feature enabled in the back-end.\n\n\nStarIOTests\n\n\nThe SDK supports a variety of StarIO devices. This test helps you test them. Specifically, the code:\n\n\n\n\ndetects paired devices\n\n\nopens the cash drawer\n\n\nprints a receipt\n\n\nscans a barcode\n\n\n\n\n\n\nNote\n\n\nThe StarMicronics device does not have a barcode scanner. \n\n\n\n\nStatsTests\n\n\nA simple implementation lets you test the statistics retrieval features of the SDK, including querying for:\n\n\n\n\nminimum, maximum and average sale amounts\n\n\nturnover\n\n\ntransaction counts\n\n\n\n\nSee the \nSales Statistics\n chapter for complete information. \n\n\nUserTests\n\n\nProvides a variety of tests for user and credential management (i.e., username/password), including:\n\n\n\n\nget credentials for a user\n\n\nremind a user of their username\n\n\nhandle a request by a user to reset their password\n\n\nallow the user to change their password\n\n\n\n\nThis functionality is part of the User Manager component which is described in more detail in the \nUser Manager component chapter\n.", 
            "title": "iOS Integration Tests"
        }, 
        {
            "location": "/int-tests-i/#ios-integration-tests", 
            "text": "A variety of integration tests are provided with the SDK, in both Objective-C and Swift. They are stored in the  Example  folder below your project folder.   These tests useful for testing your hardware and back-end connection as well as familiarizing yourself with typical application code that uses the SDK.   Each Test file has detailed comments that walk you through the code. Each Test is described briefly below.", 
            "title": "iOS Integration Tests"
        }, 
        {
            "location": "/int-tests-i/#cashtests", 
            "text": "Demonstrates a complete usage of the Cash Management feature including how to:   login and request user data  check for available cash registers and get one  deal with various shift-related activities, such as open and close  pay in and pay out   The code also demonstrates how to process:    a complete cash sale with a basket full of items  a refund of a sale", 
            "title": "CashTests"
        }, 
        {
            "location": "/int-tests-i/#cataloguetests", 
            "text": "Illustrates how to request:   product catalogues  product categories  products  product images   This data can then be used to display a product catalogue within your payment acceptance app, including images of each product.", 
            "title": "CatalogueTests"
        }, 
        {
            "location": "/int-tests-i/#datecsprintertest", 
            "text": "Enables you to test a Datecs printer, including:   get a sale  detect a printer  print a receipt   The Datecs printer only works with the AcceptReceipt object. The StarIO printer works with:   PDF  UIImage", 
            "title": "DatecsPrinterTest"
        }, 
        {
            "location": "/int-tests-i/#erp-tests", 
            "text": "This test helps you validate queries directed at an SAP back-end ERP. For more information about using an ERP as part of your back-end, consult  Using an ERP .   Before using this test, you must:   have ERP enabled in your back-end  ensure that you have actual data, such as product catalogue, members, products and so forth in your ERP    Note  Members is another term for Customers in some ERP systems.   The code demonstrates how to:   search for members  request discount prices for specific members  request stock levels for specific products    Note  Stock level refers to the quantity of products in inventory.    See  Product Stocks (ERP)  for more information about retrieving and using product stock levels from your ERP system.", 
            "title": "ERP Tests"
        }, 
        {
            "location": "/int-tests-i/#salestests", 
            "text": "Provides a basic test of a sale, including:   login and request user data  request a sale from the current user  save the sale response so it can be used by other tests, such as the Printer tests  query the sale    Tip  If you dive in and start reading the code, note that objects are named with a prefix of  WDAccept .  WD  is short for Wirecard. So to read the object name, ignore this prefix. For example,  WDAcceptSalesQuery  is the Sales Query object.  WDAcceptMerchantUser  is the Merchant User object.", 
            "title": "SalesTests"
        }, 
        {
            "location": "/int-tests-i/#socketscannertests", 
            "text": "The SDK supports the SocketMobile Series 7 scanner. This Test allows you to test it, including:   discover paired scanners  listen for activity on the paired scanner  process a scanned barcode  handle battery level changes   To use this test, a  barcode-example.png  image file is provided in the  AcceptDemo  folder, as shown:   Scan this barcode when running this test to validate that your scanner is functioning properly.", 
            "title": "SocketScannerTests"
        }, 
        {
            "location": "/int-tests-i/#spiretests", 
            "text": "The SDK supports the Spire PosMate card reader terminal. This test allows you to validate that it functions properly withe SDK. To use this test, you must:    have an actual iOS device because device simulators do not work for this test  have a Spire terminal paired to your iOS device through your iOS device settings   Once your hardware is ready, you can use the code to:   discover paired iOS device  check for updates for the device  handle firmware updates  process a card sale  refund a sale    Tip  The refund code is particularly useful if you are using an actual credit card to test because you will want to refund any purchases you make on a real card.    The code also demonstrates how to add a tip and a discount. And there is additional code to help you with Cash Management if you have this feature enabled in the back-end.", 
            "title": "SpireTests"
        }, 
        {
            "location": "/int-tests-i/#stariotests", 
            "text": "The SDK supports a variety of StarIO devices. This test helps you test them. Specifically, the code:   detects paired devices  opens the cash drawer  prints a receipt  scans a barcode    Note  The StarMicronics device does not have a barcode scanner.", 
            "title": "StarIOTests"
        }, 
        {
            "location": "/int-tests-i/#statstests", 
            "text": "A simple implementation lets you test the statistics retrieval features of the SDK, including querying for:   minimum, maximum and average sale amounts  turnover  transaction counts   See the  Sales Statistics  chapter for complete information.", 
            "title": "StatsTests"
        }, 
        {
            "location": "/int-tests-i/#usertests", 
            "text": "Provides a variety of tests for user and credential management (i.e., username/password), including:   get credentials for a user  remind a user of their username  handle a request by a user to reset their password  allow the user to change their password   This functionality is part of the User Manager component which is described in more detail in the  User Manager component chapter .", 
            "title": "UserTests"
        }, 
        {
            "location": "/int-initialization-ios/", 
            "text": "iOS SDK Initialization\n\n\nAfter you install the SDK in your own project, you can start to use the component functionality (i.e. the public APIs) of the SDK, but first, you need to initialize the SDK as shown in this chapter. Before looking at the code though, you should understand how the Public Test environment works.\n\n\nUsing the Public Test Environment\n\n\nAll Wirecard partners who develop with the SDK are provided with:\n\n\n\n\na Wirecard card reader hardware device that can be used for testing purposes\n\n\na user name and password that can be used to access the \nPublic Test\n back-end testing environment\n\n\n\n\nAs part of your initialization code (a sample of which is shown below), you must \npoint\n the SDK to a back-end \nenvironment\n. An environment essentially means a Switch back-end, as described in the \nmPOS Architecture\n. Eventually, you will point to the live/production environment of the merchant for whom you are developing the payment acceptance app. However, during development, you can take advantage of our Public Test environment. This is a fully-functional back-end that you can use throughout development and testing.\n\n\n\n\nNote\n\n\nTalk to your project manager if you do not yet have a user name and password for accessing Public Test. If your project manager does not yet have this information, email \n with a request to obtain a user name and password and include the relevant data from your partnership agreement. They will be happy to help you.\n\n\n\n\n\n\nTip\n\n\nWe often use the term \ncredentials\n to refer to both the user name and the password.\n\n\n\n\nThe AcceptSDK Class\n\n\nThe highest-level class in the object hierarchy for both platforms is the AcceptSDK class. The first step in using AcceptSDK is to instantiate this object class as shown in the sample code below. \n\n\nThe Sample Code\n\n\nThe sample code demonstrates how to initialize the SDK. Note that the \nAcceptEnvironmentPublicTest\n is passed to \nsetupWithEnvironment\n method. This points your payment app to the Public Test environment. Substitute your actual user name and password where instead of \nyourUsername\n and \nyourPassword\n. Also note that if there is a current user and a current cashier, both are returned. The cashier is important if you are using the Cash Management functionality of the SDK because every cash operation requires an associated cashier. \n\n\n// Import the SDK header\n\n\n#import \nAccept/Accept.h\n\n\n\n//End of SDK Setup process\n\n\nCurrentUserCompletion\n \nsetupCompletion\n \n=\n \n^\n(\n \nWDAcceptMerchantUser\n \n*\n \n_Nullable\n \ncurrentUser\n,\n \nWDAcceptMerchantCashier\n \n*\n \n_Nullable\n \ncashier\n,\n \nNSError\n \n*\n \n_Nullable\n \nerror\n){\n\n    \n//Current User is returned upon successful login\n\n    \n//if Cash Management is enabled and a Cashier record exists for the current user then the Cashier is returned also\n\n\n};\n\n\n\n// The SDK is initialized as a shared instance so it can be accessed \n\n\n// from multiple View Controllers\n\n\nAcceptSDK\n \n*\nsdk\n \n=\n \n[\nAcceptSDK\n \nsharedInstance\n];\n \n\n\n// Set the SDK target environment - in this case Public Test\n\n\n// and the username and password to authenticate to it\n\n\n[\nsdk\n \nsetupWithEnvironment\n:\nAcceptEnvironmentPublicTest\n \n                 \nusername\n:\n@\nyourUsername\n \n                 \npassword\n:\n@\nyourPassword\n\n                 \ncompletion\n:\n \nsetupCompletion\n];", 
            "title": "iOS SDK Initialization"
        }, 
        {
            "location": "/int-initialization-ios/#ios-sdk-initialization", 
            "text": "After you install the SDK in your own project, you can start to use the component functionality (i.e. the public APIs) of the SDK, but first, you need to initialize the SDK as shown in this chapter. Before looking at the code though, you should understand how the Public Test environment works.", 
            "title": "iOS SDK Initialization"
        }, 
        {
            "location": "/int-initialization-ios/#using-the-public-test-environment", 
            "text": "All Wirecard partners who develop with the SDK are provided with:   a Wirecard card reader hardware device that can be used for testing purposes  a user name and password that can be used to access the  Public Test  back-end testing environment   As part of your initialization code (a sample of which is shown below), you must  point  the SDK to a back-end  environment . An environment essentially means a Switch back-end, as described in the  mPOS Architecture . Eventually, you will point to the live/production environment of the merchant for whom you are developing the payment acceptance app. However, during development, you can take advantage of our Public Test environment. This is a fully-functional back-end that you can use throughout development and testing.   Note  Talk to your project manager if you do not yet have a user name and password for accessing Public Test. If your project manager does not yet have this information, email   with a request to obtain a user name and password and include the relevant data from your partnership agreement. They will be happy to help you.    Tip  We often use the term  credentials  to refer to both the user name and the password.", 
            "title": "Using the Public Test Environment"
        }, 
        {
            "location": "/int-initialization-ios/#the-acceptsdk-class", 
            "text": "The highest-level class in the object hierarchy for both platforms is the AcceptSDK class. The first step in using AcceptSDK is to instantiate this object class as shown in the sample code below.", 
            "title": "The AcceptSDK Class"
        }, 
        {
            "location": "/int-initialization-ios/#the-sample-code", 
            "text": "The sample code demonstrates how to initialize the SDK. Note that the  AcceptEnvironmentPublicTest  is passed to  setupWithEnvironment  method. This points your payment app to the Public Test environment. Substitute your actual user name and password where instead of  yourUsername  and  yourPassword . Also note that if there is a current user and a current cashier, both are returned. The cashier is important if you are using the Cash Management functionality of the SDK because every cash operation requires an associated cashier.   // Import the SDK header  #import  Accept/Accept.h  //End of SDK Setup process  CurrentUserCompletion   setupCompletion   =   ^ (   WDAcceptMerchantUser   *   _Nullable   currentUser ,   WDAcceptMerchantCashier   *   _Nullable   cashier ,   NSError   *   _Nullable   error ){ \n     //Current User is returned upon successful login \n     //if Cash Management is enabled and a Cashier record exists for the current user then the Cashier is returned also  };  // The SDK is initialized as a shared instance so it can be accessed   // from multiple View Controllers  AcceptSDK   * sdk   =   [ AcceptSDK   sharedInstance ];   // Set the SDK target environment - in this case Public Test  // and the username and password to authenticate to it  [ sdk   setupWithEnvironment : AcceptEnvironmentPublicTest  \n                  username : @ yourUsername  \n                  password : @ yourPassword \n                  completion :   setupCompletion ];", 
            "title": "The Sample Code"
        }, 
        {
            "location": "/int-sale-overview/", 
            "text": "Sales Manager Overview\n\n\nThe objective of every merchant is to complete sales and make a profit so the Sale Managers component is probably the most important API in the SUPR Accept SDK. This topic provides a general introduction to the Sales Manager component and the key object it uses: Sale Request. The next chapter describes how to use Sales Manager to handle a \ncash sale request\n. The chapter after that describes how to handle a \ncard sale request\n.\n\n\nA Sample User Interface\n\n\nTo help you visualize the end-user functionality that needs to be created, the picture below shows a simple example of a user interface that we will use throughout this documentation. Of course, you are responsible for creating the UI on your own platform and in your programming language of choice, but this gives a feel for what the user interaction might look like before your code takes over and processes the sale request.\n\n\n\n\nMinimum Information for a Sales Request\n\n\nMost importantly, the UI picture above highlights the kind of information that you need to provide to the Sale Request object:\n\n\n\n\npayment method (i.e. the buttons at the bottom of the UI), with the supported payment methods that you can include being:\n\n\nCard (i.e. Visa and Mastercard)\n\n\nCash\n\n\nSEPA\n\n\nAlipay\n\n\nWeChat Pay\n\n\n\n\n\n\n\n\n\n\nNote\n\n\nSEPA, Alipay and WeChat Pay are \nalternative payment methods\n. Implementing them is optional. You only need to implement them if they are required by the merchant for whom you are implementing.\n\n\n\n\n\n\nFor each individual item that is part of a sale, you need to provide:\n\n\nItem Description\n\n\nPrice\n\n\nQuantity\n\n\nCurrency\n\n\nTax to be charged\n\n\n\n\n\n\n\n\nFor simplicity, in the Integrate section of this documentation website we use a sale example with just one item. Most of the code samples also use just a single item.", 
            "title": "Sales Manager Overview"
        }, 
        {
            "location": "/int-sale-overview/#sales-manager-overview", 
            "text": "The objective of every merchant is to complete sales and make a profit so the Sale Managers component is probably the most important API in the SUPR Accept SDK. This topic provides a general introduction to the Sales Manager component and the key object it uses: Sale Request. The next chapter describes how to use Sales Manager to handle a  cash sale request . The chapter after that describes how to handle a  card sale request .", 
            "title": "Sales Manager Overview"
        }, 
        {
            "location": "/int-sale-overview/#a-sample-user-interface", 
            "text": "To help you visualize the end-user functionality that needs to be created, the picture below shows a simple example of a user interface that we will use throughout this documentation. Of course, you are responsible for creating the UI on your own platform and in your programming language of choice, but this gives a feel for what the user interaction might look like before your code takes over and processes the sale request.", 
            "title": "A Sample User Interface"
        }, 
        {
            "location": "/int-sale-overview/#minimum-information-for-a-sales-request", 
            "text": "Most importantly, the UI picture above highlights the kind of information that you need to provide to the Sale Request object:   payment method (i.e. the buttons at the bottom of the UI), with the supported payment methods that you can include being:  Card (i.e. Visa and Mastercard)  Cash  SEPA  Alipay  WeChat Pay      Note  SEPA, Alipay and WeChat Pay are  alternative payment methods . Implementing them is optional. You only need to implement them if they are required by the merchant for whom you are implementing.    For each individual item that is part of a sale, you need to provide:  Item Description  Price  Quantity  Currency  Tax to be charged     For simplicity, in the Integrate section of this documentation website we use a sale example with just one item. Most of the code samples also use just a single item.", 
            "title": "Minimum Information for a Sales Request"
        }, 
        {
            "location": "/int-salerequest-cash/", 
            "text": "Sale Request - Cash\n\n\nLet's look at a very simple cash sale request to illustrate the importance of the Sale Request object and the Sale Manager component.  \n\n\nThe User Interface\n\n\nThe starting point for your app functionality is the user interface. A typical user interface for accepting app payments is shown below, where a single \nItem 1\n is being purchased at a price of \n10.00 \u20ac\n and the tax rate is \n20.00%\n. In this chapter, we look at how to handle a cash sale so the user's hand is shown clicking on the \nCash\n button. \n\n\n\n\n\n\nTip\n\n\nFour our non-European readers, the \u20ac symbol indicates euros, which is abbreviated as \nEUR\n.\n\n\n\n\nOf course, you need to create your own UI, but after that the SDK takes over. Let's see how the code is set up to handle this sale.\n\n\nThe iOS Design\n\n\nThe Sales Manager component is implemented somewhat differently on iOS and Android so we look at each individually, starting with the iOS object model and process flow.\n\n\nThe iOS Object Model\n\n\nThe diagram below shows the key objects involved in the processing of a cash sale request. \n\n\n\n\n\n\nNote\n\n\nThe object and method names above are shown in simplified pseudo-code to make it easier to read for both developers and non-developers. Generally speaking, we remove the \nWDAccept\n, which is the prefix at the beginning of all class names, and we add in some spaces. For example, the actual class name is \nWDAcceptSaleRequest\n but that is tough to read, so we display it as \nSale Request\n instead. We do the same with method names. For example, the method \nadd cash payment\n, shown above, is implemented in Objective-C and Swift as \naddCashPayment\n.\n\n\n\n\nThe iOS Process Flow\n\n\nThe process flow in the code is as follows:\n\n\n\n\n Instantiate a \nSale Request\n object.\n\n\n The \ntype\n attribute of \nSale Request\n defines the type of sale request, most commonly a \nPurchase\n.\n\n\n Add details to the Sale Request object with the \nadd sale item\n method. \n\n\n For cash transactions, use the \nadd cash payment\n method. \n\n\n\n\n\n\n Pass the full details of the \nSale Request\n to the \nPayment Config\n object in the \nsale\n property.\n\n\n\n\nAt this point, the \nSales Manager\n component has everything it needs to process the payment in the sale property, and the next steps are described in \nThe Payment Flow\n chapter. \n\n\nThe Android Design\n\n\nThe Android design and process flow is described below.\n\n\nThe Android Object Model\n\n\nThe Sales Manager component in Android is implemented as the \nsales()\n method of the \nAcceptSDK\n class. The \nSales Builder\n then does most of the work as shown:\n\n\n\n\nThe Android Process Flow\n\n\nThe process flow is:\n\n\n\n\n Create an \nitems\n object with a \nSale Item Type\n of \nPurchase\n. \n\n\n Use \nSale Builder\n to create the sale request.\n\n\n Add the sample amount (i.e., 10 \u20ac), currency and tax inclusion for the sample sale item with \npay(Sales Builder)\n.\n\n\n The \nadd cash payment\n method indicates that the full amount of the sale is paid with cash (i.e., 10 \u20ac).\n\n\n\n\n\n\n A \nsaleId\n string is returned which has the complete sale object.\n\n\n\n\nAt this point, the \nSales Manager\n component has everything it needs to process the payment in the sale property, and the next steps are described in \nThe Payment Flow\n chapter. \n\n\nThe Sample Code\n\n\nBefore jumping ahead, you should look at the sample code that demonstrates exactly how this is implemented, using the example of a single item shown in the picture of the UI.\n\n\nInsert GIST here and remove Objective-C below.\n\n\n// Create the instance of the Sale Request\n\n\n// Here the minimum data is depicted\n\n\nWDAcceptSaleRequest\n \n*\nsaleRequest\n \n=\n \n[[\nWDAcceptSaleRequest\n \nalloc\n]\n \ninitWithUniqueId\n:\n@\nyourSaleUniqueID\n \n// provide your unique ID to identify the Sale - Using for example [[NSUUID UUID] UUIDString]\n\n                                                                        \nlocation\n:\nnil\n \n// provide the GPS location for this payment e.g. the mobile device location, simply using Core Location CLLocation\n\n                                                                  \ninclusiveTaxes\n:\nYES\n \n// Tax inclusive/exclusive flag\n\n                                                                        \ncurrency\n:\n@\nEUR\n \n// Currency to use for this Sale as per ISO 4217 Currency codes\n\n                                                                            \nnote\n:\n@\nTest Sale\n \n// Top level note for this sale\n\n                                                                 \ngratuityTaxRate\n:\nnil\n \n// Gratuity tax rate - nil if no gratuity to be set later in the payment flow\n\n                                    \n];\n\n\n\n// Create one item named \nItem 1\n costing 10.00 EUR at 20% Tax\n\n\n[\nsaleRequest\n \naddSaleItem\n:[\nNSDecimalNumber\n \ndecimalNumberWithString\n:\n@\n10.00\n]\n \n// Item Unit price\n\n                \nquantity\n:\n1\n \n// Item Quantity\n\n                 \ntaxRate\n:[\nNSDecimalNumber\n \ndecimalNumberWithString\n:\n@\n20.00\n]\n \n// Item Tax rate\n\n         \nitemDescription\n:\n@\nItem 1\n \n// Item description\n\n               \nproductId\n:\nnil\n \n// External product ID - in the case you are using ERP - such as SAP and wish to refer to the product\n\n \n];\n\n\n\n// Define the Sale operation as Purchase [other available are Return | Authorize | Pre-Authorize]\n\n\nsaleRequest\n.\noperation\n \n=\n \nAcceptSaleOperationPurchase\n;\n\n\n\n// Set this Sale to be settled by Cash transaction\n\n\n[\nsaleRequest\n \naddCashTransaction\n:[\nNSDecimalNumber\n \ndecimalNumberWithString\n:\n@\n10.00\n]];\n\n   \n// The total amount of Sale can be settled by more than on transaction type e.g. Cash and Card\n\n   \n// Should you wish to do so you would add additional transaction e.g. saleRequest.addCardTransaction ...\n\n\n\n\n// Create Payment Configuration to be used in the Pay API later\n\n\nWDAcceptPaymentConfig\n \n*\npaymentConfiguration\n \n=\n \n[\nWDAcceptPaymentConfig\n \nnew\n];\n\n\n\n// Set the Sale of this payment configuration to be your new Sale Request\n\n\npaymentConfiguration\n.\nsale\n \n=\n \nsaleRequest\n;", 
            "title": "Sale Request - Cash"
        }, 
        {
            "location": "/int-salerequest-cash/#sale-request-cash", 
            "text": "Let's look at a very simple cash sale request to illustrate the importance of the Sale Request object and the Sale Manager component.", 
            "title": "Sale Request - Cash"
        }, 
        {
            "location": "/int-salerequest-cash/#the-user-interface", 
            "text": "The starting point for your app functionality is the user interface. A typical user interface for accepting app payments is shown below, where a single  Item 1  is being purchased at a price of  10.00 \u20ac  and the tax rate is  20.00% . In this chapter, we look at how to handle a cash sale so the user's hand is shown clicking on the  Cash  button.     Tip  Four our non-European readers, the \u20ac symbol indicates euros, which is abbreviated as  EUR .   Of course, you need to create your own UI, but after that the SDK takes over. Let's see how the code is set up to handle this sale.", 
            "title": "The User Interface"
        }, 
        {
            "location": "/int-salerequest-cash/#the-ios-design", 
            "text": "The Sales Manager component is implemented somewhat differently on iOS and Android so we look at each individually, starting with the iOS object model and process flow.", 
            "title": "The iOS Design"
        }, 
        {
            "location": "/int-salerequest-cash/#the-ios-object-model", 
            "text": "The diagram below shows the key objects involved in the processing of a cash sale request.     Note  The object and method names above are shown in simplified pseudo-code to make it easier to read for both developers and non-developers. Generally speaking, we remove the  WDAccept , which is the prefix at the beginning of all class names, and we add in some spaces. For example, the actual class name is  WDAcceptSaleRequest  but that is tough to read, so we display it as  Sale Request  instead. We do the same with method names. For example, the method  add cash payment , shown above, is implemented in Objective-C and Swift as  addCashPayment .", 
            "title": "The iOS Object Model"
        }, 
        {
            "location": "/int-salerequest-cash/#the-ios-process-flow", 
            "text": "The process flow in the code is as follows:    Instantiate a  Sale Request  object.   The  type  attribute of  Sale Request  defines the type of sale request, most commonly a  Purchase .   Add details to the Sale Request object with the  add sale item  method.    For cash transactions, use the  add cash payment  method.      Pass the full details of the  Sale Request  to the  Payment Config  object in the  sale  property.   At this point, the  Sales Manager  component has everything it needs to process the payment in the sale property, and the next steps are described in  The Payment Flow  chapter.", 
            "title": "The iOS Process Flow"
        }, 
        {
            "location": "/int-salerequest-cash/#the-android-design", 
            "text": "The Android design and process flow is described below.", 
            "title": "The Android Design"
        }, 
        {
            "location": "/int-salerequest-cash/#the-android-object-model", 
            "text": "The Sales Manager component in Android is implemented as the  sales()  method of the  AcceptSDK  class. The  Sales Builder  then does most of the work as shown:", 
            "title": "The Android Object Model"
        }, 
        {
            "location": "/int-salerequest-cash/#the-android-process-flow", 
            "text": "The process flow is:    Create an  items  object with a  Sale Item Type  of  Purchase .    Use  Sale Builder  to create the sale request.   Add the sample amount (i.e., 10 \u20ac), currency and tax inclusion for the sample sale item with  pay(Sales Builder) .   The  add cash payment  method indicates that the full amount of the sale is paid with cash (i.e., 10 \u20ac).     A  saleId  string is returned which has the complete sale object.   At this point, the  Sales Manager  component has everything it needs to process the payment in the sale property, and the next steps are described in  The Payment Flow  chapter.", 
            "title": "The Android Process Flow"
        }, 
        {
            "location": "/int-salerequest-cash/#the-sample-code", 
            "text": "Before jumping ahead, you should look at the sample code that demonstrates exactly how this is implemented, using the example of a single item shown in the picture of the UI.  Insert GIST here and remove Objective-C below.  // Create the instance of the Sale Request  // Here the minimum data is depicted  WDAcceptSaleRequest   * saleRequest   =   [[ WDAcceptSaleRequest   alloc ]   initWithUniqueId : @ yourSaleUniqueID   // provide your unique ID to identify the Sale - Using for example [[NSUUID UUID] UUIDString] \n                                                                         location : nil   // provide the GPS location for this payment e.g. the mobile device location, simply using Core Location CLLocation \n                                                                   inclusiveTaxes : YES   // Tax inclusive/exclusive flag \n                                                                         currency : @ EUR   // Currency to use for this Sale as per ISO 4217 Currency codes \n                                                                             note : @ Test Sale   // Top level note for this sale \n                                                                  gratuityTaxRate : nil   // Gratuity tax rate - nil if no gratuity to be set later in the payment flow \n                                     ];  // Create one item named  Item 1  costing 10.00 EUR at 20% Tax  [ saleRequest   addSaleItem :[ NSDecimalNumber   decimalNumberWithString : @ 10.00 ]   // Item Unit price \n                 quantity : 1   // Item Quantity \n                  taxRate :[ NSDecimalNumber   decimalNumberWithString : @ 20.00 ]   // Item Tax rate \n          itemDescription : @ Item 1   // Item description \n                productId : nil   // External product ID - in the case you are using ERP - such as SAP and wish to refer to the product \n  ];  // Define the Sale operation as Purchase [other available are Return | Authorize | Pre-Authorize]  saleRequest . operation   =   AcceptSaleOperationPurchase ;  // Set this Sale to be settled by Cash transaction  [ saleRequest   addCashTransaction :[ NSDecimalNumber   decimalNumberWithString : @ 10.00 ]]; \n    // The total amount of Sale can be settled by more than on transaction type e.g. Cash and Card \n    // Should you wish to do so you would add additional transaction e.g. saleRequest.addCardTransaction ...  // Create Payment Configuration to be used in the Pay API later  WDAcceptPaymentConfig   * paymentConfiguration   =   [ WDAcceptPaymentConfig   new ];  // Set the Sale of this payment configuration to be your new Sale Request  paymentConfiguration . sale   =   saleRequest ;", 
            "title": "The Sample Code"
        }, 
        {
            "location": "/int-salerequest-card/", 
            "text": "Sale Request - Card\n\n\nYou should now have a good feel for the Sale Request object as it relates to handling cash payments. Now let's look at card payments. Card payments can be processed by an mPOS terminal if the terminal is paired and connected to the user's mobile device. \n\n\nThe User Interface\n\n\nLet's revisit our UI again. The user hand in the picture below emphasizes that we are now going to focus on card payments, which require that a terminal be connected and paired to the mobile device of the user. \n\n\n\n\nThe same sample Item 1 which costs 10 \u20ac is again used in the sample code. So there are actually only a few differences between this code and the cash code in the \nprevious chapter\n.\n\n\nCode Differences with Credit Sale Request\n\n\nThey key differences between the cash code and the credit code presented in this topic are:\n\n\n\n\nTerminal Manager\n is used to \ndiscover Devices\n and the results are placed into:\n\n\nan array of \nterminals\n in the iOS code\n\n\na \nterminalDevice\n object in the Android code.\n\n\n\n\n\n\nThe \nadd card payment\n method is used instead of the \nadd cash payment\n method. The \nadd card payment\n method uses the discovered terminal.\n\n\n\n\nThat's it. The rest of the code is almost exactly the same as the cash code, so it should look quite familiar. Let's now examine the two object models.\n\n\nThe iOS Object Model\n\n\nAn expanded version of the iOS object model is shown below. It now shows the \nadd card payment\n method and the \nTerminal Manager\n component and illustrates how they collaborate together.\n\n\n\n\n\n\nTip\n\n\nIf you are a little overwhelmed at this point, don't worry about it. The \nPayment Flow\n chapter provides a good review which covers card and cash payments on iOS a second time. \n\n\n\n\nThe Android Object Model\n\n\nThe Android sample code is structured somewhat differently from the iOS code. The device discovery, sample sale request building and adding of a card payment are similar, but after that, the \neventRelay\n takes over and handles various events that can take place on the terminal, such as \nSignature Request\n, \nSignature Confirmation\n and so forth.\n\n\n\n\n\n\nNote\n\n\nSignature Request and Signature Confirmation on iOS are covered in the \nPayment Flow\n chapter. In addition, a sample UI for handling these user actions is presented in that chapter.\n\n\n\n\nThe Sample Code\n\n\nInsert GIST here and remove Objective-C below.\n\n\n// Create the instance of the Sale Request\n\n\n// Here the minimum data is depicted\n\n\nWDAcceptSaleRequest\n \n*\nsaleRequest\n \n=\n \n[[\nWDAcceptSaleRequest\n \nalloc\n]\n \ninitWithUniqueId\n:\n@\nyourSaleUniqueID\n \n// provide your unique ID to identify the Sale - Using for example [[NSUUID UUID] UUIDString]\n\n                                                                        \nlocation\n:\nnil\n \n// provide the GPS location - Simply use Core Location CLLocation\n\n                                                                  \ninclusiveTaxes\n:\nYES\n \n// Tax inclusive/exclusive flag\n\n                                                                        \ncurrency\n:\n@\nEUR\n \n// Currency to use for this Sale as per ISO 4217 Currency codes\n\n                                                                            \nnote\n:\n@\nTest Posmate Sale\n \n// Top level note for this sale\n\n                                                                 \ngratuityTaxRate\n:\nnil\n \n// Gratuity tax rate - nil if no gratuity to be set later in the payment flow\n\n                                    \n];\n\n\n\n// Create one item named \nItem 1\n costing 10.00 EUR at 20% Tax\n\n\n[\nsaleRequest\n \naddSaleItem\n:[\nNSDecimalNumber\n \ndecimalNumberWithString\n:\n@\n10.00\n]\n \n// Item Unit price\n\n                \nquantity\n:\n1\n \n// Item Quantity\n\n                 \ntaxRate\n:[\nNSDecimalNumber\n \ndecimalNumberWithString\n:\n@\n20.00\n]\n \n// Item Tax rate\n\n         \nitemDescription\n:\n@\nItem 1\n \n// Item description\n\n               \nproductId\n:\nnil\n \n// External product ID - in the case you are using ERP - such as SAP and wish to refer to the product\n\n \n];\n\n\n\n// Define the Sale operation as Purchase\n\n\nsaleRequest\n.\noperation\n \n=\n \nAcceptSaleOperationPurchase\n;\n\n\n\n// Discover active terminals and use it - in this case we use the first one\n\n\n// Alternatively use the one discovered previously and stored in an instance variable (or user preferences)\n\n\n[\nsdk\n.\nterminalManager\n \ndiscoverDevices\n:\nWDAMiuraExtensionUUID\n\n                          \ncompletion\n:\n^\n(\nNSArray\nWDAcceptTerminal\n \n*\n \n*\n \n_Nullable\n \nterminals\n,\n \nNSError\n \n*\n \n_Nullable\n \ndevicesError\n)\n \n{\n\n\n    \n// Set this Sale to be settled by Card transaction\n\n    \n[\nsaleRequest\n \naddCardTransaction\n:[\nNSDecimalNumber\n \ndecimalNumberWithString\n:\n@\n10.00\n]\n\n                           \nterminal\n:[\nterminals\n \nfirstObject\n]];\n\n\n  \n// The total amount of Sale can be settled by more than on transaction type e.g. Cash and Card\n\n  \n// Should you wish to do so you would add additional transaction e.g. saleRequest.addCashTransaction ...\n\n\n    \n// Create Payment Configuration to be used in the Pay API later\n\n    \nWDAcceptPaymentConfig\n \n*\npaymentConfiguration\n \n=\n \n[\nWDAcceptPaymentConfig\n \nnew\n];\n\n\n    \n// Set the Sale of this payment configuration to be your new Sale Request\n\n    \npaymentConfiguration\n.\nsale\n \n=\n \nsaleRequest\n;\n\n\n}];", 
            "title": "Sales Request - Card"
        }, 
        {
            "location": "/int-salerequest-card/#sale-request-card", 
            "text": "You should now have a good feel for the Sale Request object as it relates to handling cash payments. Now let's look at card payments. Card payments can be processed by an mPOS terminal if the terminal is paired and connected to the user's mobile device.", 
            "title": "Sale Request - Card"
        }, 
        {
            "location": "/int-salerequest-card/#the-user-interface", 
            "text": "Let's revisit our UI again. The user hand in the picture below emphasizes that we are now going to focus on card payments, which require that a terminal be connected and paired to the mobile device of the user.    The same sample Item 1 which costs 10 \u20ac is again used in the sample code. So there are actually only a few differences between this code and the cash code in the  previous chapter .", 
            "title": "The User Interface"
        }, 
        {
            "location": "/int-salerequest-card/#code-differences-with-credit-sale-request", 
            "text": "They key differences between the cash code and the credit code presented in this topic are:   Terminal Manager  is used to  discover Devices  and the results are placed into:  an array of  terminals  in the iOS code  a  terminalDevice  object in the Android code.    The  add card payment  method is used instead of the  add cash payment  method. The  add card payment  method uses the discovered terminal.   That's it. The rest of the code is almost exactly the same as the cash code, so it should look quite familiar. Let's now examine the two object models.", 
            "title": "Code Differences with Credit Sale Request"
        }, 
        {
            "location": "/int-salerequest-card/#the-ios-object-model", 
            "text": "An expanded version of the iOS object model is shown below. It now shows the  add card payment  method and the  Terminal Manager  component and illustrates how they collaborate together.    Tip  If you are a little overwhelmed at this point, don't worry about it. The  Payment Flow  chapter provides a good review which covers card and cash payments on iOS a second time.", 
            "title": "The iOS Object Model"
        }, 
        {
            "location": "/int-salerequest-card/#the-android-object-model", 
            "text": "The Android sample code is structured somewhat differently from the iOS code. The device discovery, sample sale request building and adding of a card payment are similar, but after that, the  eventRelay  takes over and handles various events that can take place on the terminal, such as  Signature Request ,  Signature Confirmation  and so forth.    Note  Signature Request and Signature Confirmation on iOS are covered in the  Payment Flow  chapter. In addition, a sample UI for handling these user actions is presented in that chapter.", 
            "title": "The Android Object Model"
        }, 
        {
            "location": "/int-salerequest-card/#the-sample-code", 
            "text": "Insert GIST here and remove Objective-C below.  // Create the instance of the Sale Request  // Here the minimum data is depicted  WDAcceptSaleRequest   * saleRequest   =   [[ WDAcceptSaleRequest   alloc ]   initWithUniqueId : @ yourSaleUniqueID   // provide your unique ID to identify the Sale - Using for example [[NSUUID UUID] UUIDString] \n                                                                         location : nil   // provide the GPS location - Simply use Core Location CLLocation \n                                                                   inclusiveTaxes : YES   // Tax inclusive/exclusive flag \n                                                                         currency : @ EUR   // Currency to use for this Sale as per ISO 4217 Currency codes \n                                                                             note : @ Test Posmate Sale   // Top level note for this sale \n                                                                  gratuityTaxRate : nil   // Gratuity tax rate - nil if no gratuity to be set later in the payment flow \n                                     ];  // Create one item named  Item 1  costing 10.00 EUR at 20% Tax  [ saleRequest   addSaleItem :[ NSDecimalNumber   decimalNumberWithString : @ 10.00 ]   // Item Unit price \n                 quantity : 1   // Item Quantity \n                  taxRate :[ NSDecimalNumber   decimalNumberWithString : @ 20.00 ]   // Item Tax rate \n          itemDescription : @ Item 1   // Item description \n                productId : nil   // External product ID - in the case you are using ERP - such as SAP and wish to refer to the product \n  ];  // Define the Sale operation as Purchase  saleRequest . operation   =   AcceptSaleOperationPurchase ;  // Discover active terminals and use it - in this case we use the first one  // Alternatively use the one discovered previously and stored in an instance variable (or user preferences)  [ sdk . terminalManager   discoverDevices : WDAMiuraExtensionUUID \n                           completion : ^ ( NSArray WDAcceptTerminal   *   *   _Nullable   terminals ,   NSError   *   _Nullable   devicesError )   { \n\n     // Set this Sale to be settled by Card transaction \n     [ saleRequest   addCardTransaction :[ NSDecimalNumber   decimalNumberWithString : @ 10.00 ] \n                            terminal :[ terminals   firstObject ]]; \n\n   // The total amount of Sale can be settled by more than on transaction type e.g. Cash and Card \n   // Should you wish to do so you would add additional transaction e.g. saleRequest.addCashTransaction ... \n\n     // Create Payment Configuration to be used in the Pay API later \n     WDAcceptPaymentConfig   * paymentConfiguration   =   [ WDAcceptPaymentConfig   new ]; \n\n     // Set the Sale of this payment configuration to be your new Sale Request \n     paymentConfiguration . sale   =   saleRequest ;  }];", 
            "title": "The Sample Code"
        }, 
        {
            "location": "/int-payment/", 
            "text": "Payment\n\n\nAlright, we're getting there! Our payment acceptance app is taking shape. We've collected some sales request details and we have looked at how to prepare the Sale Request object. We've also seen how the Sale Request is passed to the Sales Manager component using the Payment Config object's sale attribute. So now we can get down to the heavy duty work of processing the payment.\n\n\nThe User Interface\n\n\nFrom the user's perspective, the payment flow typically begins when the user clicks the Card or Cash button on the UI.\n\n\n \n\n\nIf the user selects to pay with card, the next step is determined by the terminal and the card. More specifically, the card has a list of Card Verification Methods (CVM) and this indicates if a PIN should be requested, or if a Signature should be requested. You must implement a signature collection request and the user interface might look something like this:\n\n\n\n\nThe iOS Object Model\n\n\nThe payment flow for purchase sales requests is largely handled by the six methods of the \nSales Manager\n component shown below on the right side of the diagram. The completed sale is delivered in the \nSale Response\n object:\n\n\n\n\nas a \nsale\n object if the processing was successful\n\n\nas an \nerror\n object if the processing was not successful\n\n\n\n\n\n\n\n\nTip\n\n\nIn the provided Objective-C and Swift sample code, look first at the very bottom of the code to see the six \nSales Manager\n methods that are used because this helps to understand the overall payment flow. Next, look at the preceding code to see the details of each method that is called in the payment flow. \n\n\n\n\nThe Android Object Model\n\n\nThe previous chapter presented the Android code for handling the various card-related events on the terminal so the sample code here has just this code, and the object model looks like this:\n\n\n\n\nThe Sample Code\n\n\nInsert GIST here and remove Objective-C below.\n\n\n  \n// Updates from the payment flow\n\n  \nPaymentProgress\n \nprogressUpdate\n \n=\n \n^(\nAcceptStateUpdate\n \nstatusUpdate\n){\n\n      \n// statusUpdate - coded statuses are reported throughout the payment flow\n\n  \n};\n\n\n  \n// In the case the Cardholder Signature is required by the Payment flow this block will be executed\n\n  \n// Your task is to respond to it by collecting the signature image from the customer and\n\n  \n// posting it back in the sendCollectedSignature method\n\n  \nSignatureRequiredRequest\n \nsignatureRequiredRequest\n \n=\n \n^(\nWDAcceptSignatureRequest\n*\n \nsignatureRequest\n){\n\n      \n//signatureRequest - comes from the payment flow and once you collect the signature from the customer\n\n      \n// send it back in the signatureRequest.sendCollectedSignature\n\n      \nsignatureRequest\n.\nsendCollectedSignature\n([\nTestUtils\n \nsignatureImageFromText\n:\n@\nTest\n],\nnil\n);\n\n      \n//The signature image is transferred to the backend and stored with the Sale\n\n  \n};\n\n\n  \n// Note: Applicable to terminals without USER INPUT\n\n  \n// In the case the Cardholder Signature was collected then the merchant is required to confirm it\ns validity\n\n  \n// A. If the terminal has buttons that are used for Approving/Rejecting then this block is either never called from Payment flow\n\n  \n// or it\ns signatureVerificationCallback comes nil\n\n  \n// B. If the terminal does not have buttons then the Application must present a user interface to Approve/Reject the Cardholder Signature\n\n  \nSignatureVerificationRequest\n \nverifySignature\n \n=\n \n^(\nSignatureVerificationResult\n \nsignatureVerificationResult\n,\n \nNSError\n*\n \nsignatureVerificationError\n){\n\n\n      \nif\n \n(\nsignatureVerificationResult\n)\n \n{\n\n          \n// Here the simplified use of Approving the Cardholder Signature is demonstrated\n\n          \nsignatureVerificationResult\n(\nAcceptSignatureVerificationResultApproved\n);\n\n      \n}\n\n\n  \n};\n\n\n  \n// Note: Applicable to terminals without USER INPUT\n\n  \n// In the case the payment Card has more than one card application available then the client application\n\n  \n// has to present user interface for the Cardholder to select preferred card application\n\n  \n// The list of card applications is present in appSelectionRequest.appsArray as a list of Strings\n\n  \nPaymentCardApplicationSelectionRequest\n \ncardAppSelection\n \n=\n \n^(\nWDAcceptAppSelectionRequest\n \n*\n \nappSelectionRequest\n){\n\n      \n// There is more than 1 card application available\n\n      \n// Present the UI for the Cardholder to select preferred card application (Debit | Credit)\n\n      \nif\n(\nappSelectionRequest\n.\nappsArray\n.\ncount\n \n \n0\n){\n\n          \n// Here we demonstrate the simplified use of selecting the first card application from the list of available card applications\n\n          \n// and sending it to the Payment flow\n\n          \nappSelectionRequest\n.\nsendSelectedCardApplication\n(\n0\n);\n\n      \n}\n\n  \n};\n\n\n  \n// The end of the payment process\n\n  \nSaleCompletion\n \npaymentCompletion\n \n=\n \n^(\nWDAcceptSaleResponse\n*\n \nsale\n,\n \nNSError\n*\n \nerror\n){\n\n      \n//sale - Is the completed Sale - contains the sale status, details, results\n\n      \n//error - If any error is encountered during the sale it would be reported\n\n      \n//in the form of error and hierarchy of underlying errors to give you as much details as possible\n\n  \n};\n\n\n  \n// Start the Payment flow\n\n  \n[[\nsdk\n \nsaleManager\n]\n \npay\n:\npaymentConfiguration\n \n// the payment configuration containing the Sale Request\n\n                \nprogress\n:\nprogressUpdate\n \n// Block to be executed at the time of Payment flow progress update\n\n        \ncollectSignature\n:\nsignatureRequiredRequest\n \n// Block to be executed at the time of Requesting the capture of the Cardholder signature\n\n         \nverifySignature\n:\nverifySignature\n \n// Block to be executed if terminal asks Application to confirm the validity of the Cardholder signature\n\n   \nselectCardApplication\n:\ncardAppSelection\n \n// Block to be executed if terminal asks for the Card Application selection in the case Card supports more than one card application\n\n              \ncompletion\n:\npaymentCompletion\n];\n \n// Block to be executed at the end of the Payment process", 
            "title": "Payment"
        }, 
        {
            "location": "/int-payment/#payment", 
            "text": "Alright, we're getting there! Our payment acceptance app is taking shape. We've collected some sales request details and we have looked at how to prepare the Sale Request object. We've also seen how the Sale Request is passed to the Sales Manager component using the Payment Config object's sale attribute. So now we can get down to the heavy duty work of processing the payment.", 
            "title": "Payment"
        }, 
        {
            "location": "/int-payment/#the-user-interface", 
            "text": "From the user's perspective, the payment flow typically begins when the user clicks the Card or Cash button on the UI.     If the user selects to pay with card, the next step is determined by the terminal and the card. More specifically, the card has a list of Card Verification Methods (CVM) and this indicates if a PIN should be requested, or if a Signature should be requested. You must implement a signature collection request and the user interface might look something like this:", 
            "title": "The User Interface"
        }, 
        {
            "location": "/int-payment/#the-ios-object-model", 
            "text": "The payment flow for purchase sales requests is largely handled by the six methods of the  Sales Manager  component shown below on the right side of the diagram. The completed sale is delivered in the  Sale Response  object:   as a  sale  object if the processing was successful  as an  error  object if the processing was not successful     Tip  In the provided Objective-C and Swift sample code, look first at the very bottom of the code to see the six  Sales Manager  methods that are used because this helps to understand the overall payment flow. Next, look at the preceding code to see the details of each method that is called in the payment flow.", 
            "title": "The iOS Object Model"
        }, 
        {
            "location": "/int-payment/#the-android-object-model", 
            "text": "The previous chapter presented the Android code for handling the various card-related events on the terminal so the sample code here has just this code, and the object model looks like this:", 
            "title": "The Android Object Model"
        }, 
        {
            "location": "/int-payment/#the-sample-code", 
            "text": "Insert GIST here and remove Objective-C below.     // Updates from the payment flow \n   PaymentProgress   progressUpdate   =   ^( AcceptStateUpdate   statusUpdate ){ \n       // statusUpdate - coded statuses are reported throughout the payment flow \n   }; \n\n   // In the case the Cardholder Signature is required by the Payment flow this block will be executed \n   // Your task is to respond to it by collecting the signature image from the customer and \n   // posting it back in the sendCollectedSignature method \n   SignatureRequiredRequest   signatureRequiredRequest   =   ^( WDAcceptSignatureRequest *   signatureRequest ){ \n       //signatureRequest - comes from the payment flow and once you collect the signature from the customer \n       // send it back in the signatureRequest.sendCollectedSignature \n       signatureRequest . sendCollectedSignature ([ TestUtils   signatureImageFromText : @ Test ], nil ); \n       //The signature image is transferred to the backend and stored with the Sale \n   }; \n\n   // Note: Applicable to terminals without USER INPUT \n   // In the case the Cardholder Signature was collected then the merchant is required to confirm it s validity \n   // A. If the terminal has buttons that are used for Approving/Rejecting then this block is either never called from Payment flow \n   // or it s signatureVerificationCallback comes nil \n   // B. If the terminal does not have buttons then the Application must present a user interface to Approve/Reject the Cardholder Signature \n   SignatureVerificationRequest   verifySignature   =   ^( SignatureVerificationResult   signatureVerificationResult ,   NSError *   signatureVerificationError ){ \n\n       if   ( signatureVerificationResult )   { \n           // Here the simplified use of Approving the Cardholder Signature is demonstrated \n           signatureVerificationResult ( AcceptSignatureVerificationResultApproved ); \n       } \n\n   }; \n\n   // Note: Applicable to terminals without USER INPUT \n   // In the case the payment Card has more than one card application available then the client application \n   // has to present user interface for the Cardholder to select preferred card application \n   // The list of card applications is present in appSelectionRequest.appsArray as a list of Strings \n   PaymentCardApplicationSelectionRequest   cardAppSelection   =   ^( WDAcceptAppSelectionRequest   *   appSelectionRequest ){ \n       // There is more than 1 card application available \n       // Present the UI for the Cardholder to select preferred card application (Debit | Credit) \n       if ( appSelectionRequest . appsArray . count     0 ){ \n           // Here we demonstrate the simplified use of selecting the first card application from the list of available card applications \n           // and sending it to the Payment flow \n           appSelectionRequest . sendSelectedCardApplication ( 0 ); \n       } \n   }; \n\n   // The end of the payment process \n   SaleCompletion   paymentCompletion   =   ^( WDAcceptSaleResponse *   sale ,   NSError *   error ){ \n       //sale - Is the completed Sale - contains the sale status, details, results \n       //error - If any error is encountered during the sale it would be reported \n       //in the form of error and hierarchy of underlying errors to give you as much details as possible \n   }; \n\n   // Start the Payment flow \n   [[ sdk   saleManager ]   pay : paymentConfiguration   // the payment configuration containing the Sale Request \n                 progress : progressUpdate   // Block to be executed at the time of Payment flow progress update \n         collectSignature : signatureRequiredRequest   // Block to be executed at the time of Requesting the capture of the Cardholder signature \n          verifySignature : verifySignature   // Block to be executed if terminal asks Application to confirm the validity of the Cardholder signature \n    selectCardApplication : cardAppSelection   // Block to be executed if terminal asks for the Card Application selection in the case Card supports more than one card application \n               completion : paymentCompletion ];   // Block to be executed at the end of the Payment process", 
            "title": "The Sample Code"
        }, 
        {
            "location": "/int-complete/", 
            "text": "A Complete Sale\n\n\nThis chapter lets you catch your breath a bit by providing a review of all the topics that have come before. Specifically, the sample code provides a complete implementation of a sale, from initialization of the AcceptSDK object right through to a Sale Response. The only wrinkle here is that we now demonstrate a sale where the consumer pays with both cash and card. (They're a bit tight for cash!). So the example shows how to put 5 \u20ac onto a card and 5 \u20ac on cash. Not so likely in the world, but a great review of what we have learned so far.\n\n\nThe User Interface\n\n\nHere's a summary of the user interaction where they pay 5 \u20ac cash and they put 5 \u20ac on a credit card:\n\n\n\n\nThe iOS Object Model\n\n\nSince this chapter is a review, there is nothing new to show in the object model. The difference with this code sample is that both the \nadd cash transaction\n and the \nadd card transaction\n methods are used to process the split-method payment from the consumer:\n\n\n\n\n\n\nTip\n\n\nJust like in the \nprevious chapter\n, it is recommended you read the bottom lines of code first to see the overall payment flow.\n\n\n\n\nThe Sample Code\n\n\nInsert GIST here and remove Objective-C below.\n\n\n// The SDK is initialized as shared instance so can be accessed\n\n\n// from multiple View Controllers\n\n\nAcceptSDK\n \n*\nsdk\n \n=\n \n[\nAcceptSDK\n \nsharedInstance\n];\n\n\n\n// Set the SDK target environment - in this case Public Test\n\n\n// and the username and password to authenticate to it\n\n\n[\nsdk\n \nsetupWithEnvironment\n:\nAcceptEnvironmentPublicTest\n\n                 \nusername\n:\n@\nyourUsername\n\n                 \npassword\n:\n@\nyourPassword\n];\n\n\n\n// Create the instance of the Sale Request\n\n\n// Here the minimum data is depicted\n\n\nWDAcceptSaleRequest\n \n*\nsaleRequest\n \n=\n \n[[\nWDAcceptSaleRequest\n \nalloc\n]\n \ninitWithUniqueId\n:\n@\nyourSaleUniqueID\n \n// provide your unique ID to identify the Sale\n\n                                                                        \nlocation\n:\nnil\n \n// provide the GPS location\n\n                                                                  \ninclusiveTaxes\n:\nYES\n \n// Tax inclusive/exclusive flag\n\n                                                                        \ncurrency\n:\n@\nEUR\n \n// Currency to use for this Sale\n\n                                                                            \nnote\n:\n@\nTest Posmate Sale\n \n// Top level note for this sale\n\n                                                                 \ngratuityTaxRate\n:\nnil\n \n// Gratuity tax rate - nil if no gratuity to be set later in the payment flow\n\n                                    \n];\n\n\n\n// Create one item named \nItem 1\n costing 10.00 EUR at 20% Tax\n\n\n[\nsaleRequest\n \naddSaleItem\n:[\nNSDecimalNumber\n \ndecimalNumberWithString\n:\n@\n10.00\n]\n \n// Item Unit price\n\n                \nquantity\n:\n1\n \n// Item Quantity\n\n                 \ntaxRate\n:[\nNSDecimalNumber\n \ndecimalNumberWithString\n:\n@\n20.00\n]\n \n// Item Tax rate\n\n         \nitemDescription\n:\n@\nItem 1\n \n// Item description\n\n               \nproductId\n:\nnil\n \n// External product ID - in the case you are using ERP - such as SAP and wish to refer to the product\n\n \n];\n\n\n\n// Define the Sale operation as Purchase\n\n\nsaleRequest\n.\noperation\n \n=\n \nAcceptSaleOperationPurchase\n;\n\n\n\n// Create Payment Configuration to be used in the Sale API later\n\n\nWDAcceptPaymentConfig\n \n*\npaymentConfiguration\n \n=\n \n[\nWDAcceptPaymentConfig\n \nnew\n];\n\n\n\n// The end of the payment process\n\n\nSaleCompletion\n \npaymentCompletion\n \n=\n \n^(\nWDAcceptSaleResponse\n*\n \nsale\n,\n \nNSError\n*\n \nerror\n){\n\n    \n//sale - Is the completed Sale - contains the sale status, details, results\n\n    \n//error - If any error is encountered during the sale it would be reported\n\n    \n//in the form of error and hierarchy of underlying errors to give you as much details as possible\n\n\n};\n\n\n\n// Updates from the payment flow\n\n\nPaymentProgress\n \nprogressUpdate\n \n=\n \n^(\nAcceptStateUpdate\n \nstatusUpdate\n){\n\n    \n// statusUpdate - coded statuses are reported throughout the payment flow\n\n\n};\n\n\n\n// In the case the Cardholder Signature is required by the Payment flow this block will be executed\n\n\n// Your task is to respond to it by collecting the signature image from the customer and\n\n\n// posting it back in the sendCollectedSignature method\n\n\nSignatureRequiredRequest\n \nsignatureRequiredRequest\n \n=\n \n^(\nWDAcceptSignatureRequest\n*\n \nsignatureRequest\n){\n\n    \n//signatureRequest - comes from the payment flow and once you collect the signature from the customer\n\n    \n// send it back in the signatureRequest.sendCollectedSignature\n\n    \nsignatureRequest\n.\nsendCollectedSignature\n([\nTestUtils\n \nsignatureImageFromText\n:\n@\nTest\n],\nnil\n);\n\n    \n//The signature image is transferred to the backend and stored with the Sale\n\n\n};\n\n\n\n// Note: Applicable to terminals without USER INPUT\n\n\n// In the case the Cardholder Signature was collected then the merchant is required to confirm it\ns validity\n\n\n// A. If the terminal has buttons that are used for Approving/Rejecting then this block is either never called from Payment flow\n\n\n// or it\ns signatureVerificationCallback comes nil\n\n\n// B. If the terminal does not have buttons then the Application must present a user interface to Approve/Reject the Cardholder Signature\n\n\nSignatureVerificationRequest\n \nverifySignature\n \n=\n \n^(\nSignatureVerificationResult\n \nsignatureVerificationResult\n,\n \nNSError\n*\n \nsignatureVerificationError\n){\n\n\n    \nif\n \n(\nsignatureVerificationResult\n)\n \n{\n\n        \n// Here the simplified use of Approving the Cardholder Signature is demonstrated\n\n        \nsignatureVerificationResult\n(\nAcceptSignatureVerificationResultApproved\n);\n\n    \n}\n\n\n\n};\n\n\n\n// Note: Applicable to terminals without USER INPUT\n\n\n// In the case the payment Card has more than one card application available then the client application\n\n\n// has to present user interface for the Cardholder to select preferred card application\n\n\n// The list of card applications is present in appSelectionRequest.appsArray as a list of Strings\n\n\nPaymentCardApplicationSelectionRequest\n \ncardAppSelection\n \n=\n \n^(\nWDAcceptAppSelectionRequest\n \n*\n \nappSelectionRequest\n){\n\n    \n// There is more than 1 card application available\n\n    \n// Present the UI for the Cardholder to select preferred card application (Debit | Credit)\n\n    \nif\n(\nappSelectionRequest\n.\nappsArray\n.\ncount\n \n \n0\n){\n\n        \n// Here we demonstrate the simplified use of selecting the first card application from the list of available card applications\n\n        \n// and sending it to the Payment flow\n\n        \nappSelectionRequest\n.\nsendSelectedCardApplication\n(\n0\n);\n\n    \n}\n\n\n};\n\n\n\n// Discover active terminals and use it - in this case we use the first one\n\n\n// Alternatively use the one discovered previously and stored in an instance variable (or user preferences)\n\n\n[\nsdk\n.\nterminalManager\n \ndiscoverDevices\n:\nWDAMiuraExtensionUUID\n\n                          \ncompletion\n:^(\nNSArray\nWDAcceptTerminal\n \n*\n \n*\n \n_Nullable\n \nterminals\n,\n \nNSError\n \n*\n \n_Nullable\n \ndevicesError\n)\n\n \n{\n\n     \n// Set this Sale in total amount 10 EUR to be settled half by Card transaction (5 EUR)\n\n     \n[\nsaleRequest\n \naddCardTransaction\n:[\nNSDecimalNumber\n \ndecimalNumberWithString\n:\n@\n5.00\n]\n\n                            \nterminal\n:[\nterminals\n \nfirstObject\n]];\n\n\n     \n// and half by Cash transaction (5 EUR)\n\n     \n[\nsaleRequest\n \naddCashTransaction\n:[\nNSDecimalNumber\n \ndecimalNumberWithString\n:\n@\n5.00\n]];\n\n\n     \n// Set the Sale of this payment configuration to be your new Sale Request\n\n     \npaymentConfiguration\n.\nsale\n \n=\n \nsaleRequest\n;\n\n\n     \n// Start the Payment flow\n\n     \n[[\nsdk\n \nsaleManager\n]\n \npay\n:\npaymentConfiguration\n \n// the payment configuration containing the Sale Request\n\n                   \nprogress\n:\nprogressUpdate\n \n// Block to be executed at the time of Payment flow progress update\n\n           \ncollectSignature\n:\nsignatureRequiredRequest\n \n// Block to be executed at the time of Requesting the capture of the Cardholder signature\n\n            \nverifySignature\n:\nverifySignature\n \n// Block to be executed if terminal asks Application to confirm the validity of the Cardholder signature\n\n      \nselectCardApplication\n:\ncardAppSelection\n \n// Block to be executed if terminal asks for the Card Application selection in the case Card supports more than one card application\n\n                 \ncompletion\n:\npaymentCompletion\n];\n \n// Block to be executed at the end of the Payment process\n\n\n\n\n \n}];", 
            "title": "A Complete Sale"
        }, 
        {
            "location": "/int-complete/#a-complete-sale", 
            "text": "This chapter lets you catch your breath a bit by providing a review of all the topics that have come before. Specifically, the sample code provides a complete implementation of a sale, from initialization of the AcceptSDK object right through to a Sale Response. The only wrinkle here is that we now demonstrate a sale where the consumer pays with both cash and card. (They're a bit tight for cash!). So the example shows how to put 5 \u20ac onto a card and 5 \u20ac on cash. Not so likely in the world, but a great review of what we have learned so far.", 
            "title": "A Complete Sale"
        }, 
        {
            "location": "/int-complete/#the-user-interface", 
            "text": "Here's a summary of the user interaction where they pay 5 \u20ac cash and they put 5 \u20ac on a credit card:", 
            "title": "The User Interface"
        }, 
        {
            "location": "/int-complete/#the-ios-object-model", 
            "text": "Since this chapter is a review, there is nothing new to show in the object model. The difference with this code sample is that both the  add cash transaction  and the  add card transaction  methods are used to process the split-method payment from the consumer:    Tip  Just like in the  previous chapter , it is recommended you read the bottom lines of code first to see the overall payment flow.", 
            "title": "The iOS Object Model"
        }, 
        {
            "location": "/int-complete/#the-sample-code", 
            "text": "Insert GIST here and remove Objective-C below.  // The SDK is initialized as shared instance so can be accessed  // from multiple View Controllers  AcceptSDK   * sdk   =   [ AcceptSDK   sharedInstance ];  // Set the SDK target environment - in this case Public Test  // and the username and password to authenticate to it  [ sdk   setupWithEnvironment : AcceptEnvironmentPublicTest \n                  username : @ yourUsername \n                  password : @ yourPassword ];  // Create the instance of the Sale Request  // Here the minimum data is depicted  WDAcceptSaleRequest   * saleRequest   =   [[ WDAcceptSaleRequest   alloc ]   initWithUniqueId : @ yourSaleUniqueID   // provide your unique ID to identify the Sale \n                                                                         location : nil   // provide the GPS location \n                                                                   inclusiveTaxes : YES   // Tax inclusive/exclusive flag \n                                                                         currency : @ EUR   // Currency to use for this Sale \n                                                                             note : @ Test Posmate Sale   // Top level note for this sale \n                                                                  gratuityTaxRate : nil   // Gratuity tax rate - nil if no gratuity to be set later in the payment flow \n                                     ];  // Create one item named  Item 1  costing 10.00 EUR at 20% Tax  [ saleRequest   addSaleItem :[ NSDecimalNumber   decimalNumberWithString : @ 10.00 ]   // Item Unit price \n                 quantity : 1   // Item Quantity \n                  taxRate :[ NSDecimalNumber   decimalNumberWithString : @ 20.00 ]   // Item Tax rate \n          itemDescription : @ Item 1   // Item description \n                productId : nil   // External product ID - in the case you are using ERP - such as SAP and wish to refer to the product \n  ];  // Define the Sale operation as Purchase  saleRequest . operation   =   AcceptSaleOperationPurchase ;  // Create Payment Configuration to be used in the Sale API later  WDAcceptPaymentConfig   * paymentConfiguration   =   [ WDAcceptPaymentConfig   new ];  // The end of the payment process  SaleCompletion   paymentCompletion   =   ^( WDAcceptSaleResponse *   sale ,   NSError *   error ){ \n     //sale - Is the completed Sale - contains the sale status, details, results \n     //error - If any error is encountered during the sale it would be reported \n     //in the form of error and hierarchy of underlying errors to give you as much details as possible  };  // Updates from the payment flow  PaymentProgress   progressUpdate   =   ^( AcceptStateUpdate   statusUpdate ){ \n     // statusUpdate - coded statuses are reported throughout the payment flow  };  // In the case the Cardholder Signature is required by the Payment flow this block will be executed  // Your task is to respond to it by collecting the signature image from the customer and  // posting it back in the sendCollectedSignature method  SignatureRequiredRequest   signatureRequiredRequest   =   ^( WDAcceptSignatureRequest *   signatureRequest ){ \n     //signatureRequest - comes from the payment flow and once you collect the signature from the customer \n     // send it back in the signatureRequest.sendCollectedSignature \n     signatureRequest . sendCollectedSignature ([ TestUtils   signatureImageFromText : @ Test ], nil ); \n     //The signature image is transferred to the backend and stored with the Sale  };  // Note: Applicable to terminals without USER INPUT  // In the case the Cardholder Signature was collected then the merchant is required to confirm it s validity  // A. If the terminal has buttons that are used for Approving/Rejecting then this block is either never called from Payment flow  // or it s signatureVerificationCallback comes nil  // B. If the terminal does not have buttons then the Application must present a user interface to Approve/Reject the Cardholder Signature  SignatureVerificationRequest   verifySignature   =   ^( SignatureVerificationResult   signatureVerificationResult ,   NSError *   signatureVerificationError ){ \n\n     if   ( signatureVerificationResult )   { \n         // Here the simplified use of Approving the Cardholder Signature is demonstrated \n         signatureVerificationResult ( AcceptSignatureVerificationResultApproved ); \n     }  };  // Note: Applicable to terminals without USER INPUT  // In the case the payment Card has more than one card application available then the client application  // has to present user interface for the Cardholder to select preferred card application  // The list of card applications is present in appSelectionRequest.appsArray as a list of Strings  PaymentCardApplicationSelectionRequest   cardAppSelection   =   ^( WDAcceptAppSelectionRequest   *   appSelectionRequest ){ \n     // There is more than 1 card application available \n     // Present the UI for the Cardholder to select preferred card application (Debit | Credit) \n     if ( appSelectionRequest . appsArray . count     0 ){ \n         // Here we demonstrate the simplified use of selecting the first card application from the list of available card applications \n         // and sending it to the Payment flow \n         appSelectionRequest . sendSelectedCardApplication ( 0 ); \n     }  };  // Discover active terminals and use it - in this case we use the first one  // Alternatively use the one discovered previously and stored in an instance variable (or user preferences)  [ sdk . terminalManager   discoverDevices : WDAMiuraExtensionUUID \n                           completion :^( NSArray WDAcceptTerminal   *   *   _Nullable   terminals ,   NSError   *   _Nullable   devicesError ) \n  { \n      // Set this Sale in total amount 10 EUR to be settled half by Card transaction (5 EUR) \n      [ saleRequest   addCardTransaction :[ NSDecimalNumber   decimalNumberWithString : @ 5.00 ] \n                             terminal :[ terminals   firstObject ]]; \n\n      // and half by Cash transaction (5 EUR) \n      [ saleRequest   addCashTransaction :[ NSDecimalNumber   decimalNumberWithString : @ 5.00 ]]; \n\n      // Set the Sale of this payment configuration to be your new Sale Request \n      paymentConfiguration . sale   =   saleRequest ; \n\n      // Start the Payment flow \n      [[ sdk   saleManager ]   pay : paymentConfiguration   // the payment configuration containing the Sale Request \n                    progress : progressUpdate   // Block to be executed at the time of Payment flow progress update \n            collectSignature : signatureRequiredRequest   // Block to be executed at the time of Requesting the capture of the Cardholder signature \n             verifySignature : verifySignature   // Block to be executed if terminal asks Application to confirm the validity of the Cardholder signature \n       selectCardApplication : cardAppSelection   // Block to be executed if terminal asks for the Card Application selection in the case Card supports more than one card application \n                  completion : paymentCompletion ];   // Block to be executed at the end of the Payment process \n\n\n\n  }];", 
            "title": "The Sample Code"
        }, 
        {
            "location": "/int-salereturns/", 
            "text": "Sale Return\n\n\nSometimes consumers return products to a merchant and expect a refund. If the consumers want to return the entire purchase then a \nfull refund\n is required. If the consumer only wants to return a portion of their purchase, then a \npartial refund\n is required. The SDK supports both types. In the sample code, we demonstrate how to perform a full return, but it is easy to tweak this code to handle a partial refund.  \n\n\n\n\nNote\n\n\nIn the case of a card payment, the return amount is processed directly to the card that was used for payment.\n\n\n\n\n\n\nTip\n\n\nAt the time of a return, you may also want to look up the \nSale History\n so you can see the full details of the sale.\n\n\n\n\nThe Sample Code\n\n\nInsert GIST here and remove Objective-C below.\n\n\n// End of Return process\n\n\nSaleUpdateCompletion\n \ncompletion\n \n=\n \n^\nvoid\n(\nWDAcceptSaleResponse\n*\n \n_Nullable\n \nsale\n,\n \nNSError\n*\n \n_Nullable\n \nerror\n){\n\n    \n// sale - Returned Sale detail\n\n    \n// error - if encountered during the Refund process\n\n\n};\n\n\n\nWDAcceptSaleRequest\n \n*\nsaleReturn\n  \n=\n \n[\nsale\n \nsaleReturn\n];\n \n// Here we created the full Sale Return\n\n\n// Alternatively you would create the Sale Return consisting only of Items you wish to Return - aka Partial Return\n\n\n\n// Perform the Refund\n\n\n[\nsdk\n.\nsaleManager\n \nrefundSale\n:\n \nsaleReturn\n \n// The full Sale Return Request\n\n                    \nmessage\n:\n@\nMerchant Refunded\n \n// Set the note for this Return\n\n                 \ncompletion\n:\ncompletion\n];\n \n// End of Return process", 
            "title": "Sale Return"
        }, 
        {
            "location": "/int-salereturns/#sale-return", 
            "text": "Sometimes consumers return products to a merchant and expect a refund. If the consumers want to return the entire purchase then a  full refund  is required. If the consumer only wants to return a portion of their purchase, then a  partial refund  is required. The SDK supports both types. In the sample code, we demonstrate how to perform a full return, but it is easy to tweak this code to handle a partial refund.     Note  In the case of a card payment, the return amount is processed directly to the card that was used for payment.    Tip  At the time of a return, you may also want to look up the  Sale History  so you can see the full details of the sale.", 
            "title": "Sale Return"
        }, 
        {
            "location": "/int-salereturns/#the-sample-code", 
            "text": "Insert GIST here and remove Objective-C below.  // End of Return process  SaleUpdateCompletion   completion   =   ^ void ( WDAcceptSaleResponse *   _Nullable   sale ,   NSError *   _Nullable   error ){ \n     // sale - Returned Sale detail \n     // error - if encountered during the Refund process  };  WDAcceptSaleRequest   * saleReturn    =   [ sale   saleReturn ];   // Here we created the full Sale Return  // Alternatively you would create the Sale Return consisting only of Items you wish to Return - aka Partial Return  // Perform the Refund  [ sdk . saleManager   refundSale :   saleReturn   // The full Sale Return Request \n                     message : @ Merchant Refunded   // Set the note for this Return \n                  completion : completion ];   // End of Return process", 
            "title": "The Sample Code"
        }, 
        {
            "location": "/int-salereversals/", 
            "text": "Sale Reversal\n\n\nA sale reversal is typically used when a customer changes their mind about a purchase shortly after they make the purchase. A sale reversal can only be performed within a short period of time after the sale was created, that is, before it is processed by the Acquiring Platform. Sale reversals can only be processed for the full amount of the sale. Partial reversals are not supported.\n\n\n\n\nNote\n\n\nIf the merchant is using Cash Management, the Cash Register Id method needs to be called.\n\n\n\n\nThe Sample Code\n\n\n\n\nNote\n\n\nThe Android sample code is not yet implemented.\n\n\n\n\n// End of Return process\n\n\nSaleUpdateCompletion\n \ncompletion\n \n=\n \n^\nvoid\n(\nWDAcceptSaleResponse\n*\n \n_Nullable\n \nsale\n,\n \nNSError\n*\n \n_Nullable\n \nerror\n){\n\n    \n// sale - Returned Sale detail\n\n    \n// error - if encountered during the Refund process\n\n\n};\n\n\n\n// Alternatively you are able to call Sale Reverse - it is possible to Reverse the Sale which was not yet processed by Acquiring\n\n\n// The sale.isReversible flag would indicate if this Sale can be Reversed\n\n\n// The Sale Reversals are used to Cancel recently created Sale - Customers changed their mind in short time after Sale\n\n\n[\nsdk\n.\nsaleManager\n \nreverseSale\n:\n@\nSale ID\n \n// The Sale ID of the Sale you would like to Reverse the fresh Sale in full\n\n              \ncashRegisterId\n:\n@\nThe cash Register which initiated the Return\n  \n// Cash Register ID which Reversed the Sale * only needed if Cash Management enabled for the Merchant\n\n                    \nmessage\n:\n@\nMerchant Reversed\n \n// Set the note for this Return\n\n                 \ncompletion\n:\ncompletion\n];\n \n// End of Return process", 
            "title": "Sale Reversal"
        }, 
        {
            "location": "/int-salereversals/#sale-reversal", 
            "text": "A sale reversal is typically used when a customer changes their mind about a purchase shortly after they make the purchase. A sale reversal can only be performed within a short period of time after the sale was created, that is, before it is processed by the Acquiring Platform. Sale reversals can only be processed for the full amount of the sale. Partial reversals are not supported.   Note  If the merchant is using Cash Management, the Cash Register Id method needs to be called.", 
            "title": "Sale Reversal"
        }, 
        {
            "location": "/int-salereversals/#the-sample-code", 
            "text": "Note  The Android sample code is not yet implemented.   // End of Return process  SaleUpdateCompletion   completion   =   ^ void ( WDAcceptSaleResponse *   _Nullable   sale ,   NSError *   _Nullable   error ){ \n     // sale - Returned Sale detail \n     // error - if encountered during the Refund process  };  // Alternatively you are able to call Sale Reverse - it is possible to Reverse the Sale which was not yet processed by Acquiring  // The sale.isReversible flag would indicate if this Sale can be Reversed  // The Sale Reversals are used to Cancel recently created Sale - Customers changed their mind in short time after Sale  [ sdk . saleManager   reverseSale : @ Sale ID   // The Sale ID of the Sale you would like to Reverse the fresh Sale in full \n               cashRegisterId : @ The cash Register which initiated the Return    // Cash Register ID which Reversed the Sale * only needed if Cash Management enabled for the Merchant \n                     message : @ Merchant Reversed   // Set the note for this Return \n                  completion : completion ];   // End of Return process", 
            "title": "The Sample Code"
        }, 
        {
            "location": "/int-saleshistory/", 
            "text": "Sales History\n\n\nThe sale response has all the details of completed sales so it is useful to query it to view the sales history. From this, a \nquery\n is constructed that includes attributes such as:\n\n\n\n\npaging information\n\n\nordering information\n\n\nstart date\n\n\nend date\n\n\n\n\n\n\nTip\n\n\nSales History is part of the Sales Manager component. Sales Manager is implemented in Objective-C as \nsaleManager\n, whereas in Java it is implemented as \nsales()\n. \n\n\n\n\nThe Sample Code\n\n\nInsert GIST here and remove Objective-C below.\n\n\n// End of Sale Query process\n\n\nSaleQueryResponse\n \ncompletion\n \n=\n \n^\n(\nNSArray\n \nWDAcceptSaleResponse\n \n*\n*\n \n_Nullable\n \nsales\n,\n \nNSError\n*\n \n_Nullable\n \nerror\n){\n\n    \n// sales list of WDAcceptSaleResponse objects\n\n    \n// SaleResponse has all the details of the performed Sale including\n\n    \n// - Transaction details (CARD | COUPON | CASH)\n\n    \n// - Basket details\n\n\n};\n\n\n\n// Query parameters such as paging, order by , sort\n\n\n// and specific filters such as full text search, sale creation date, sale operation, sale status\n\n\nWDAcceptSalesQuery\n \n*\nquery\n \n=\n \n[\nWDAcceptSalesQuery\n \nnew\n];\n\n\nquery\n.\npage\n \n=\n \n1\n;\n\n\nquery\n.\npageSize\n \n=\n \n20\n;\n\n\nquery\n.\norderBy\n \n=\n \nAcceptTransactionsQueryOrderByCreatedAt\n;\n \n// Order by Creation date\n\n\nquery\n.\norderSort\n \n=\n \nAcceptQuerySortDescending\n;\n \n// Sort Descending - latest Sale first\n\n\nquery\n.\nstatuses\n \n=\n \n@[@(\nAcceptSaleStateCompleted\n)]\n;\n \n// Only Sales with Completed status\n\n\nquery\n.\nsaleOperations\n \n=\n \n@[\n    \n@(\nAcceptSaleOperationPurchase\n)\n,\n \n// Purchases\n\n                             \n@(\nAcceptSaleOperationAuthorize\n)\n,\n \n// Authorisations\n\n                             \n@(\nAcceptSaleOperationPreAuthorize\n)]\n;\n \n// Pre authorisations\n\n\n// Obtain the Sale\n\n\n[\nsdk\n.\nsaleManager\n \nquerySales\n:\nquery\n \n// Sale query parameters\n\n                 \ncompletion\n:\ncompletion\n];\n \n// ENd of Sale Query process", 
            "title": "Sales History"
        }, 
        {
            "location": "/int-saleshistory/#sales-history", 
            "text": "The sale response has all the details of completed sales so it is useful to query it to view the sales history. From this, a  query  is constructed that includes attributes such as:   paging information  ordering information  start date  end date    Tip  Sales History is part of the Sales Manager component. Sales Manager is implemented in Objective-C as  saleManager , whereas in Java it is implemented as  sales() .", 
            "title": "Sales History"
        }, 
        {
            "location": "/int-saleshistory/#the-sample-code", 
            "text": "Insert GIST here and remove Objective-C below.  // End of Sale Query process  SaleQueryResponse   completion   =   ^ ( NSArray   WDAcceptSaleResponse   * *   _Nullable   sales ,   NSError *   _Nullable   error ){ \n     // sales list of WDAcceptSaleResponse objects \n     // SaleResponse has all the details of the performed Sale including \n     // - Transaction details (CARD | COUPON | CASH) \n     // - Basket details  };  // Query parameters such as paging, order by , sort  // and specific filters such as full text search, sale creation date, sale operation, sale status  WDAcceptSalesQuery   * query   =   [ WDAcceptSalesQuery   new ];  query . page   =   1 ;  query . pageSize   =   20 ;  query . orderBy   =   AcceptTransactionsQueryOrderByCreatedAt ;   // Order by Creation date  query . orderSort   =   AcceptQuerySortDescending ;   // Sort Descending - latest Sale first  query . statuses   =   @[@( AcceptSaleStateCompleted )] ;   // Only Sales with Completed status  query . saleOperations   =   @[      @( AcceptSaleOperationPurchase ) ,   // Purchases \n                              @( AcceptSaleOperationAuthorize ) ,   // Authorisations \n                              @( AcceptSaleOperationPreAuthorize )] ;   // Pre authorisations  // Obtain the Sale  [ sdk . saleManager   querySales : query   // Sale query parameters \n                  completion : completion ];   // ENd of Sale Query process", 
            "title": "The Sample Code"
        }, 
        {
            "location": "/int-salesstatistics/", 
            "text": "Sales Statistics\n\n\nYou frequently need to find out how you are doing in terms of sales performance. For this purpose, it is useful to report on sales statistics. \n\n\nTo get sales statistics, you build a query object with key parameters such as the start date of the period you wish to report on and the end date, as well as which statuses you want (e.g. completed sales only). The Sales Manager component then retrieves the information you need. Other query parameters that you can retrieve include:\n\n\n\n\nMIN - amount of the smallest sale\n\n\nMAX - amount of the largest sale\n\n\nTurnover\n\n\nTransaction Counts\n\n\n\n\nThe sample code illustrates how to retrieve completed purchases because this is probably what you want to see most, but of course you can retrieve whatever data you need. In the iOS code, the \nsaleStatistics\n object has the results of the query. In the Android code, the \nsalesStatistics\n has the results.\n\n\n\n\nTip\n\n\nThe Java code uses the term \nfilter\n while the Objective-C code uses the term \nquery\n.\n\n\n\n\nThe Sample Code\n\n\nInsert GIST here and remove Objective-C below.\n\n\n// End of Sale Statistics process\n\n\nSaleStatisticsCompletion\n \ncompletion\n \n=\n \n^\n(\nNSArray\n  \nWDAcceptSaleStatistics\n \n*\n*\n \n_Nullable\n \nstatistics\n,\n \nNSError\n*\n \n_Nullable\n \nerror\n){\n\n    \n// statistics - list of WDAcceptSaleStatistics objects\n\n    \n// SaleStatistics has all the details of Sale statistics including\n\n    \n// - MIN, MAX, AVG amounts\n\n    \n// - Turnover\n\n    \n// - Transaction count\n\n\n};\n\n\n\n// Query parameters such as filters start/end Sale dates, Sale status and reporting Period\n\n\nWDAcceptStatisticsQuery\n \n*\nquery\n \n=\n \n[\nWDAcceptStatisticsQuery\n \nnew\n];\n\n\nquery\n.\nmerchantId\n \n=\n \n@\nMerchantID\n;\n \n//Your Merchant ID\n\n\nquery\n.\nprocessedFrom\n \n=\n \n[[\nNSDate\n \ndate\n]\n \ndateByAddingTimeInterval\n:\n-\n2629743.83\n];\n \n// Start date - a month\n\n\nquery\n.\nprocessedTo\n \n=\n \n[\nNSDate\n \ndate\n];\n \n// End Date\n\n\nquery\n.\nstatus\n \n=\n \nAcceptStatisticStatusCompleted\n;\n \n// Completed Sales only\n\n\nquery\n.\nperiod\n \n=\n \nAcceptStatisticPeriodMonth\n;\n \n// Month statistics period\n\n\nquery\n.\ncurrency\n \n=\n \n@\nEUR\n;\n \n// Performed Sales Currency\n\n\n\n// Obtain Sale statistics\n\n\n[\nsdk\n.\nsaleManager\n \nsalesStatistics\n:\nquery\n \n// Sale statistics query parameters\n\n                      \ncompletion\n:\ncompletion\n];\n \n// End of Sale Statistics Query process", 
            "title": "Sales Statistics"
        }, 
        {
            "location": "/int-salesstatistics/#sales-statistics", 
            "text": "You frequently need to find out how you are doing in terms of sales performance. For this purpose, it is useful to report on sales statistics.   To get sales statistics, you build a query object with key parameters such as the start date of the period you wish to report on and the end date, as well as which statuses you want (e.g. completed sales only). The Sales Manager component then retrieves the information you need. Other query parameters that you can retrieve include:   MIN - amount of the smallest sale  MAX - amount of the largest sale  Turnover  Transaction Counts   The sample code illustrates how to retrieve completed purchases because this is probably what you want to see most, but of course you can retrieve whatever data you need. In the iOS code, the  saleStatistics  object has the results of the query. In the Android code, the  salesStatistics  has the results.   Tip  The Java code uses the term  filter  while the Objective-C code uses the term  query .", 
            "title": "Sales Statistics"
        }, 
        {
            "location": "/int-salesstatistics/#the-sample-code", 
            "text": "Insert GIST here and remove Objective-C below.  // End of Sale Statistics process  SaleStatisticsCompletion   completion   =   ^ ( NSArray    WDAcceptSaleStatistics   * *   _Nullable   statistics ,   NSError *   _Nullable   error ){ \n     // statistics - list of WDAcceptSaleStatistics objects \n     // SaleStatistics has all the details of Sale statistics including \n     // - MIN, MAX, AVG amounts \n     // - Turnover \n     // - Transaction count  };  // Query parameters such as filters start/end Sale dates, Sale status and reporting Period  WDAcceptStatisticsQuery   * query   =   [ WDAcceptStatisticsQuery   new ];  query . merchantId   =   @ MerchantID ;   //Your Merchant ID  query . processedFrom   =   [[ NSDate   date ]   dateByAddingTimeInterval : - 2629743.83 ];   // Start date - a month  query . processedTo   =   [ NSDate   date ];   // End Date  query . status   =   AcceptStatisticStatusCompleted ;   // Completed Sales only  query . period   =   AcceptStatisticPeriodMonth ;   // Month statistics period  query . currency   =   @ EUR ;   // Performed Sales Currency  // Obtain Sale statistics  [ sdk . saleManager   salesStatistics : query   // Sale statistics query parameters \n                       completion : completion ];   // End of Sale Statistics Query process", 
            "title": "The Sample Code"
        }, 
        {
            "location": "/int-cash-overview/", 
            "text": "Cash Manager Overview\n\n\nCash Management is an optional feature of the SUPR Accept SDK. It allows you to define functionality for merchants to handle cash from their customers. A key implementation decision for a merchant is whether to use Cash Management or not. Typically, since many customers still like to use cash, merchants use the Cash Management feature. \n\n\nMost of the functionality of Cash Management is defined within the Cash Manager component. The second component that enables Cash Management is the \nCash Drawer Manager\n, which discovers and manages cash drawers and cash registers that are paired with the mobile device of the merchant user.\n\n\nFeatures of Cash Manager\n\n\nMore specifically, the Cash Manager component supports:\n\n\n\n\ncash register management\n\n\nopening and closing of shifts (a shift being a period of time worked by merchant staff)\n\n\nputting cash in or taking cash out of the cash drawer (referred to as pay in/out or as cash in/out)\n\n\nreporting on shift activity for each cash register\n\n\nreporting on cash activity (also known as Z-Reports) for each cash register\n\n\n\n\nFor complete information about the hardware required to use Cash Management, see the \nCash Drawer Manager\n chapter. \n\n\nCashier Base\n\n\nYou also have the ability with the SDK to support merchants who set up a Cashier Base. This optional capability allows for:\n\n\n\n\nsupport of PIN-authorized users\n\n\nsupport for ERP Integration (such as SAP By Design)", 
            "title": "Cash Manager Overview"
        }, 
        {
            "location": "/int-cash-overview/#cash-manager-overview", 
            "text": "Cash Management is an optional feature of the SUPR Accept SDK. It allows you to define functionality for merchants to handle cash from their customers. A key implementation decision for a merchant is whether to use Cash Management or not. Typically, since many customers still like to use cash, merchants use the Cash Management feature.   Most of the functionality of Cash Management is defined within the Cash Manager component. The second component that enables Cash Management is the  Cash Drawer Manager , which discovers and manages cash drawers and cash registers that are paired with the mobile device of the merchant user.", 
            "title": "Cash Manager Overview"
        }, 
        {
            "location": "/int-cash-overview/#features-of-cash-manager", 
            "text": "More specifically, the Cash Manager component supports:   cash register management  opening and closing of shifts (a shift being a period of time worked by merchant staff)  putting cash in or taking cash out of the cash drawer (referred to as pay in/out or as cash in/out)  reporting on shift activity for each cash register  reporting on cash activity (also known as Z-Reports) for each cash register   For complete information about the hardware required to use Cash Management, see the  Cash Drawer Manager  chapter.", 
            "title": "Features of Cash Manager"
        }, 
        {
            "location": "/int-cash-overview/#cashier-base", 
            "text": "You also have the ability with the SDK to support merchants who set up a Cashier Base. This optional capability allows for:   support of PIN-authorized users  support for ERP Integration (such as SAP By Design)", 
            "title": "Cashier Base"
        }, 
        {
            "location": "/int-cash-register/", 
            "text": "Cash Registers\n\n\nThe first step in dealing with cash is to select a cash register that will be used by the \ncash sale request\n. More specifically, you need to obtain the unique identifier for the cash register. In the sample code for both platforms, a \ncashRegisters\n object stores the valid cash register identifiers.\n\n\n\n\nTip\n\n\nFor complete information about setting up cash register and cash drawer hardware, see \nCash Drawer Manager\n.\n\n\n\n\nThe User Interface\n\n\nAs illustrated below, we are preparing for a cash transaction on a merchant user's device that has a cash register or cash drawer paired to it:\n\n\n\n\n\n\nNote\n\n\nEven though the picture might suggest a physical cable connecting the device, it is also likely that Bluetooth is used and the hardware simply needs to be paired with the device. \n\n\n\n\nThe Sample Code\n\n\nThe sample code demonstrates how to select a Cash Register where the currency is set to EUR (for \u20ac). There is no user interface defined (e.g. a list of valid cash registers) in the sample code. However, since you are obtaining an array of \ncashRegisters\n, you could also present a table of cash registers in a user interface and let the user select the cash register they wish to use, as the comments describe.\n\n\n// End of get Cash Registers process\n\n\nCashRegisterCompletion\n \ncompletion\n \n=\n \n^\n(\nNSArray\nWDAcceptCashRegister\n \n*\n \n*\n \ncashRegisters\n \n,\n \nNSError\n \n*\n \ncashRegisterErr\n){\n\n\n    \n//Select the Cash Register you wish to use later for any Sale Request\n\n    \n//This is an example how to select the Cash Register who\ns currency code is set to EUR\n\n    \nNSPredicate\n \n*\npred\n \n=\n \n[\nNSPredicate\n \npredicateWithFormat\n:\n@\nself.currency.code = \nEUR\n];\n\n    \ncashRegister\n \n=\n \n[[\ncashRegisters\n \nfilteredArrayUsingPredicate\n:\npred\n]\n \nfirstObject\n];\n\n\n    \n//Alternatively you could present the Cash Register list in the form of UITableView\n\n\n\n};\n\n\n\n//Obtain the list of Cash Registers for the Merchant who has Cash Management enabled\n\n\n[[\nsdk\n \ncashManager\n]\n \ncashRegisters\n:\n@\nYourMerchantID\n \n//Merchant ID for who to obtain the Cash Registers list\n\n                      \ncompletion\n:\ncompletion\n];\n \n// End of get Cash Registers process", 
            "title": "Cash Registers"
        }, 
        {
            "location": "/int-cash-register/#cash-registers", 
            "text": "The first step in dealing with cash is to select a cash register that will be used by the  cash sale request . More specifically, you need to obtain the unique identifier for the cash register. In the sample code for both platforms, a  cashRegisters  object stores the valid cash register identifiers.   Tip  For complete information about setting up cash register and cash drawer hardware, see  Cash Drawer Manager .", 
            "title": "Cash Registers"
        }, 
        {
            "location": "/int-cash-register/#the-user-interface", 
            "text": "As illustrated below, we are preparing for a cash transaction on a merchant user's device that has a cash register or cash drawer paired to it:    Note  Even though the picture might suggest a physical cable connecting the device, it is also likely that Bluetooth is used and the hardware simply needs to be paired with the device.", 
            "title": "The User Interface"
        }, 
        {
            "location": "/int-cash-register/#the-sample-code", 
            "text": "The sample code demonstrates how to select a Cash Register where the currency is set to EUR (for \u20ac). There is no user interface defined (e.g. a list of valid cash registers) in the sample code. However, since you are obtaining an array of  cashRegisters , you could also present a table of cash registers in a user interface and let the user select the cash register they wish to use, as the comments describe.  // End of get Cash Registers process  CashRegisterCompletion   completion   =   ^ ( NSArray WDAcceptCashRegister   *   *   cashRegisters   ,   NSError   *   cashRegisterErr ){ \n\n     //Select the Cash Register you wish to use later for any Sale Request \n     //This is an example how to select the Cash Register who s currency code is set to EUR \n     NSPredicate   * pred   =   [ NSPredicate   predicateWithFormat : @ self.currency.code =  EUR ]; \n     cashRegister   =   [[ cashRegisters   filteredArrayUsingPredicate : pred ]   firstObject ]; \n\n     //Alternatively you could present the Cash Register list in the form of UITableView  };  //Obtain the list of Cash Registers for the Merchant who has Cash Management enabled  [[ sdk   cashManager ]   cashRegisters : @ YourMerchantID   //Merchant ID for who to obtain the Cash Registers list \n                       completion : completion ];   // End of get Cash Registers process", 
            "title": "The Sample Code"
        }, 
        {
            "location": "/int-cash-shift-open/", 
            "text": "Open Shift\n\n\nJust like in the real world where employees would write down the amount of cash in their register at the beginning of a shift, the SDK requires that you also open a shift and record the amount of cash in the register. Throughout the day, cash is then put in or taken out of the cash register. This is referred to as pay in/out or cash in/out and the SDK also handles this as described in \nPay In/Out\n. \n\n\nYou must also record the amount of cash in the register when the shift is over. This is referred to as \nclosing the shift\n. For both opening and closing of shifts, the unique identifier for the cash register being used is required. The unique identifiers for cash registers are obtained by \nCash Registers\n.\n\n\n\n\nCaution\n\n\nSales can only be performed after a shift is opened.\n\n\n\n\nThe User Interface\n\n\nOnce again, to visualize what a user interface might look like we created a mockup:\n\n\n\n\nThe Sample Code\n\n\nThe sample code demonstrates how to open the shift for a specific cash register, which includes recording:\n\n\n\n\nthe amount of cash in the drawer which is very important for reconciliation purposes (\namount\n in the iOS code and \nopeningAmount\n in the Android code)\n\n\nand optionally, recording a note related to the opening of the drawer (\nnote\n in the iOS code and \nopeningNote\n in the Android code), for example, a user could indicate \"I think there is a 20 \u20ac bill missing).\n\n\n\n\n//End of Open Shift process\n\n\nvoid\n \n(\n^\ncompletion\n)(\nBOOL\n \n,\n \nNSError\n*\n \n)\n \n=\n \n^\n(\nBOOL\n \nsuccess\n,\n \nNSError\n \n*\nerror\n){\n\n    \n//success - flag if the Shift was opened successfuly\n\n\n};\n\n\n\n// Open the shift for the selected Cash Register\n\n\n[[\nsdk\n \ncashManager\n]\n \nopenShift\n:\ncashRegister\n.\ninternalId\n \n//Selected Cash Register ID\n\n                        \nnote\n:\n@\nOpen My Shift\n \n// Optional Note when opening the shift\n\n                      \namount\n:[\nNSNumber\n \nnumberWithInt\n:\n100\n]\n \n// Amount of Cash which is present in the Cash Register at the time of opening\n\n                  \ncompletion\n:\ncompletion\n];\n \n// End of Open Shift process", 
            "title": "Open Shift"
        }, 
        {
            "location": "/int-cash-shift-open/#open-shift", 
            "text": "Just like in the real world where employees would write down the amount of cash in their register at the beginning of a shift, the SDK requires that you also open a shift and record the amount of cash in the register. Throughout the day, cash is then put in or taken out of the cash register. This is referred to as pay in/out or cash in/out and the SDK also handles this as described in  Pay In/Out .   You must also record the amount of cash in the register when the shift is over. This is referred to as  closing the shift . For both opening and closing of shifts, the unique identifier for the cash register being used is required. The unique identifiers for cash registers are obtained by  Cash Registers .   Caution  Sales can only be performed after a shift is opened.", 
            "title": "Open Shift"
        }, 
        {
            "location": "/int-cash-shift-open/#the-user-interface", 
            "text": "Once again, to visualize what a user interface might look like we created a mockup:", 
            "title": "The User Interface"
        }, 
        {
            "location": "/int-cash-shift-open/#the-sample-code", 
            "text": "The sample code demonstrates how to open the shift for a specific cash register, which includes recording:   the amount of cash in the drawer which is very important for reconciliation purposes ( amount  in the iOS code and  openingAmount  in the Android code)  and optionally, recording a note related to the opening of the drawer ( note  in the iOS code and  openingNote  in the Android code), for example, a user could indicate \"I think there is a 20 \u20ac bill missing).   //End of Open Shift process  void   ( ^ completion )( BOOL   ,   NSError *   )   =   ^ ( BOOL   success ,   NSError   * error ){ \n     //success - flag if the Shift was opened successfuly  };  // Open the shift for the selected Cash Register  [[ sdk   cashManager ]   openShift : cashRegister . internalId   //Selected Cash Register ID \n                         note : @ Open My Shift   // Optional Note when opening the shift \n                       amount :[ NSNumber   numberWithInt : 100 ]   // Amount of Cash which is present in the Cash Register at the time of opening \n                   completion : completion ];   // End of Open Shift process", 
            "title": "The Sample Code"
        }, 
        {
            "location": "/int-cash-shift-close/", 
            "text": "Close Shift\n\n\nAt the end of a shift, staff who work for the merchant must record the amount of cash in their register. This can then be compared with the cash recorded at the \nopening of their shift\n. \n\n\nFor both opening and closing of shifts, the unique identifier for the cash register being used is required. The unique identifier is obtained by \nCash Registers\n.\n\n\nDuring the shift, cash that goes in and out of the cash register is recorded by \nPay In/Out\n. \n\n\n\n\nCaution\n\n\nA \nShift Report\n for a shift can only be generated after a shift is closed. \n\n\n\n\nThe User Interface\n\n\nThe user interface is almost the same as the Open Shift one, but with a couple of key changes:\n\n\n\n\nThe Code\n\n\nInsert GIST here and remove Objective-C below.\n\n\n//End of Close Shift process\n\n\nvoid\n \n(\n^\ncompletion\n)(\nBOOL\n \n,\n \nNSError\n*\n \n)\n \n=\n \n^\n(\nBOOL\n \nsuccess\n,\n \nNSError\n \n*\nerror\n){\n\n    \n//success - flag if the Shift was closed successfuly\n\n\n};\n\n\n\n// OPen the shift for the selected Cash Register\n\n\n[[\nsdk\n \ncashManager\n]\n \ncloseShift\n:\ncashRegister\n.\ninternalId\n \n//Selected Cash Register ID\n\n                        \nnote\n:\n@\nClose My Shift\n \n// Optional Note when closing the shift\n\n                      \namount\n:[\nNSNumber\n \nnumberWithInt\n:\n100\n]\n \n// Amount of Cash which is present in the Cash Register at the time of closing\n\n                  \ncompletion\n:\ncompletion\n];\n \n// End of Close Shift process", 
            "title": "Close Shift"
        }, 
        {
            "location": "/int-cash-shift-close/#close-shift", 
            "text": "At the end of a shift, staff who work for the merchant must record the amount of cash in their register. This can then be compared with the cash recorded at the  opening of their shift .   For both opening and closing of shifts, the unique identifier for the cash register being used is required. The unique identifier is obtained by  Cash Registers .  During the shift, cash that goes in and out of the cash register is recorded by  Pay In/Out .    Caution  A  Shift Report  for a shift can only be generated after a shift is closed.", 
            "title": "Close Shift"
        }, 
        {
            "location": "/int-cash-shift-close/#the-user-interface", 
            "text": "The user interface is almost the same as the Open Shift one, but with a couple of key changes:", 
            "title": "The User Interface"
        }, 
        {
            "location": "/int-cash-shift-close/#the-code", 
            "text": "Insert GIST here and remove Objective-C below.  //End of Close Shift process  void   ( ^ completion )( BOOL   ,   NSError *   )   =   ^ ( BOOL   success ,   NSError   * error ){ \n     //success - flag if the Shift was closed successfuly  };  // OPen the shift for the selected Cash Register  [[ sdk   cashManager ]   closeShift : cashRegister . internalId   //Selected Cash Register ID \n                         note : @ Close My Shift   // Optional Note when closing the shift \n                       amount :[ NSNumber   numberWithInt : 100 ]   // Amount of Cash which is present in the Cash Register at the time of closing \n                   completion : completion ];   // End of Close Shift process", 
            "title": "The Code"
        }, 
        {
            "location": "/int-cash-payinout/", 
            "text": "Pay In/Out\n\n\nWe have seen how to \nopen\n and \nclose\n a shift. In between the open and close, cash is paid in and paid out of the register. This is commonly referred to as the \npay in\n and the \npay out\n, or sometimes it is referred to as the \ncash in\n and \ncash out\n. \n\n\nYou can report on all cash activity during a shift using \nShift Activity\n, or after the shift is closed you can report on all activity using \nShift Report\n. As is usually the case when dealing with cash, the cash register's unique identifier is required, so it must be obtained by the \nCash Registers\n.\n\n\nThe User Interface\n\n\nA typical interface might look like this:\n\n\n\n\n\n\nNote\n\n\nThe Android sample code uses an amount of 200 \u20ac. \n\n\n\n\nThe Sample Code\n\n\nPay ins and pay outs are both recorded in an amount field so it is crucial to note that \npay ins are entered using a positive number\n while \npay outs are entered using a negative number\n. \n\n\n\n\nBigDecimal\n is used in the Java code with a sample value of \n200\n \u20ac hard-coded for demonstration purposes, which means the code is handling a pay in of 200 \u20ac\n\n\namount\n is used in the iOS code with a sample value of \n100\n \u20ac hard-coded for demonstration purposes, which means the code is handling a pay in of 100 \u20ac\n\n\n\n\n\n\nCaution\n\n\nAs the code comments make clear, the cash currency \nmust match the currency\n of the selected cash register.\n\n\n\n\n// End of Pay In/Out process\n\n\nvoid\n \n(\n^\ncompletion\n)(\nBOOL\n \n,\n \nNSError\n*\n \n)\n \n=\n \n^\n(\nBOOL\n \nsuccess\n,\n \nNSError\n \n*\nerror\n){\n\n    \n//success - flag if the Pay In/Out was processed successfuly\n\n\n};\n\n\n\n// Record the Cash register paying In/out cash\n\n\n[\nsdk\n.\ncashManager\n \ncashOperation\n:\n@\nCashRegisterInteralID\n \n// The selected Cash Register internal ID\n\n                          \nnote\n:\n@\nCash Pay In/Out note\n \n// Optional Note for Paying In/Out\n\n                        \namount\n:[\nNSDecimalNumber\n \ndecimalNumberWithString\n:\n@\n100\n]\n \n// The amount of Cash Paying IN (set positive amount) or OUT (set negative amount)\n\n                      \ncurrency\n:\n@\nEUR\n \n// The Cash Currency *MUST* match the currency of the selected Cash Register\n\n                    \ncompletion\n:\ncompletion\n];\n \n// End of Pay In/out process", 
            "title": "Pay In/Out"
        }, 
        {
            "location": "/int-cash-payinout/#pay-inout", 
            "text": "We have seen how to  open  and  close  a shift. In between the open and close, cash is paid in and paid out of the register. This is commonly referred to as the  pay in  and the  pay out , or sometimes it is referred to as the  cash in  and  cash out .   You can report on all cash activity during a shift using  Shift Activity , or after the shift is closed you can report on all activity using  Shift Report . As is usually the case when dealing with cash, the cash register's unique identifier is required, so it must be obtained by the  Cash Registers .", 
            "title": "Pay In/Out"
        }, 
        {
            "location": "/int-cash-payinout/#the-user-interface", 
            "text": "A typical interface might look like this:    Note  The Android sample code uses an amount of 200 \u20ac.", 
            "title": "The User Interface"
        }, 
        {
            "location": "/int-cash-payinout/#the-sample-code", 
            "text": "Pay ins and pay outs are both recorded in an amount field so it is crucial to note that  pay ins are entered using a positive number  while  pay outs are entered using a negative number .    BigDecimal  is used in the Java code with a sample value of  200  \u20ac hard-coded for demonstration purposes, which means the code is handling a pay in of 200 \u20ac  amount  is used in the iOS code with a sample value of  100  \u20ac hard-coded for demonstration purposes, which means the code is handling a pay in of 100 \u20ac    Caution  As the code comments make clear, the cash currency  must match the currency  of the selected cash register.   // End of Pay In/Out process  void   ( ^ completion )( BOOL   ,   NSError *   )   =   ^ ( BOOL   success ,   NSError   * error ){ \n     //success - flag if the Pay In/Out was processed successfuly  };  // Record the Cash register paying In/out cash  [ sdk . cashManager   cashOperation : @ CashRegisterInteralID   // The selected Cash Register internal ID \n                           note : @ Cash Pay In/Out note   // Optional Note for Paying In/Out \n                         amount :[ NSDecimalNumber   decimalNumberWithString : @ 100 ]   // The amount of Cash Paying IN (set positive amount) or OUT (set negative amount) \n                       currency : @ EUR   // The Cash Currency *MUST* match the currency of the selected Cash Register \n                     completion : completion ];   // End of Pay In/out process", 
            "title": "The Sample Code"
        }, 
        {
            "location": "/int-cash-shift-activity/", 
            "text": "Shift Activity\n\n\nYou can query all \npay in/out\n activity for:\n\n\n\n\na specific shift and \n\n\na specific cash register \n\n\n\n\nAnd then use that information to report on shift activity. Once again, the cash register's unique identifier is required, so it must first be obtained using \nCash Registers\n.\n\n\nThe Code\n\n\nInsert GIST here and remove Objective-C below.\n\n\n// End of Shift operations process\n\n\nCashRegisterActivityCompletion\n \ncompletion\n  \n=\n \n^\n(\n \nNSArray\n \nWDAcceptCashActivity\n \n*\n*\n \n_Nullable\n \ncashActivities\n,\n \nNSError\n \n*\n \n_Nullable\n \ncashActivitiesError\n){\n\n    \n// cashActivities List of Cash In/Out activities for the specified Shift and Cash Register\n\n\n};\n\n\n\n// Additional Query details such as page ,page size\n\n\nWDAcceptQuery\n \n*\nquery\n \n=\n \n[\nWDAcceptQuery\n \nnew\n \n];\n\n\nquery\n.\npage\n \n=\n \n1\n;\n\n\nquery\n.\npageSize\n \n=\n \n20\n;\n\n\n\n[\nsdk\n.\ncashManager\n \ngetOperationsForShift\n:\n@\nShiftID\n \n// Shift for which to query the activities\n\n                                 \nquery\n:\nquery\n \n// additional query details\n\n               \nbelongingToCashRegister\n:\n \n@\nCashRegisterInteralID\n \n// The selected Cash Register internal ID\n\n                            \ncompletion\n:\ncompletion\n];\n \n// End of Shift activities process", 
            "title": "Shift Activity"
        }, 
        {
            "location": "/int-cash-shift-activity/#shift-activity", 
            "text": "You can query all  pay in/out  activity for:   a specific shift and   a specific cash register    And then use that information to report on shift activity. Once again, the cash register's unique identifier is required, so it must first be obtained using  Cash Registers .", 
            "title": "Shift Activity"
        }, 
        {
            "location": "/int-cash-shift-activity/#the-code", 
            "text": "Insert GIST here and remove Objective-C below.  // End of Shift operations process  CashRegisterActivityCompletion   completion    =   ^ (   NSArray   WDAcceptCashActivity   * *   _Nullable   cashActivities ,   NSError   *   _Nullable   cashActivitiesError ){ \n     // cashActivities List of Cash In/Out activities for the specified Shift and Cash Register  };  // Additional Query details such as page ,page size  WDAcceptQuery   * query   =   [ WDAcceptQuery   new   ];  query . page   =   1 ;  query . pageSize   =   20 ;  [ sdk . cashManager   getOperationsForShift : @ ShiftID   // Shift for which to query the activities \n                                  query : query   // additional query details \n                belongingToCashRegister :   @ CashRegisterInteralID   // The selected Cash Register internal ID \n                             completion : completion ];   // End of Shift activities process", 
            "title": "The Code"
        }, 
        {
            "location": "/int-cash-shift-report/", 
            "text": "Shift Report\n\n\nAfter a shift is \nclosed\n, cash operations performed during the shift can be reported in the Shift Report. Data included in the Shift Report includes:\n\n\n\n\nopening and closing times\n\n\nopening and closing amounts\n\n\ncashier names\n\n\nsale categories (cash, card or coupon)\n\n\nnet amount\n\n\ngross amount per sale (for purchases and returns)\n\n\ntax charged\n\n\n\n\nThe Shift identifier and Cash Register identifier are both required.\n\n\n\n\nNote\n\n\nA Shift Report is also known as a Z-Report.\n\n\n\n\nThe Sample Code\n\n\nOn both platforms, the \ncashShift\n has all of the information needed to create the Shift Report. \n\n\n\n\nCaution\n\n\nOn both platforms, a shift must first be \nclosed\n before you can generate a shift report.\n\n\n\n\n// It is possible to get the Shift details either from Shift Query or Shift Detail\n\n\n// A. Search for all Shifts for the specified Cash Register\n\n\n// End of Shifts query process\n\n\nCashRegisterShiftCompletion\n \ncompletion\n \n=\n  \n^\n(\n \nNSArray\n \nWDAcceptCashShift\n \n*\n*\n \n_Nullable\n \ncashShifts\n,\n \nNSError\n \n*\n \n_Nullable\n \ncashShiftsError\n){\n\n    \n// cashShift of WDAcceptCashShift type contains all data necessary to create the Z-Report:\n\n    \n// Opening and Closing amounts, times, Cashier names, Categories of Sales (Cash, Card, Coupon), Netto, Gross per Sale operation (Purchase, Return) and Tax Level\n\n\n};\n\n\n\n// Define the query details such as Paging, Order By and Sort Order\n\n\nWDAcceptShiftQuery\n \n*\nquery\n \n=\n \n[\nWDAcceptShiftQuery\n \nnew\n];\n\n\nquery\n.\npageSize\n \n=\n \n20\n;\n\n\nquery\n.\npage\n \n=\n \n1\n;\n\n\nquery\n.\norderBy\n \n=\n \nAcceptShiftQueryOrderByOpenTime\n;\n\n\nquery\n.\norderSort\n \n=\n \nAcceptQuerySortDescending\n;\n\n\n\n[\nsdk\n.\ncashManager\n \nshifts\n:\n@\nCashRegisterInteralID\n \n// Selected Cash register ID\n\n                  \nquery\n:\nquery\n \n// Query details\n\n             \ncompletion\n:\ncompletion\n];\n \n// End of query process\n\n\n\n// B. Get the details of the selected Shift\n\n\n// End of Shift detail process\n\n\nCashRegisterShiftDetailsCompletion\n \ncompletionShift\n \n=\n  \n^\n(\n  \nWDAcceptCashShift\n \n*\n \n_Nullable\n \ncashShift\n,\n \nNSError\n \n*\n \n_Nullable\n \ncashShiftError\n){\n\n    \n// cashShift of WDAcceptCashShift type contains all data necessary to create the Z-Report:\n\n    \n// Opening and Closing amounts, times, Cashier names, Categories of Sales (Cash, Card, Coupon), Netto, Gross per Sale operation (Purchase, Return) and Tax Level\n\n\n};\n\n\n\n[\nsdk\n.\ncashManager\n \nshiftDetails\n:\n@\nShiftID\n \n// Selected Shift ID\n\n                 \ncashRegister\n:\n@\nCashRegisterInteralID\n \n// Selected Cash register ID\n\n                   \ncompletion\n:\ncompletionShift\n];\n \n// End of Shift Detail process", 
            "title": "Shift Report"
        }, 
        {
            "location": "/int-cash-shift-report/#shift-report", 
            "text": "After a shift is  closed , cash operations performed during the shift can be reported in the Shift Report. Data included in the Shift Report includes:   opening and closing times  opening and closing amounts  cashier names  sale categories (cash, card or coupon)  net amount  gross amount per sale (for purchases and returns)  tax charged   The Shift identifier and Cash Register identifier are both required.   Note  A Shift Report is also known as a Z-Report.", 
            "title": "Shift Report"
        }, 
        {
            "location": "/int-cash-shift-report/#the-sample-code", 
            "text": "On both platforms, the  cashShift  has all of the information needed to create the Shift Report.    Caution  On both platforms, a shift must first be  closed  before you can generate a shift report.   // It is possible to get the Shift details either from Shift Query or Shift Detail  // A. Search for all Shifts for the specified Cash Register  // End of Shifts query process  CashRegisterShiftCompletion   completion   =    ^ (   NSArray   WDAcceptCashShift   * *   _Nullable   cashShifts ,   NSError   *   _Nullable   cashShiftsError ){ \n     // cashShift of WDAcceptCashShift type contains all data necessary to create the Z-Report: \n     // Opening and Closing amounts, times, Cashier names, Categories of Sales (Cash, Card, Coupon), Netto, Gross per Sale operation (Purchase, Return) and Tax Level  };  // Define the query details such as Paging, Order By and Sort Order  WDAcceptShiftQuery   * query   =   [ WDAcceptShiftQuery   new ];  query . pageSize   =   20 ;  query . page   =   1 ;  query . orderBy   =   AcceptShiftQueryOrderByOpenTime ;  query . orderSort   =   AcceptQuerySortDescending ;  [ sdk . cashManager   shifts : @ CashRegisterInteralID   // Selected Cash register ID \n                   query : query   // Query details \n              completion : completion ];   // End of query process  // B. Get the details of the selected Shift  // End of Shift detail process  CashRegisterShiftDetailsCompletion   completionShift   =    ^ (    WDAcceptCashShift   *   _Nullable   cashShift ,   NSError   *   _Nullable   cashShiftError ){ \n     // cashShift of WDAcceptCashShift type contains all data necessary to create the Z-Report: \n     // Opening and Closing amounts, times, Cashier names, Categories of Sales (Cash, Card, Coupon), Netto, Gross per Sale operation (Purchase, Return) and Tax Level  };  [ sdk . cashManager   shiftDetails : @ ShiftID   // Selected Shift ID \n                  cashRegister : @ CashRegisterInteralID   // Selected Cash register ID \n                    completion : completionShift ];   // End of Shift Detail process", 
            "title": "The Sample Code"
        }, 
        {
            "location": "/int-cash-cashiers/", 
            "text": "Cashiers\n\n\nCashiers can be defined in the back-end. They are used primarily for integration with an ERP system. Each merchant user can be associated with a Cashier, which is then used in the ERP for measurement of cashier sales. \n\n\nThere are two methods to obtain the identifier for a Cashier:\n\n\n\n\nObtain the cashier linked to the merchant user who is already logged in.\n\n\nPresent a PIN entry user interface to the merchant user and have them log in.\n\n\n\n\nThis chapter covers the first use case, while the \nnext chapter\n covers the PIN entry validation use case.\n\n\nThe Sample Code\n\n\nInsert GIST here and remove Objective-C below.\n\n\n// End of Cashiers process\n\n\nMerchantCashierCompletion\n \ncompletion\n \n=\n \n^\n(\n \nNSArray\n \nWDAcceptMerchantCashier\n \n*\n*\n \n_Nullable\n \nmerchantCashiers\n,\n \nNSError\n \n*\n \n_Nullable\n \nmerchantCashiersError\n){\n\n    \n// merchantCashiers - one element array containing the Cashier detail linked to the currenlty logged in Merchant user\n\n     \n/**\n\n\n      * 1. Initialise SDK with merchant credentials\n\n\n      * 2. If the Merchant User has Cashier linked\n\n\n      *      2.1 Present the Cashier details for PIN capture\n\n\n      *      2.2 Capture the Cashiers PIN\n\n\n      *      2.3 Validate PIN [sdk.cashManager validatePin:cashierId:completion]\n\n\n      *      2.4 If PIN NOT valid disallow application access otherwise\n\n\n      * 3. Allow application access\n\n\n      **/\n\n\n};\n\n\n\n//Obtain the current Merchant User Cashier detail (linked Cashier)\n\n\n[\nsdk\n.\ncashManager\n \ncashiers\n:\ncompletion\n];", 
            "title": "Cashiers"
        }, 
        {
            "location": "/int-cash-cashiers/#cashiers", 
            "text": "Cashiers can be defined in the back-end. They are used primarily for integration with an ERP system. Each merchant user can be associated with a Cashier, which is then used in the ERP for measurement of cashier sales.   There are two methods to obtain the identifier for a Cashier:   Obtain the cashier linked to the merchant user who is already logged in.  Present a PIN entry user interface to the merchant user and have them log in.   This chapter covers the first use case, while the  next chapter  covers the PIN entry validation use case.", 
            "title": "Cashiers"
        }, 
        {
            "location": "/int-cash-cashiers/#the-sample-code", 
            "text": "Insert GIST here and remove Objective-C below.  // End of Cashiers process  MerchantCashierCompletion   completion   =   ^ (   NSArray   WDAcceptMerchantCashier   * *   _Nullable   merchantCashiers ,   NSError   *   _Nullable   merchantCashiersError ){ \n     // merchantCashiers - one element array containing the Cashier detail linked to the currenlty logged in Merchant user \n      /**        * 1. Initialise SDK with merchant credentials        * 2. If the Merchant User has Cashier linked        *      2.1 Present the Cashier details for PIN capture        *      2.2 Capture the Cashiers PIN        *      2.3 Validate PIN [sdk.cashManager validatePin:cashierId:completion]        *      2.4 If PIN NOT valid disallow application access otherwise        * 3. Allow application access        **/  };  //Obtain the current Merchant User Cashier detail (linked Cashier)  [ sdk . cashManager   cashiers : completion ];", 
            "title": "The Sample Code"
        }, 
        {
            "location": "/int-cash-cashiers-pin/", 
            "text": "Cashiers with PIN\n\n\nThe second use case for obtaining a Cashier is to have them enter a PIN and then validate it. For more information about Cashiers, see the \nCashiers\n chapter. \n\n\nThe User Interface\n\n\nA typical interface might look like this:\n\n\n\n\nThe Sample Code\n\n\nInsert GIST here and remove Objective-C below.\n\n\n// End of PIN validation process\n\n\nMerchantCashierPinValidationCompletion\n \ncompletion\n \n=\n \n^\n(\n \nAcceptCashierPinValidationResult\n \npinValidationResult\n,\n \nNSError\n \n*\n \n_Nullable\n \nmerchantCashierValidationError\n){\n\n    \n// pinValidationResult - contains the flag that informs about PIN validation result\n\n\n};\n\n\n// Validate PIN entered by a Cashier\n\n\n[\nsdk\n.\ncashManager\n \nvalidatePin\n:\n@\nCashiersPIN\n \n// Cashier PIN - plain text entered by a Cashier\n\n                   \ncashierId\n:\n@\nCashierID\n \n// Cashier ID - Switch Internal ID\n\n                  \ncompletion\n:\ncompletion\n];\n \n// End of PIN validation process", 
            "title": "Cashiers With PIN"
        }, 
        {
            "location": "/int-cash-cashiers-pin/#cashiers-with-pin", 
            "text": "The second use case for obtaining a Cashier is to have them enter a PIN and then validate it. For more information about Cashiers, see the  Cashiers  chapter.", 
            "title": "Cashiers with PIN"
        }, 
        {
            "location": "/int-cash-cashiers-pin/#the-user-interface", 
            "text": "A typical interface might look like this:", 
            "title": "The User Interface"
        }, 
        {
            "location": "/int-cash-cashiers-pin/#the-sample-code", 
            "text": "Insert GIST here and remove Objective-C below.  // End of PIN validation process  MerchantCashierPinValidationCompletion   completion   =   ^ (   AcceptCashierPinValidationResult   pinValidationResult ,   NSError   *   _Nullable   merchantCashierValidationError ){ \n     // pinValidationResult - contains the flag that informs about PIN validation result  };  // Validate PIN entered by a Cashier  [ sdk . cashManager   validatePin : @ CashiersPIN   // Cashier PIN - plain text entered by a Cashier \n                    cashierId : @ CashierID   // Cashier ID - Switch Internal ID \n                   completion : completion ];   // End of PIN validation process", 
            "title": "The Sample Code"
        }, 
        {
            "location": "/int-inventory-overview/", 
            "text": "Inventory Manager Overview\n\n\nThe collection of items that a merchant sells is known as their \ninventory\n. An inventory is typically made up of what are referred to as \nproducts\n. \n\n\nLocal or ERP Storage of Product Data\n\n\nIt is important to understand that inventory data can be stored either:\n\n\n\n\nlocally on the merchant's device\n\n\nor centrally in the merchant's back-end ERP system\n\n\n\n\nThis makes sense because some merchants may have thousands of products and these of course need to be centrally maintained. The distinction is crucial because some of functionality of Inventory Manager is designed to handle locally stored data, while others are for ERP storage.\n\n\nLocal Storage Methods\n\n\nThe following chapters describe how to handle locally stored product-related data:\n\n\n\n\nMaintain Product Catalogues\n\n\nMaintain Product Categories\n\n\nMaintain Products\n\n\nProduct Changes\n\n\nProduct Images Changes\n\n\n\n\nERP Storage Methods\n\n\nThe following chapters describe how to handle product-related data that is stored in an ERP system:\n\n\n\n\nProduct Stocks (ERP)\n\n\nProduct Prices (ERP)\n\n\n\n\n\n\nNote\n\n\nStock is just another way to say quantity or number. \"Do you have that in stock?\" is a common phrase by a customer asking a merchant if they have a certain product available.\n\n\n\n\nProducts, Categories and Catalogues\n\n\nThe first three chapters in this section describe how to set up products, categories and catalogues so it is import to understand the hierarchy of these entities, as illustrated below using an example of a flower shop:\n\n\n\n\nIn this example, the product catalogue has three categories and six products in a single catalogue. The categories include (from left to right):\n\n\n\n\nTulips\n\n\nOrchids\n\n\nRoses\n\n\n\n\nWithin the roses category, there are six products available: \n\n\n\n\nMix (colors)\n\n\nOrange\n\n\nPink\n\n\nPink/Purple\n\n\nRed\n\n\nYellow\n\n\n\n\nThe Inventory Manager provides methods that enable Create, Retrieve, Update and Delete (CRUD) functionality for:\n\n\n\n\nproduct catalogues\n\n\nproduct categories\n\n\nproducts", 
            "title": "Inventory Manager Overview"
        }, 
        {
            "location": "/int-inventory-overview/#inventory-manager-overview", 
            "text": "The collection of items that a merchant sells is known as their  inventory . An inventory is typically made up of what are referred to as  products .", 
            "title": "Inventory Manager Overview"
        }, 
        {
            "location": "/int-inventory-overview/#local-or-erp-storage-of-product-data", 
            "text": "It is important to understand that inventory data can be stored either:   locally on the merchant's device  or centrally in the merchant's back-end ERP system   This makes sense because some merchants may have thousands of products and these of course need to be centrally maintained. The distinction is crucial because some of functionality of Inventory Manager is designed to handle locally stored data, while others are for ERP storage.", 
            "title": "Local or ERP Storage of Product Data"
        }, 
        {
            "location": "/int-inventory-overview/#local-storage-methods", 
            "text": "The following chapters describe how to handle locally stored product-related data:   Maintain Product Catalogues  Maintain Product Categories  Maintain Products  Product Changes  Product Images Changes", 
            "title": "Local Storage Methods"
        }, 
        {
            "location": "/int-inventory-overview/#erp-storage-methods", 
            "text": "The following chapters describe how to handle product-related data that is stored in an ERP system:   Product Stocks (ERP)  Product Prices (ERP)    Note  Stock is just another way to say quantity or number. \"Do you have that in stock?\" is a common phrase by a customer asking a merchant if they have a certain product available.", 
            "title": "ERP Storage Methods"
        }, 
        {
            "location": "/int-inventory-overview/#products-categories-and-catalogues", 
            "text": "The first three chapters in this section describe how to set up products, categories and catalogues so it is import to understand the hierarchy of these entities, as illustrated below using an example of a flower shop:   In this example, the product catalogue has three categories and six products in a single catalogue. The categories include (from left to right):   Tulips  Orchids  Roses   Within the roses category, there are six products available:    Mix (colors)  Orange  Pink  Pink/Purple  Red  Yellow   The Inventory Manager provides methods that enable Create, Retrieve, Update and Delete (CRUD) functionality for:   product catalogues  product categories  products", 
            "title": "Products, Categories and Catalogues"
        }, 
        {
            "location": "/int-maint-prod-catalogues/", 
            "text": "Maintain Product Catalogues\n\n\nA \nproduct catalogue\n represents the complete set of products that a merchant has for sale. This chapter describes the sample code you can use to create, update, retrieve and delete product catalogues that are stored locally. After setting up your product catalogue you can then set up your \nproduct categories\n and, in turn, your \nproducts\n. \n\n\nThe User Interface\n\n\nFor example, if a store merchant sells flowers, the first page of their catalogue might look like this:\n\n\n\n\nThe Sample Code\n\n\nInsert GIST here and remove Objective-C below.\n\n\n\n\nNote\n\n\nOn iOS, the Inventory Manager is implement by \ninventoryManagers\n, while on Android it is implemented by \ninventory()\n.\n\n\n\n\n\n\nTip\n\n\nAs mentioned previously, to understand the overall flow of the iOS code look first at the calls to \nsdk.inventoryManager\n, at the bottom of each segment of code, because this section of code defines the overall process flow. \n\n\n\n\n\n\nCaution\n\n\nIf you are integrating with SAP Business ByDesign, only query actions are allowed.\n\n\n\n\n__block\n \nNSArray\n \n*\nproductCataloguesArr\n;\n// list of Product Catalogues from CRUD process\n\n\n//End of Product Catalogue Maintenance process\n\n\nProductCatalogueCompletion\n \ncompletion\n \n=\n \n^\n(\nNSArray\n \nWDAcceptProductCatalogue\n \n*\n*\n \nproductCatalogues\n,\n \nNSError\n*\n \nerror\n)\n \n{\n\n    \n//productCatalogues - list of product catalogues of this merchant\n\n    \n//                    having the latest changes after maintenance action was performed\n\n    \nproductCataloguesArr\n \n=\n \nproductCatalogues\n;\n\n\n};\n\n\n\n//******************* RETRIEVE *******************//\n\n\n// GET the list of product catalogues for this merchant\n\n\n[\nsdk\n.\ninventoryManager\n \nproductCatalogues\n:\n@\nYourMerchantID\n \n// Merchant ID for which to obtain the product catalogue\n\n                             \ncompletion\n:\ncompletion\n];\n//End of query process\n\n\n\n//******************** CREATE ********************//\n\n\n// CREATE the new Product Catalogue\n\n\n// Setup the catalogue details\n\n\nWDAcceptProductCatalogue\n \n*\nnewProductCatalogue\n \n=\n \n[\nWDAcceptProductCatalogue\n \nnew\n];\n\n\nnewProductCatalogue\n.\nmerchantId\n \n=\n \n@\nYourMerchantID\n;\n \n//  Your Merchant ID\n\n\nnewProductCatalogue\n.\nproductCatalogueName\n \n=\n \n@\nMy Product Catalogue\n;\n \n// Name of the Product Catalogue\n\n\nnewProductCatalogue\n.\nproductCatalogueDescription\n \n=\n \n@\nProduct Catalogue - Unspecified\n;\n \n// Product Catalogue description\n\n\n// Store the data in the backend\n\n\n[\nsdk\n.\ninventoryManager\n \nmakeProductCatalogue\n:\nnewProductCatalogue\n\n                                  \ncompletion\n:\ncompletion\n];\n\n\n\n//******************** UPDATE ********************//\n\n\n//Here we just filter for the previously created Product Catalogue - filtering the results by the Product Catalogue name\n\n\nNSPredicate\n \n*\nfilter\n \n=\n \n[\nNSPredicate\n \npredicateWithFormat\n:\n@\nSELF.productCatalogueName = %@\n,\n@\nMy Product Catalogue\n];\n\n\nWDAcceptProductCatalogue\n \n*\nproductCatalogue\n \n=\n \n[[\nproductCataloguesArr\n \nfilteredArrayUsingPredicate\n:\nfilter\n]\n \nfirstObject\n];\n//for simplicity selecting the first returned Product Catalogue of the name we created in the previous step\n\n\nproductCatalogue\n.\nproductCatalogueDescription\n \n=\n \n@\nGroceries\n;\n \n// Update the description for previously created Product Catalogue\n\n\n\n// Updated the Product Catalogue in the backend\n\n\n[\nsdk\n.\ninventoryManager\n \nupdateProductCatalogue\n:\nproductCatalogue\n\n                                  \ncompletion\n:\ncompletion\n];\n \n// End of update process\n\n\n\n//******************** DELETE ********************//\n\n\n// Delete the Product Catalogue from the backend\n\n\n[\nsdk\n.\ninventoryManager\n \ndeleteProductCatalogue\n:\nproductCatalogue\n \n// Product Catalogue to delete (product catalogue ID and version attributes must be supplied)\n\n                                  \ncompletion\n:\ncompletion\n];\n \n// End of deletion process", 
            "title": "Maintain Product Catalogues"
        }, 
        {
            "location": "/int-maint-prod-catalogues/#maintain-product-catalogues", 
            "text": "A  product catalogue  represents the complete set of products that a merchant has for sale. This chapter describes the sample code you can use to create, update, retrieve and delete product catalogues that are stored locally. After setting up your product catalogue you can then set up your  product categories  and, in turn, your  products .", 
            "title": "Maintain Product Catalogues"
        }, 
        {
            "location": "/int-maint-prod-catalogues/#the-user-interface", 
            "text": "For example, if a store merchant sells flowers, the first page of their catalogue might look like this:", 
            "title": "The User Interface"
        }, 
        {
            "location": "/int-maint-prod-catalogues/#the-sample-code", 
            "text": "Insert GIST here and remove Objective-C below.   Note  On iOS, the Inventory Manager is implement by  inventoryManagers , while on Android it is implemented by  inventory() .    Tip  As mentioned previously, to understand the overall flow of the iOS code look first at the calls to  sdk.inventoryManager , at the bottom of each segment of code, because this section of code defines the overall process flow.     Caution  If you are integrating with SAP Business ByDesign, only query actions are allowed.   __block   NSArray   * productCataloguesArr ; // list of Product Catalogues from CRUD process  //End of Product Catalogue Maintenance process  ProductCatalogueCompletion   completion   =   ^ ( NSArray   WDAcceptProductCatalogue   * *   productCatalogues ,   NSError *   error )   { \n     //productCatalogues - list of product catalogues of this merchant \n     //                    having the latest changes after maintenance action was performed \n     productCataloguesArr   =   productCatalogues ;  };  //******************* RETRIEVE *******************//  // GET the list of product catalogues for this merchant  [ sdk . inventoryManager   productCatalogues : @ YourMerchantID   // Merchant ID for which to obtain the product catalogue \n                              completion : completion ]; //End of query process  //******************** CREATE ********************//  // CREATE the new Product Catalogue  // Setup the catalogue details  WDAcceptProductCatalogue   * newProductCatalogue   =   [ WDAcceptProductCatalogue   new ];  newProductCatalogue . merchantId   =   @ YourMerchantID ;   //  Your Merchant ID  newProductCatalogue . productCatalogueName   =   @ My Product Catalogue ;   // Name of the Product Catalogue  newProductCatalogue . productCatalogueDescription   =   @ Product Catalogue - Unspecified ;   // Product Catalogue description  // Store the data in the backend  [ sdk . inventoryManager   makeProductCatalogue : newProductCatalogue \n                                   completion : completion ];  //******************** UPDATE ********************//  //Here we just filter for the previously created Product Catalogue - filtering the results by the Product Catalogue name  NSPredicate   * filter   =   [ NSPredicate   predicateWithFormat : @ SELF.productCatalogueName = %@ , @ My Product Catalogue ];  WDAcceptProductCatalogue   * productCatalogue   =   [[ productCataloguesArr   filteredArrayUsingPredicate : filter ]   firstObject ]; //for simplicity selecting the first returned Product Catalogue of the name we created in the previous step  productCatalogue . productCatalogueDescription   =   @ Groceries ;   // Update the description for previously created Product Catalogue  // Updated the Product Catalogue in the backend  [ sdk . inventoryManager   updateProductCatalogue : productCatalogue \n                                   completion : completion ];   // End of update process  //******************** DELETE ********************//  // Delete the Product Catalogue from the backend  [ sdk . inventoryManager   deleteProductCatalogue : productCatalogue   // Product Catalogue to delete (product catalogue ID and version attributes must be supplied) \n                                   completion : completion ];   // End of deletion process", 
            "title": "The Sample Code"
        }, 
        {
            "location": "/int-maint-prod-categories/", 
            "text": "Maintain Product Categories\n\n\nGroups of related products are known as \nproduct categories\n. Typically, a merchant's \nproduct catalogue\n is divided up into product categories. \n\n\nThe User Interface\n\n\nFor example, if a store merchant sells flowers in their catalogue, their categories might include orchids, roses and tulips:\n\n\n\n\nThe Sample Code\n\n\nOf course, product categories are a subset of the product catalogue so you first need to know the unique identifier for the product catalogue. See \nMaintain Product Catalogues\n for complete information. \n\n\nInsert GIST here and remove Objective-C below.\n\n\n\n\nCaution\n\n\nIf you are integrating with SAP ByDesign, only query actions are allowed.\n\n\n\n\n__block\n \nNSArray\n \n*\nproductCategoriesArr\n;\n// list of Product Categories from CRUD process\n\n                                      \n//End of Product Categories Maintenance process\n\n\nProductCatalogueCategoryCompletion\n \ncompletion\n \n=\n \n^\n(\nNSArray\n \nWDAcceptProductCatalogueCategory\n \n*\n*\n \nresult\n,\n \nNSError\n*\n \nerr\n)\n \n{\n\n    \nproductCategoriesArr\n \n=\n \nresult\n;\n\n\n};\n\n\n\n//******************* RETRIEVE *******************//\n\n\n// GET the list of product categories from this product catalogue\n\n\n[\nsdk\n.\ninventoryManager\n \nproductCategoriesTree\n:\n@\nMy Product Catalogue\n \n// Your product catalogue Id\n\n                                 \ncompletion\n:\ncompletion\n];\n//End of query process\n\n\n\n//******************** CREATE ********************//\n\n\n// CREATE the new Product Category\n\n\n// Setup the category details\n\n\nWDAcceptProductCatalogueCategory\n \n*\nnewPC\n \n=\n \n[\nWDAcceptProductCatalogueCategory\n \nnew\n];\n\n\nnewPC\n.\ncategoryName\n \n=\n \n@\nMy Product Category\n;\n \n// Your Category name\n\n\nnewPC\n.\ndisplayOrder\n \n=\n[\nNSNumber\n \nnumberWithInt\n:\n0\n];\n \n// Display Order of this category\n\n\n\n[\nsdk\n.\ninventoryManager\n \nmakeCategory\n:\nnewPC\n\n                                \ninCatalogue\n:\n@\nMy Product Catalogue\n \n// Your product catalogue Id\n\n                                 \ncompletion\n:\ncompletion\n];\n \n// End of create process\n\n\n\n//******************** UPDATE ********************//\n\n\n//Here we just filter for the previously created Product Category - filtering the results by the Product Category name\n\n\nNSPredicate\n \n*\nfilter\n \n=\n \n[\nNSPredicate\n \npredicateWithFormat\n:\n@\nSELF.categoryName = %@\n,\n@\nMy Product Category\n];\n\n\nWDAcceptProductCatalogueCategory\n \n*\nproductCategory\n \n=\n \n[[\nproductCategoriesArr\n \nfilteredArrayUsingPredicate\n:\nfilter\n]\n \nfirstObject\n];\n//for simplicity selecting the first returned Product Category of the name we created in the previous step\n\n\nproductCategory\n.\ncategoryName\n \n=\n \n@\nMy UPDATED Category\n;\n \n// Update the name for previously created Product Category\n\n\n\n// Updated the Product Category in the backend\n\n\n[\nsdk\n.\ninventoryManager\n \nupdateProductCatalogueCategory\n:\nproductCategory\n \n// Product Category to update - containing updated data\n\n                                         \ninCatalogue\n:\n@\nMy Product Catalogue\n \n// Your product catalogue Id\n\n                                          \ncompletion\n:\ncompletion\n];\n \n// End of update process\n\n\n\n//******************** DELETE ********************//\n\n\n// Delete the Product Category from the backend\n\n\n[\nsdk\n.\ninventoryManager\n \ndeleteProductCatalogueCategory\n:\nproductCategory\n \n// Product Category to delete\n\n                                         \ninCatalogue\n:\n@\nMy Product Catalogue\n\n                                        \ncompletion\n:\ncompletion\n];\n \n// End of deletion process", 
            "title": "Maintain Product Categories"
        }, 
        {
            "location": "/int-maint-prod-categories/#maintain-product-categories", 
            "text": "Groups of related products are known as  product categories . Typically, a merchant's  product catalogue  is divided up into product categories.", 
            "title": "Maintain Product Categories"
        }, 
        {
            "location": "/int-maint-prod-categories/#the-user-interface", 
            "text": "For example, if a store merchant sells flowers in their catalogue, their categories might include orchids, roses and tulips:", 
            "title": "The User Interface"
        }, 
        {
            "location": "/int-maint-prod-categories/#the-sample-code", 
            "text": "Of course, product categories are a subset of the product catalogue so you first need to know the unique identifier for the product catalogue. See  Maintain Product Catalogues  for complete information.   Insert GIST here and remove Objective-C below.   Caution  If you are integrating with SAP ByDesign, only query actions are allowed.   __block   NSArray   * productCategoriesArr ; // list of Product Categories from CRUD process \n                                       //End of Product Categories Maintenance process  ProductCatalogueCategoryCompletion   completion   =   ^ ( NSArray   WDAcceptProductCatalogueCategory   * *   result ,   NSError *   err )   { \n     productCategoriesArr   =   result ;  };  //******************* RETRIEVE *******************//  // GET the list of product categories from this product catalogue  [ sdk . inventoryManager   productCategoriesTree : @ My Product Catalogue   // Your product catalogue Id \n                                  completion : completion ]; //End of query process  //******************** CREATE ********************//  // CREATE the new Product Category  // Setup the category details  WDAcceptProductCatalogueCategory   * newPC   =   [ WDAcceptProductCatalogueCategory   new ];  newPC . categoryName   =   @ My Product Category ;   // Your Category name  newPC . displayOrder   = [ NSNumber   numberWithInt : 0 ];   // Display Order of this category  [ sdk . inventoryManager   makeCategory : newPC \n                                 inCatalogue : @ My Product Catalogue   // Your product catalogue Id \n                                  completion : completion ];   // End of create process  //******************** UPDATE ********************//  //Here we just filter for the previously created Product Category - filtering the results by the Product Category name  NSPredicate   * filter   =   [ NSPredicate   predicateWithFormat : @ SELF.categoryName = %@ , @ My Product Category ];  WDAcceptProductCatalogueCategory   * productCategory   =   [[ productCategoriesArr   filteredArrayUsingPredicate : filter ]   firstObject ]; //for simplicity selecting the first returned Product Category of the name we created in the previous step  productCategory . categoryName   =   @ My UPDATED Category ;   // Update the name for previously created Product Category  // Updated the Product Category in the backend  [ sdk . inventoryManager   updateProductCatalogueCategory : productCategory   // Product Category to update - containing updated data \n                                          inCatalogue : @ My Product Catalogue   // Your product catalogue Id \n                                           completion : completion ];   // End of update process  //******************** DELETE ********************//  // Delete the Product Category from the backend  [ sdk . inventoryManager   deleteProductCatalogueCategory : productCategory   // Product Category to delete \n                                          inCatalogue : @ My Product Catalogue \n                                         completion : completion ];   // End of deletion process", 
            "title": "The Sample Code"
        }, 
        {
            "location": "/int-maint-product/", 
            "text": "Maintain Products\n\n\nWe have seen that the full collection of items for sale is known as the \nproduct catalogue\n, and then sub-divisions of items within a catalogue are referred to as \ncategories\n. At the lowest level of the hierarchy are the individual items themselves which are for sale. These are known as the products. This chapter describes the sample code that enables you to maintain your products locally (as opposed to on an ERP system).\n\n\nThe User Interface\n\n\nUsing the flower catalogue example, within the rose category a merchant might sell six different types of roses:\n\n\n\n\nThe Code\n\n\nAs with product categories, products are a subset of the product catalogue, so you first need to know the unique identifier for the product catalogue. See \nMaintain Product Catalogues\n for complete information. \n\n\nInsert GIST here and remove Objective-C below.\n\n\n\n\nWarning\n\n\nIf you are integrating with SAP ByDesign, only query actions are allowed.\n\n\n\n\n__block\n \nNSArray\n \n*\nproductsArr\n;\n// list of Product  from CRUD process\n\n                                      \n//End of Product  Maintenance process\n\n\nProductCatalogueProductCompletion\n \ncompletion\n \n=\n \n^\n(\nNSArray\n \nWDAcceptProductCatalogueProduct\n \n*\n*\n_Nullable\n \nproducts\n,\n \nNSError\n*\n \n_Nullable\n \nerror\n)\n \n{\n\n    \nproductsArr\n \n=\n \nproducts\n;\n\n\n};\n\n\n\n//******************* RETRIEVE *******************//\n\n\n// GET the list of products  from this product catalogue\n\n\nWDAcceptProductsQuery\n \n*\nquery\n \n=\n  \n[\nWDAcceptProductsQuery\n \nnew\n];\n//The simplest search will just yield all reasults for the product catalogue\n\n\nquery\n.\nproductCatalogueId\n \n=\n \n@\nMy Product Catalogue\n;\n \n// Your product catalogue Id\n\n\n\n[\nsdk\n.\ninventoryManager\n \nproducts\n:\nquery\n \n// Query attributes\n\n                 \nuncategorized\n:\nYES\n \n// Return also products which are not assigned to any category\n\n                    \ncompletion\n:\ncompletion\n];\n//End of query process\n\n\n\n//******************** CREATE ********************//\n\n\n// CREATE the new Product\n\n\n// Setup the product details\n\n\nWDAcceptProductCatalogueProduct\n \n*\nnewPC\n \n=\n \n[\nWDAcceptProductCatalogueProduct\n \nnew\n];\n\n\nnewPC\n.\nproductName\n \n=\n \n@\nMy new product\n;\n\n\nnewPC\n.\nproductCategories\n \n=\n \nnil\n;\n \n// This product will be uncetegorized initially (default)\n\n                               \n// You can query the available Cetegories to be set for this product if needed\n\n\nWDAcceptUnitPrice\n \n*\nup\n \n=\n \n[\nWDAcceptUnitPrice\n \nnew\n];\n \n// Set the Unit Price for this product\n\n\nWDAcceptCurrencyCore\n \n*\ncurrency\n \n=\n \n[\nWDAcceptCurrencyCore\n \nnew\n];\n \n// Set the currency for the Unit Price\n\n\ncurrency\n.\ncode\n \n=\n \n@\nEUR\n;\n\n\nup\n.\ncurrency\n \n=\n \ncurrency\n;\n\n\nup\n.\nunitValue\n \n=\n \n[\nNSNumber\n \nnumberWithFloat\n:\n2.25\n];\n\n\nnewPC\n.\nproductUnitPrices\n \n=\n \n@[\nup\n]\n;\n \n// Product can have multiple Unit Prices in various currencies\n\n\nnewPC\n.\nexternalId\n \n=\n \n@\n0123456\n;\n \n// ERP integration - SAP by Design Product ID\n\n\n\n[\nsdk\n.\ninventoryManager\n \nmakeProduct\n:\nnewPC\n \n// Product to create\n\n                      \ninCatalogue\n:\n@\nMy Product Catalogue\n \n// Product catalogue to create the product in\n\n                       \ncompletion\n:\ncompletion\n];\n\n\n\n//******************** UPDATE ********************//\n\n\n//Here we just filter for the previously created Product - filtering the results by the Product name\n\n\nNSPredicate\n \n*\nfilter\n \n=\n \n[\nNSPredicate\n \npredicateWithFormat\n:\n@\nproductName = %@\n,\n@\nMy new product\n];\n\n\nWDAcceptProductCatalogueProduct\n \n*\nproduct\n \n=\n \n[[\nproductsArr\n \nfilteredArrayUsingPredicate\n:\nfilter\n]\n \nfirstObject\n];\n//for simplicity selecting the first returned Product of the name we created in the previous step\n\n\nproduct\n.\nproductName\n \n=\n \n@\nMy UPDATED product\n;\n \n// Update the name for previously created Product\n\n\n\n// Updated the Product Category in the backend\n\n\n[\nsdk\n.\ninventoryManager\n \nupdateProduct\n:\nproduct\n \n// Product to update - containing updated data\n\n                        \ninCatalogue\n:\n@\nMy Product Catalogue\n \n// Your product catalogue Id\n\n                         \ncompletion\n:\ncompletion\n];\n \n// End of update process\n\n\n\n//******************** DELETE ********************//\n\n\n// Delete the Product Category from the backend\n\n\n[\nsdk\n.\ninventoryManager\n \ndeleteProduct\n:\nproduct\n \n// Product  to delete\n\n                        \ninCatalogue\n:\n@\nMy Product Catalogue\n\n                         \ncompletion\n:\ncompletion\n];\n \n// End of deletion process", 
            "title": "Maintain Products"
        }, 
        {
            "location": "/int-maint-product/#maintain-products", 
            "text": "We have seen that the full collection of items for sale is known as the  product catalogue , and then sub-divisions of items within a catalogue are referred to as  categories . At the lowest level of the hierarchy are the individual items themselves which are for sale. These are known as the products. This chapter describes the sample code that enables you to maintain your products locally (as opposed to on an ERP system).", 
            "title": "Maintain Products"
        }, 
        {
            "location": "/int-maint-product/#the-user-interface", 
            "text": "Using the flower catalogue example, within the rose category a merchant might sell six different types of roses:", 
            "title": "The User Interface"
        }, 
        {
            "location": "/int-maint-product/#the-code", 
            "text": "As with product categories, products are a subset of the product catalogue, so you first need to know the unique identifier for the product catalogue. See  Maintain Product Catalogues  for complete information.   Insert GIST here and remove Objective-C below.   Warning  If you are integrating with SAP ByDesign, only query actions are allowed.   __block   NSArray   * productsArr ; // list of Product  from CRUD process \n                                       //End of Product  Maintenance process  ProductCatalogueProductCompletion   completion   =   ^ ( NSArray   WDAcceptProductCatalogueProduct   * * _Nullable   products ,   NSError *   _Nullable   error )   { \n     productsArr   =   products ;  };  //******************* RETRIEVE *******************//  // GET the list of products  from this product catalogue  WDAcceptProductsQuery   * query   =    [ WDAcceptProductsQuery   new ]; //The simplest search will just yield all reasults for the product catalogue  query . productCatalogueId   =   @ My Product Catalogue ;   // Your product catalogue Id  [ sdk . inventoryManager   products : query   // Query attributes \n                  uncategorized : YES   // Return also products which are not assigned to any category \n                     completion : completion ]; //End of query process  //******************** CREATE ********************//  // CREATE the new Product  // Setup the product details  WDAcceptProductCatalogueProduct   * newPC   =   [ WDAcceptProductCatalogueProduct   new ];  newPC . productName   =   @ My new product ;  newPC . productCategories   =   nil ;   // This product will be uncetegorized initially (default) \n                                // You can query the available Cetegories to be set for this product if needed  WDAcceptUnitPrice   * up   =   [ WDAcceptUnitPrice   new ];   // Set the Unit Price for this product  WDAcceptCurrencyCore   * currency   =   [ WDAcceptCurrencyCore   new ];   // Set the currency for the Unit Price  currency . code   =   @ EUR ;  up . currency   =   currency ;  up . unitValue   =   [ NSNumber   numberWithFloat : 2.25 ];  newPC . productUnitPrices   =   @[ up ] ;   // Product can have multiple Unit Prices in various currencies  newPC . externalId   =   @ 0123456 ;   // ERP integration - SAP by Design Product ID  [ sdk . inventoryManager   makeProduct : newPC   // Product to create \n                       inCatalogue : @ My Product Catalogue   // Product catalogue to create the product in \n                        completion : completion ];  //******************** UPDATE ********************//  //Here we just filter for the previously created Product - filtering the results by the Product name  NSPredicate   * filter   =   [ NSPredicate   predicateWithFormat : @ productName = %@ , @ My new product ];  WDAcceptProductCatalogueProduct   * product   =   [[ productsArr   filteredArrayUsingPredicate : filter ]   firstObject ]; //for simplicity selecting the first returned Product of the name we created in the previous step  product . productName   =   @ My UPDATED product ;   // Update the name for previously created Product  // Updated the Product Category in the backend  [ sdk . inventoryManager   updateProduct : product   // Product to update - containing updated data \n                         inCatalogue : @ My Product Catalogue   // Your product catalogue Id \n                          completion : completion ];   // End of update process  //******************** DELETE ********************//  // Delete the Product Category from the backend  [ sdk . inventoryManager   deleteProduct : product   // Product  to delete \n                         inCatalogue : @ My Product Catalogue \n                          completion : completion ];   // End of deletion process", 
            "title": "The Code"
        }, 
        {
            "location": "/int-prod-changes/", 
            "text": "Product Changes\n\n\nIf the merchant stores the product catalogue locally, and if there was an initial synchronization of the product catalogue data, you can obtain product changes at a later date. Changed product data returned includes:\n\n\n\n\na list of products that have changed since the last synchronization date\n\n\na list of deleted products (according to their identifier)\n\n\n\n\nThe Code\n\n\nAs with product categories, products are a subset of the product catalogue, so you first need to know the unique identifier for the product catalogue. See \nMaintain Product Catalogues\n for complete information.\n\n\n\n\nNote\n\n\nOn iOS, the catalogue is identified by \nproductCatalogueId\n, whereas on Android, it is identified by \ncatalogueId\n.  \n\n\n\n\nInsert GIST here and remove Objective-C below.\n\n\n// End of product changes process\n\n\nProductCatalogueProductChangeCompletion\n \ncompletion\n \n=\n \n^\n(\nNSArray\n \nWDAcceptProductCatalogueProduct\n \n*\n*\n_Nullable\n \nupdatedProducts\n,\n\n                                                       \nNSArray\n \nNSString\n \n*\n*\n_Nullable\n \ndeletedProducts\n,\n \nNSError\n*\n \n_Nullable\n \nerror\n)\n \n{\n\n    \n//updatedProducts contains the details of all products that were updated\n\n    \n//deletedProducts contains the product IDs of deleted products - these are no longer available for sale\n\n\n};\n\n\n\n//The simplest search will just yield all reasults for the\n\n\nWDAcceptProductsQuery\n \n*\nquery\n \n=\n  \n[\nWDAcceptProductsQuery\n \nnew\n];\n//The simplest search will just yield all reasults for the product catalogue\n\n\nquery\n.\nproductCatalogueId\n \n=\n \n@\nMy Product Catalogue\n;\n \n// Your product catalogue Id\n\n\nquery\n.\ndateToLookForChanges\n \n=\n \n[\nNSDate\n \ndate\n];\n// The date since when to get the changes = the date when the client last received the inventory data\n\n\n//retrieve product changes\n\n\n[\nsdk\n.\ninventoryManager\n \nproductsChanges\n:\nquery\n \n// Query products changes\n\n                           \ncompletion\n:\ncompletion\n];\n \n// Product changes process end", 
            "title": "Product Changes"
        }, 
        {
            "location": "/int-prod-changes/#product-changes", 
            "text": "If the merchant stores the product catalogue locally, and if there was an initial synchronization of the product catalogue data, you can obtain product changes at a later date. Changed product data returned includes:   a list of products that have changed since the last synchronization date  a list of deleted products (according to their identifier)", 
            "title": "Product Changes"
        }, 
        {
            "location": "/int-prod-changes/#the-code", 
            "text": "As with product categories, products are a subset of the product catalogue, so you first need to know the unique identifier for the product catalogue. See  Maintain Product Catalogues  for complete information.   Note  On iOS, the catalogue is identified by  productCatalogueId , whereas on Android, it is identified by  catalogueId .     Insert GIST here and remove Objective-C below.  // End of product changes process  ProductCatalogueProductChangeCompletion   completion   =   ^ ( NSArray   WDAcceptProductCatalogueProduct   * * _Nullable   updatedProducts , \n                                                        NSArray   NSString   * * _Nullable   deletedProducts ,   NSError *   _Nullable   error )   { \n     //updatedProducts contains the details of all products that were updated \n     //deletedProducts contains the product IDs of deleted products - these are no longer available for sale  };  //The simplest search will just yield all reasults for the  WDAcceptProductsQuery   * query   =    [ WDAcceptProductsQuery   new ]; //The simplest search will just yield all reasults for the product catalogue  query . productCatalogueId   =   @ My Product Catalogue ;   // Your product catalogue Id  query . dateToLookForChanges   =   [ NSDate   date ]; // The date since when to get the changes = the date when the client last received the inventory data  //retrieve product changes  [ sdk . inventoryManager   productsChanges : query   // Query products changes \n                            completion : completion ];   // Product changes process end", 
            "title": "The Code"
        }, 
        {
            "location": "/int-prod-changes-images/", 
            "text": "Product Image Changes\n\n\nEach product has an associated image. In this chapter, the sample code illustrates how to retrieve either:\n\n\n\n\nall changed product images\n\n\nor an individual product image that has been changed\n\n\n\n\nTo retrieve individual product images, you need to know the unique product identifier.\n\n\nThe Code\n\n\nIf you want to select a single product image change, then you require the unique identifier for that image and you pass it in the \nproductId\n on iOS, or the \nproductExternalId\n on Android.\n\n\nAs with product categories, products are a subset of the product catalogue, so you first need to know the unique identifier for the product catalogue. See \nMaintain Product Catalogues\n for complete information.\n\n\n\n\nNote\n\n\nOn iOS, the catalogue is identified by \nproductCatalogueId\n, whereas on Android, it is identified by \ncatalogueId\n.  \n\n\n\n\nInsert GIST here and remove Objective-C below.\n\n\n//End of product images process\n\n\nProductCatalogueImageCompletion\n \ncompletion\n \n=\n \n^\n(\nNSArray\n \nWDProductImageResponse\n \n*\n*\n_Nullable\n \nproductsImage\n,\n \nNSError\n*\n \n_Nullable\n \nerror\n){\n\n    \n//List of products images objects containing the information about product Id and URL of the image for the product\n\n\n};\n\n\n\n//The simplest search will just yield all reasults for the\n\n\nWDAcceptProductsQuery\n \n*\nquery\n \n=\n  \n[\nWDAcceptProductsQuery\n \nnew\n];\n//The simplest search will just yield all reasults for the product catalogue\n\n\nquery\n.\nproductCatalogueId\n \n=\n \n@\nMy Product Catalogue\n;\n \n// Your product catalogue Id\n\n\nquery\n.\nproductId\n \n=\n \n@\nProductInternalId\n;\n \n// Product id to get the image for\n\n\n\n[\nsdk\n.\ninventoryManager\n \nproductsImage\n:\n@[\nquery\n]\n \n// Array of queries - product ids and catalogue to get the image for\n\n                         \ncompletion\n:\ncompletion\n];\n//end of Product image query\n\n\n\n//An alternative to obtain just one product image\n\n\n[\nsdk\n.\ninventoryManager\n \nproductImage\n:\nquery\n \n//Just a single query\n\n                        \ncompletion\n:\ncompletion\n];\n//end of Product image query\n\n\n\n//The two above methods do the same, the earlier one allows multiple product queries at the same time", 
            "title": "Product Images Changes"
        }, 
        {
            "location": "/int-prod-changes-images/#product-image-changes", 
            "text": "Each product has an associated image. In this chapter, the sample code illustrates how to retrieve either:   all changed product images  or an individual product image that has been changed   To retrieve individual product images, you need to know the unique product identifier.", 
            "title": "Product Image Changes"
        }, 
        {
            "location": "/int-prod-changes-images/#the-code", 
            "text": "If you want to select a single product image change, then you require the unique identifier for that image and you pass it in the  productId  on iOS, or the  productExternalId  on Android.  As with product categories, products are a subset of the product catalogue, so you first need to know the unique identifier for the product catalogue. See  Maintain Product Catalogues  for complete information.   Note  On iOS, the catalogue is identified by  productCatalogueId , whereas on Android, it is identified by  catalogueId .     Insert GIST here and remove Objective-C below.  //End of product images process  ProductCatalogueImageCompletion   completion   =   ^ ( NSArray   WDProductImageResponse   * * _Nullable   productsImage ,   NSError *   _Nullable   error ){ \n     //List of products images objects containing the information about product Id and URL of the image for the product  };  //The simplest search will just yield all reasults for the  WDAcceptProductsQuery   * query   =    [ WDAcceptProductsQuery   new ]; //The simplest search will just yield all reasults for the product catalogue  query . productCatalogueId   =   @ My Product Catalogue ;   // Your product catalogue Id  query . productId   =   @ ProductInternalId ;   // Product id to get the image for  [ sdk . inventoryManager   productsImage : @[ query ]   // Array of queries - product ids and catalogue to get the image for \n                          completion : completion ]; //end of Product image query  //An alternative to obtain just one product image  [ sdk . inventoryManager   productImage : query   //Just a single query \n                         completion : completion ]; //end of Product image query  //The two above methods do the same, the earlier one allows multiple product queries at the same time", 
            "title": "The Code"
        }, 
        {
            "location": "/int-product-stocks-erp/", 
            "text": "Product Stocks (ERP)\n\n\nIf the merchant for whom you are creating the payment acceptance app chooses ERP integration, you can use Product Stocks to retrieve stock information. Stock refers to the quantity, or total amount, of products available. For example, the stock of red roses might be 100.\n\n\n\n\nNote\n\n\nSee the \nInventory Manager Overview\n for more information about storing product data in an ERP versus storing product data locally.\n\n\n\n\nIf the merchant has more than one shop, you can retrieve information for either:\n\n\n\n\nall shops or \n\n\njust one shop \n\n\n\n\n\n\nTip\n\n\nSupport for multiple shops can be useful, for example, to build functionality to check if a product is available from another store, which is close by, if the shop that the consumer is in has run out of a certain product. \n\n\n\n\nThe Sample Code\n\n\nIf you want to retrieve product stock information for a single shop, you also need to know the unique identifier for the shop. The sample code displays only the first product that is returned. \n\n\nAs with product categories, products are a subset of the product catalogue, so you first need to know the unique identifier for the product catalogue. See \nMaintain Product Catalogues\n for complete information.\n\n\n\n\nNote\n\n\nThe Android sample code is not yet implemented.\n\n\n\n\nInsert GIST here and remove Objective-C below.\n\n\n//End of product stocks process\n\n\nProductStocksCompletion\n \ncompletion\n \n=\n \n^\n(\nNSArray\n \nWDAcceptProductStock\n \n*\n*\n_Nullable\n \nstocks\n,\n \nNSError\n*\n \n_Nullable\n \nerror\n){\n\n    \n//stocks - List of product stocks information containing the quantity and shop at which the product is available\n\n\n};\n\n\n//******************* RETRIEVE *******************//\n\n\n// GET the list of products  from this product catalogue\n\n\nWDAcceptProductsQuery\n \n*\nquery\n \n=\n  \n[\nWDAcceptProductsQuery\n \nnew\n];\n//The simplest search will just yield all reasults for the product catalogue\n\n\nquery\n.\nproductCatalogueId\n \n=\n \n@\nMy Product Catalogue\n;\n \n// Your product catalogue Id\n\n\n\n[\nsdk\n.\ninventoryManager\n \nproducts\n:\nquery\n \n// Query attributes\n\n                 \nuncategorized\n:\nYES\n \n// Return also products which are not assigned to any category\n\n                    \ncompletion\n:\n^\n(\nNSArray\nWDAcceptProductCatalogueProduct\n \n*\n \n*\n \n_Nullable\n \nproducts\n,\n \nNSError\n \n*\n \n_Nullable\n \nerror\n)\n \n{\n\n                        \n[\nsdk\n.\ninventoryManager\n \nproductsStock\n:\n@[\n[\nproducts\n \nfirstObject\n]\n \n]\n \n// For simplicity we just use one (first) object from the product query - we assume at least one is returned\n\n                                                     \ninShop\n:\n@\nShopId\n \n// Internal ID of the Shop - optional, will check all shops stocks if not specified\n\n                                                 \ncompletion\n:\ncompletion\n];\n \n//End of product stock process\n\n                    \n}];\n//End of query process", 
            "title": "Product Stocks (ERP)"
        }, 
        {
            "location": "/int-product-stocks-erp/#product-stocks-erp", 
            "text": "If the merchant for whom you are creating the payment acceptance app chooses ERP integration, you can use Product Stocks to retrieve stock information. Stock refers to the quantity, or total amount, of products available. For example, the stock of red roses might be 100.   Note  See the  Inventory Manager Overview  for more information about storing product data in an ERP versus storing product data locally.   If the merchant has more than one shop, you can retrieve information for either:   all shops or   just one shop     Tip  Support for multiple shops can be useful, for example, to build functionality to check if a product is available from another store, which is close by, if the shop that the consumer is in has run out of a certain product.", 
            "title": "Product Stocks (ERP)"
        }, 
        {
            "location": "/int-product-stocks-erp/#the-sample-code", 
            "text": "If you want to retrieve product stock information for a single shop, you also need to know the unique identifier for the shop. The sample code displays only the first product that is returned.   As with product categories, products are a subset of the product catalogue, so you first need to know the unique identifier for the product catalogue. See  Maintain Product Catalogues  for complete information.   Note  The Android sample code is not yet implemented.   Insert GIST here and remove Objective-C below.  //End of product stocks process  ProductStocksCompletion   completion   =   ^ ( NSArray   WDAcceptProductStock   * * _Nullable   stocks ,   NSError *   _Nullable   error ){ \n     //stocks - List of product stocks information containing the quantity and shop at which the product is available  };  //******************* RETRIEVE *******************//  // GET the list of products  from this product catalogue  WDAcceptProductsQuery   * query   =    [ WDAcceptProductsQuery   new ]; //The simplest search will just yield all reasults for the product catalogue  query . productCatalogueId   =   @ My Product Catalogue ;   // Your product catalogue Id  [ sdk . inventoryManager   products : query   // Query attributes \n                  uncategorized : YES   // Return also products which are not assigned to any category \n                     completion : ^ ( NSArray WDAcceptProductCatalogueProduct   *   *   _Nullable   products ,   NSError   *   _Nullable   error )   { \n                         [ sdk . inventoryManager   productsStock : @[ [ products   firstObject ]   ]   // For simplicity we just use one (first) object from the product query - we assume at least one is returned \n                                                      inShop : @ ShopId   // Internal ID of the Shop - optional, will check all shops stocks if not specified \n                                                  completion : completion ];   //End of product stock process \n                     }]; //End of query process", 
            "title": "The Sample Code"
        }, 
        {
            "location": "/int-product-prices-erp/", 
            "text": "Product Prices (ERP)\n\n\nIf the merchant has defined customer information (i.e., member information) in their ERP, you can obtain the adjusted price for the member before check out. This allows for any discounts or promotions to be applied to the price before the sale is completed. \n\n\nThe Sample Code\n\n\nThe unique identifier for both the member and each Product is required.  You can validate the unique identifier for the member using the Customer Manager, as described in \nCustomer Manager\n.\n\n\n\n\nNote\n\n\nThe Android sample code is not yet implemented.\n\n\n\n\nInsert GIST here and remove Objective-C below.\n\n\n//End of Product Prices process\n\n\nProductPricesCompletion\n \ncompletion\n \n=\n \n^\n(\nNSArray\n \nWDAcceptProductPrice\n \n*\n*\n_Nullable\n \nproductPrices\n,\n \nNSError\n*\n \n_Nullable\n \nerror\n){\n\n    \n//productPrices - list of product prices as known by ERP for the Customer\n\n\n};\n\n\n\n// Get the adjusted product prices for the customer - e.g. The merchant has their Members base defined in ERP (SAP by Design)\n\n\n// and have specified discounted prices for each Member.\n\n\n// It is possible then to request the adjusted prices for the Member known by ERP Customer ID\n\n\n[\nsdk\n.\ninventoryManager\n \nproductPriceForMember\n:\n@\nERP Member ID\n \n// Member ID as known by ERP (SAP by Design Customer ID)\n\n                                  \nexternalIDs\n:\n@[\n@\nERP Product ID 1\n,\n@\nERP Product ID 1\n]\n \n// List of Products IDs to get the prices for\n\n                                     \ncurrency\n:\n@\nEUR\n \n// Currency in which the prices are defined\n\n                                   \ngrossPrice\n:\nYES\n \n// Gross unit price should be returned - Net unit price if NO\n\n                                   \ncompletion\n:\ncompletion\n];\n \n// End of product prices", 
            "title": "Product Prices (ERP)"
        }, 
        {
            "location": "/int-product-prices-erp/#product-prices-erp", 
            "text": "If the merchant has defined customer information (i.e., member information) in their ERP, you can obtain the adjusted price for the member before check out. This allows for any discounts or promotions to be applied to the price before the sale is completed.", 
            "title": "Product Prices (ERP)"
        }, 
        {
            "location": "/int-product-prices-erp/#the-sample-code", 
            "text": "The unique identifier for both the member and each Product is required.  You can validate the unique identifier for the member using the Customer Manager, as described in  Customer Manager .   Note  The Android sample code is not yet implemented.   Insert GIST here and remove Objective-C below.  //End of Product Prices process  ProductPricesCompletion   completion   =   ^ ( NSArray   WDAcceptProductPrice   * * _Nullable   productPrices ,   NSError *   _Nullable   error ){ \n     //productPrices - list of product prices as known by ERP for the Customer  };  // Get the adjusted product prices for the customer - e.g. The merchant has their Members base defined in ERP (SAP by Design)  // and have specified discounted prices for each Member.  // It is possible then to request the adjusted prices for the Member known by ERP Customer ID  [ sdk . inventoryManager   productPriceForMember : @ ERP Member ID   // Member ID as known by ERP (SAP by Design Customer ID) \n                                   externalIDs : @[ @ ERP Product ID 1 , @ ERP Product ID 1 ]   // List of Products IDs to get the prices for \n                                      currency : @ EUR   // Currency in which the prices are defined \n                                    grossPrice : YES   // Gross unit price should be returned - Net unit price if NO \n                                    completion : completion ];   // End of product prices", 
            "title": "The Sample Code"
        }, 
        {
            "location": "/int-terminal-overview/", 
            "text": "Terminal Manager Overview\n\n\nThis section shows you how to use the Terminal Manager component which is one of four hardware-related components. Specifically it describes how to:\n\n\n\n\ndiscover devices\n\n\nupdate firmware\n\n\ncheck for available devices", 
            "title": "Terminal Manager Overview"
        }, 
        {
            "location": "/int-terminal-overview/#terminal-manager-overview", 
            "text": "This section shows you how to use the Terminal Manager component which is one of four hardware-related components. Specifically it describes how to:   discover devices  update firmware  check for available devices", 
            "title": "Terminal Manager Overview"
        }, 
        {
            "location": "/int-terminal-discovery/", 
            "text": "Terminal Discovery\n\n\nThe discoverDevices method of Terminal Manager handles discovery of all paired and connected Posmate terminals. Spire manufactures the following terminals:\n\n\n\n\nPosmate\n\n\nSPm2\n\n\nSpm20\n\n\n\n\nAll three of these terminals are served by the PosMateExtension.\n\n\nThe User Interface\n\n\nA typical user interface might look like this:\n\n\n\n\nThe Sample Code\n\n\nInsert GIST here and remove Objective-C below.\n\n\n// The SDK is initialized as shared instance so can be accessed\n\n\n// from multiple View Controllers\n\n\nAcceptSDK\n \n*\nsdk\n \n=\n \n[\nAcceptSDK\n \nsharedInstance\n];\n\n\n\n// Set the SDK target environment - in this case Public Test\n\n\n// and the username and password to authenticate to it\n\n\n[\nsdk\n \nsetupWithEnvironment\n:\nAcceptEnvironmentPublicTest\n\n                 \nusername\n:\n@\nyourUsername\n\n                 \npassword\n:\n@\nyourPassword\n];\n\n\n\n// Define the array to hold the list of paired and connected BT terminals\n\n\n__block\n \nNSArray\n*\n \nreturnedTerminalsArr\n;\n\n\n\n// Completion from the Terminal Discovery API\n\n\nDeviceDiscoveryCompletion\n \ncompletionTerminals\n \n=\n \n^\n(\nNSArray\n \n*\narr\n,\n \nNSError\n \n*\nerr\n)\n \n{\n\n    \nreturnedTerminalsArr\n \n=\n \narr\n;\n\n\n\n};\n\n\n\n// Discover all paired and connected Posmate terminals - Spire is producing Posmate | SPm2 | Spm20 which are all served by PosMateExtension\n\n\n[\nsdk\n.\nterminalManager\n \ndiscoverDevices\n:\nPosMateExtensionUUID\n \n// Vendor UUID - Spire terminals have the UUID of PosMateExtensionUUID\n\n                          \ncompletion\n:\ncompletionTerminals\n \n// completion to be executed at the end of discovery method\n\n \n];", 
            "title": "Terminal Discovery"
        }, 
        {
            "location": "/int-terminal-discovery/#terminal-discovery", 
            "text": "The discoverDevices method of Terminal Manager handles discovery of all paired and connected Posmate terminals. Spire manufactures the following terminals:   Posmate  SPm2  Spm20   All three of these terminals are served by the PosMateExtension.", 
            "title": "Terminal Discovery"
        }, 
        {
            "location": "/int-terminal-discovery/#the-user-interface", 
            "text": "A typical user interface might look like this:", 
            "title": "The User Interface"
        }, 
        {
            "location": "/int-terminal-discovery/#the-sample-code", 
            "text": "Insert GIST here and remove Objective-C below.  // The SDK is initialized as shared instance so can be accessed  // from multiple View Controllers  AcceptSDK   * sdk   =   [ AcceptSDK   sharedInstance ];  // Set the SDK target environment - in this case Public Test  // and the username and password to authenticate to it  [ sdk   setupWithEnvironment : AcceptEnvironmentPublicTest \n                  username : @ yourUsername \n                  password : @ yourPassword ];  // Define the array to hold the list of paired and connected BT terminals  __block   NSArray *   returnedTerminalsArr ;  // Completion from the Terminal Discovery API  DeviceDiscoveryCompletion   completionTerminals   =   ^ ( NSArray   * arr ,   NSError   * err )   { \n     returnedTerminalsArr   =   arr ;  };  // Discover all paired and connected Posmate terminals - Spire is producing Posmate | SPm2 | Spm20 which are all served by PosMateExtension  [ sdk . terminalManager   discoverDevices : PosMateExtensionUUID   // Vendor UUID - Spire terminals have the UUID of PosMateExtensionUUID \n                           completion : completionTerminals   // completion to be executed at the end of discovery method \n  ];", 
            "title": "The Sample Code"
        }, 
        {
            "location": "/int-terminal-update/", 
            "text": "Update Firmware\n\n\nCard acceptance is heavily reliant on the terminals that the merchant users use, so it is a good idea to provide functionality that lets them update their firmware on a regular basis, as demonstrated by the sample code in this chapter.\n\n\n\n\nTip\n\n\nYou can check if any updates are available with the \nCheck Available Updates\n sample code. \n\n\n\n\nThe User Interface\n\n\nA typical interface might look like this:\n\n\n\n\nThe Sample Code\n\n\nIn the sample code, all Miura terminals are discovered and then the first one is updated. Both the firmware and payment application are updated. \n\n\n    \n// Updates from Terminal Update\n\n    \nUpdateConfigurationProgress\n \nprogress\n \n=\n \n^\n(\nAcceptUpdateConfigurationProgressUpdate\n \nprogressUpdate\n){\n\n        \n// progressUpdate - coded statuses are reported throughout the Terminal Update flow\n\n    \n};\n\n\n    \n// The end of terminal update process\n\n    \nUpdateTerminalCompletion\n \ncompletion\n \n=\n \n^\n(\nAcceptUpdateConfigurationStatus\n \nupdateStatus\n,\n \nNSError\n \n*\nupdateError\n){\n\n        \n// updateStatus - coded final status of the update process\n\n        \n// updateError - error encountered during the terminal update process\n\n    \n};\n\n\n    \n// Discover active terminals and use it - in this case we use the first one\n\n    \n// Alternatively use the one discovered previously and stored in an instance variable (or user preferences)\n\n    \n[\nsdk\n.\nterminalManager\n \ndiscoverDevices\n:\nWDAMiuraExtensionUUID\n \n// Discover all active Miura terminals\n\n                              \ncompletion\n:\n^\n(\nNSArray\nWDAcceptTerminal\n \n*\n \n*\n \n_Nullable\n \nterminals\n,\n \nNSError\n \n*\n \n_Nullable\n \ndevicesError\n){\n\n\n        \n// Perform the terminal update\n\n        \n[\nsdk\n.\nterminalManager\n \nupdate\n:[\nterminals\n \nfirstObject\n]\n \n// For simplicity we are selecting the first active terminal from the list of discovered terminals\n\n                         \nupdateType\n:\nAcceptTerminalUpdateTypeMaskSoftware\n \n// We opt to update the terminal Firmware and Payment application - alternatives are Config | Application | Firmware | CA Keys\n\n                           \nprogress\n:\nprogress\n \n// Progress Update from the terminal update\n\n                         \ncompletion\n:\ncompletion\n];\n \n// End if terminal update process\n\n                              \n}];", 
            "title": "Update Firmware"
        }, 
        {
            "location": "/int-terminal-update/#update-firmware", 
            "text": "Card acceptance is heavily reliant on the terminals that the merchant users use, so it is a good idea to provide functionality that lets them update their firmware on a regular basis, as demonstrated by the sample code in this chapter.   Tip  You can check if any updates are available with the  Check Available Updates  sample code.", 
            "title": "Update Firmware"
        }, 
        {
            "location": "/int-terminal-update/#the-user-interface", 
            "text": "A typical interface might look like this:", 
            "title": "The User Interface"
        }, 
        {
            "location": "/int-terminal-update/#the-sample-code", 
            "text": "In the sample code, all Miura terminals are discovered and then the first one is updated. Both the firmware and payment application are updated.        // Updates from Terminal Update \n     UpdateConfigurationProgress   progress   =   ^ ( AcceptUpdateConfigurationProgressUpdate   progressUpdate ){ \n         // progressUpdate - coded statuses are reported throughout the Terminal Update flow \n     }; \n\n     // The end of terminal update process \n     UpdateTerminalCompletion   completion   =   ^ ( AcceptUpdateConfigurationStatus   updateStatus ,   NSError   * updateError ){ \n         // updateStatus - coded final status of the update process \n         // updateError - error encountered during the terminal update process \n     }; \n\n     // Discover active terminals and use it - in this case we use the first one \n     // Alternatively use the one discovered previously and stored in an instance variable (or user preferences) \n     [ sdk . terminalManager   discoverDevices : WDAMiuraExtensionUUID   // Discover all active Miura terminals \n                               completion : ^ ( NSArray WDAcceptTerminal   *   *   _Nullable   terminals ,   NSError   *   _Nullable   devicesError ){ \n\n         // Perform the terminal update \n         [ sdk . terminalManager   update :[ terminals   firstObject ]   // For simplicity we are selecting the first active terminal from the list of discovered terminals \n                          updateType : AcceptTerminalUpdateTypeMaskSoftware   // We opt to update the terminal Firmware and Payment application - alternatives are Config | Application | Firmware | CA Keys \n                            progress : progress   // Progress Update from the terminal update \n                          completion : completion ];   // End if terminal update process \n                               }];", 
            "title": "The Sample Code"
        }, 
        {
            "location": "/int-terminal-avail/", 
            "text": "Check Available Updates\n\n\nYou can check for available updates before performing an \nUpdate Firmware\n. This sample code discovers connected devices and for the first one found, checks for any available updates.\n\n\nTypically, you should provide the user with an information notice and option to update if there is new firmware available.\n\n\nThe Code\n\n\nInsert GIST here and remove Objective-C below.\n\n\n//End of available updates check\n\n\nTerminalUpdatesCompletion\n \ncompletion\n \n=\n \n^\n(\nWDAcceptTerminalUpdates\n \n*\n_Nullable\n \navailableUpdates\n,\n \nNSError\n*\n \n_Nullable\n \navailableUpdatesError\n){\n\n    \n// availableUpdates - contains the details about available Configuration | Application | Firmware for the selected terminal\n\n    \n// WDAcceptTerminalUpdate contains details for Configuration | Application | Firmware update\n\n    \n//   .severity mandates the use/installation of the update to the terminal - please consult AcceptUpdateSeverity for details\n\n    \n//   .version available on the backend\n\n    \n//   .downloadUrl to obtain the update archive from\n\n\n};\n\n\n\n// Discover active terminals\n\n\n[\nsdk\n.\nterminalManager\n \ndiscoverDevices\n:\nWDAPosMateExtensionUUID\n\n                          \ncompletion\n:\n^\n(\nNSArray\nWDAcceptTerminal\n \n*\n \n*\n \n_Nullable\n \nterminals\n,\n \nNSError\n \n*\n \n_Nullable\n \ndevicesError\n)\n\n \n{\n\n     \n//set active terminal for which to check available updates\n\n     \n[\nsdk\n.\nterminalManager\n \nsetActive\n:[\nterminals\n \nfirstObject\n]\n \n// For simplicity we use the first active terminal to check the available updates for\n\n                    \ncompletion\n:\n^\n{\n\n                        \n// Check if there are any updates for the active terminal\n\n                        \n[\nsdk\n.\nterminalManager\n \navailableUpdates\n:\ncompletion\n];\n// End of available updates call\n\n                    \n}];\n\n \n}];", 
            "title": "Check Available Updates"
        }, 
        {
            "location": "/int-terminal-avail/#check-available-updates", 
            "text": "You can check for available updates before performing an  Update Firmware . This sample code discovers connected devices and for the first one found, checks for any available updates.  Typically, you should provide the user with an information notice and option to update if there is new firmware available.", 
            "title": "Check Available Updates"
        }, 
        {
            "location": "/int-terminal-avail/#the-code", 
            "text": "Insert GIST here and remove Objective-C below.  //End of available updates check  TerminalUpdatesCompletion   completion   =   ^ ( WDAcceptTerminalUpdates   * _Nullable   availableUpdates ,   NSError *   _Nullable   availableUpdatesError ){ \n     // availableUpdates - contains the details about available Configuration | Application | Firmware for the selected terminal \n     // WDAcceptTerminalUpdate contains details for Configuration | Application | Firmware update \n     //   .severity mandates the use/installation of the update to the terminal - please consult AcceptUpdateSeverity for details \n     //   .version available on the backend \n     //   .downloadUrl to obtain the update archive from  };  // Discover active terminals  [ sdk . terminalManager   discoverDevices : WDAPosMateExtensionUUID \n                           completion : ^ ( NSArray WDAcceptTerminal   *   *   _Nullable   terminals ,   NSError   *   _Nullable   devicesError ) \n  { \n      //set active terminal for which to check available updates \n      [ sdk . terminalManager   setActive :[ terminals   firstObject ]   // For simplicity we use the first active terminal to check the available updates for \n                     completion : ^ { \n                         // Check if there are any updates for the active terminal \n                         [ sdk . terminalManager   availableUpdates : completion ]; // End of available updates call \n                     }]; \n  }];", 
            "title": "The Code"
        }, 
        {
            "location": "/int-cashdrawer-overview/", 
            "text": "Cash Drawer Manager Overview\n\n\nThis section shows you how to use the Cash Drawer Manager component, which is one of four hardware-related components. Specifically, the sample code demonstrates how to:\n\n\n\n\ndiscover paired cash drawers\n\n\nopen cash drawers\n\n\nconnect to Bluetooth cash drawers and check their status", 
            "title": "Cash Drawer Overview"
        }, 
        {
            "location": "/int-cashdrawer-overview/#cash-drawer-manager-overview", 
            "text": "This section shows you how to use the Cash Drawer Manager component, which is one of four hardware-related components. Specifically, the sample code demonstrates how to:   discover paired cash drawers  open cash drawers  connect to Bluetooth cash drawers and check their status", 
            "title": "Cash Drawer Manager Overview"
        }, 
        {
            "location": "/int-cashdrawer-discovery/", 
            "text": "Cash Drawer Discovery\n\n\nThe device discovery functionality of Cash Drawer Manager:\n\n\n\n\ndiscovers any connected Star Micronics or other cash drawer devices\n\n\nregisters to receive device status updates\n\n\nregisters to receive action result updates\n\n\nhandles the reception of notifications related to:\n\n\nconnection status\n\n\nbattery levels\n\n\n\n\n\n\n\n\nSo, related to the last point above, there are two main tasks for you:\n\n\n\n\nimplement the \nconnectionStatusDidChange\n\n\nimplement the \nbatteryLevelDidChange\n\n\n\n\nThe User Interface\n\n\nA typical user interface might look like this:\n\n\n\n\nThe Sample Code\n\n\nFor simplicity, the sample code utilizes the first cash drawer that is found, however, if necessary you can handle this in a more sophisticated way and deal with more than one scanner.\n\n\n\n\nNote\n\n\nThe Android sample code is not yet implemented.\n\n\n\n\nInsert GIST here and remove Objective-C below.\n\n\n//Discover active devices\n\n\n[[\nsdk\n \ncashDrawerManager\n]\n \ndiscoverDevices\n:\nWDAStarMicronicsExtensionUUID\n \n//Get the active Cash Drawer\n\n                           \ncompletion\n:\n^\n(\nNSArray\n \nWDAcceptTerminal\n \n*\n*\n \n_Nullable\n \ndevices\n,\n \nNSError\n*\n \n_Nullable\n \ndevicesError\n){\n\n                               \n//Register for updates on device statuses and action results\n\n                               \n//Add Cash drawer delegate to receive the notifications about connection status and battery levels\n\n                               \n//Implement the methods: -(void)gistdevice:(WDAcceptTerminal*)device connectionStatusDidChange:(AcceptExtensionConnectionStatus)connectionsStatus\n\n                               \n//                      -(void)device:(WDAcceptTerminal*)device batteryLevelDidChange:(NSInteger)batteryLevel\n\n                               \n[[\nsdk\n \ncashDrawerManager\n]\n \naddManagerDelegate\n:\nself\n\n                                                                      \nforDevice\n:[\ndevices\n \nfirstObject\n]];\n//for simplicity we use the first active Cash Drawer\n\n                           \n}];", 
            "title": "Cash Drawer Discovery"
        }, 
        {
            "location": "/int-cashdrawer-discovery/#cash-drawer-discovery", 
            "text": "The device discovery functionality of Cash Drawer Manager:   discovers any connected Star Micronics or other cash drawer devices  registers to receive device status updates  registers to receive action result updates  handles the reception of notifications related to:  connection status  battery levels     So, related to the last point above, there are two main tasks for you:   implement the  connectionStatusDidChange  implement the  batteryLevelDidChange", 
            "title": "Cash Drawer Discovery"
        }, 
        {
            "location": "/int-cashdrawer-discovery/#the-user-interface", 
            "text": "A typical user interface might look like this:", 
            "title": "The User Interface"
        }, 
        {
            "location": "/int-cashdrawer-discovery/#the-sample-code", 
            "text": "For simplicity, the sample code utilizes the first cash drawer that is found, however, if necessary you can handle this in a more sophisticated way and deal with more than one scanner.   Note  The Android sample code is not yet implemented.   Insert GIST here and remove Objective-C below.  //Discover active devices  [[ sdk   cashDrawerManager ]   discoverDevices : WDAStarMicronicsExtensionUUID   //Get the active Cash Drawer \n                            completion : ^ ( NSArray   WDAcceptTerminal   * *   _Nullable   devices ,   NSError *   _Nullable   devicesError ){ \n                                //Register for updates on device statuses and action results \n                                //Add Cash drawer delegate to receive the notifications about connection status and battery levels \n                                //Implement the methods: -(void)gistdevice:(WDAcceptTerminal*)device connectionStatusDidChange:(AcceptExtensionConnectionStatus)connectionsStatus \n                                //                      -(void)device:(WDAcceptTerminal*)device batteryLevelDidChange:(NSInteger)batteryLevel \n                                [[ sdk   cashDrawerManager ]   addManagerDelegate : self \n                                                                       forDevice :[ devices   firstObject ]]; //for simplicity we use the first active Cash Drawer \n                            }];", 
            "title": "The Sample Code"
        }, 
        {
            "location": "/int-cashdrawer-open/", 
            "text": "Open Cash Drawer\n\n\nThe sample code in this chapter builds on the code in the \nprevious chapter\n by opening a cash drawer device after it is discovered. Opening of the cash drawer is required when the user needs to physically insert or withdraw bank notes or coins. \n\n\nThe Sample Code\n\n\n\n\nNote\n\n\nThe Android sample code is not yet implemented.\n\n\n\n\nInsert GIST here and remove Objective-C below.\n\n\n//End of device command process\n\n\nExtensionCommandCompletion\n \ncompletion\n \n=\n \n^\n(\nBOOL\n \ncommandCompletionStatus\n,\n  \nNSError\n \n*\n \n_Nullable\n \nerror\n){\n\n    \n//commandCompletionStatus - true if command successfull\n\n\n};\n\n\n\n//Discover active devices\n\n\n[[\nsdk\n \ncashDrawerManager\n]\n \ndiscoverDevices\n:\nWDAMPOPExtensionUUID\n \n//Get the active mPOP cash drawer\n\n                           \ncompletion\n:\n^\n(\nNSArray\n \nWDAcceptTerminal\n \n*\n*\n \n_Nullable\n \ndevices\n,\n \nNSError\n*\n \n_Nullable\n \ndevicesError\n){\n\n\n                               \n//Open the Cash Drawer - to physically insert or withdraw bank notes or coins from the drawer\n\n                               \n[\nsdk\n.\ncashDrawerManager\n \nopenCashDrawer\n:[\ndevices\n \nfirstObject\n]\n \n//for simplicity we use the first active Cash Drawer\n\n                                                          \ncompletion\n:\ncompletion\n];\n//End of device command process\n\n\n                           \n}];", 
            "title": "Open Cash Drawer"
        }, 
        {
            "location": "/int-cashdrawer-open/#open-cash-drawer", 
            "text": "The sample code in this chapter builds on the code in the  previous chapter  by opening a cash drawer device after it is discovered. Opening of the cash drawer is required when the user needs to physically insert or withdraw bank notes or coins.", 
            "title": "Open Cash Drawer"
        }, 
        {
            "location": "/int-cashdrawer-open/#the-sample-code", 
            "text": "Note  The Android sample code is not yet implemented.   Insert GIST here and remove Objective-C below.  //End of device command process  ExtensionCommandCompletion   completion   =   ^ ( BOOL   commandCompletionStatus ,    NSError   *   _Nullable   error ){ \n     //commandCompletionStatus - true if command successfull  };  //Discover active devices  [[ sdk   cashDrawerManager ]   discoverDevices : WDAMPOPExtensionUUID   //Get the active mPOP cash drawer \n                            completion : ^ ( NSArray   WDAcceptTerminal   * *   _Nullable   devices ,   NSError *   _Nullable   devicesError ){ \n\n                                //Open the Cash Drawer - to physically insert or withdraw bank notes or coins from the drawer \n                                [ sdk . cashDrawerManager   openCashDrawer :[ devices   firstObject ]   //for simplicity we use the first active Cash Drawer \n                                                           completion : completion ]; //End of device command process \n\n                            }];", 
            "title": "The Sample Code"
        }, 
        {
            "location": "/int-cashdrawer-connect/", 
            "text": "Check Connection Status\n\n\nThe connection status of a Bluetooth-connected cash drawer can be reported, as shown in the sample code.\n\n\nThe Sample Code\n\n\n\n\nNote\n\n\nThe Android sample code is not yet implemented.\n\n\n\n\nInsert GIST here and remove Objective-C below.\n\n\n//The base class needs to conform to WDAcceptManagerDelegate\n\n\n//Discover active devices\n\n\n[[\nsdk\n \ncashDrawerManager\n]\n \ndiscoverDevices\n:\nWDAStarMicronicsExtensionUUID\n \n//Get the active Cash Drawer\n\n                           \ncompletion\n:\n^\n(\nNSArray\n \nWDAcceptTerminal\n \n*\n*\n \n_Nullable\n \ndevices\n,\n \nNSError\n*\n \n_Nullable\n \ndevicesError\n){\n\n                               \n//Register for updates on device statuses and action results\n\n                               \n//Add Cash drawer delegate to receive the notifications about connection status\n\n                               \n//Implement the methods: -(void)device:(WDAcceptTerminal*)device connectionStatusDidChange:(AcceptExtensionConnectionStatus)connectionsStatus\n\n                               \n[[\nsdk\n \ncashDrawerManager\n]\n \naddManagerDelegate\n:\nself\n\n                                                                      \nforDevice\n:[\ndevices\n \nfirstObject\n]];\n//for simplicity we use the first active Cash Drawer\n\n                           \n}];", 
            "title": "Check Connection Status"
        }, 
        {
            "location": "/int-cashdrawer-connect/#check-connection-status", 
            "text": "The connection status of a Bluetooth-connected cash drawer can be reported, as shown in the sample code.", 
            "title": "Check Connection Status"
        }, 
        {
            "location": "/int-cashdrawer-connect/#the-sample-code", 
            "text": "Note  The Android sample code is not yet implemented.   Insert GIST here and remove Objective-C below.  //The base class needs to conform to WDAcceptManagerDelegate  //Discover active devices  [[ sdk   cashDrawerManager ]   discoverDevices : WDAStarMicronicsExtensionUUID   //Get the active Cash Drawer \n                            completion : ^ ( NSArray   WDAcceptTerminal   * *   _Nullable   devices ,   NSError *   _Nullable   devicesError ){ \n                                //Register for updates on device statuses and action results \n                                //Add Cash drawer delegate to receive the notifications about connection status \n                                //Implement the methods: -(void)device:(WDAcceptTerminal*)device connectionStatusDidChange:(AcceptExtensionConnectionStatus)connectionsStatus \n                                [[ sdk   cashDrawerManager ]   addManagerDelegate : self \n                                                                       forDevice :[ devices   firstObject ]]; //for simplicity we use the first active Cash Drawer \n                            }];", 
            "title": "The Sample Code"
        }, 
        {
            "location": "/int-printer-overview/", 
            "text": "Printer Manager Overview\n\n\nThis section shows you how to use the Printer Manager component, which is one of four hardware-related components. Specifically, the sample code demonstrates how to:\n\n\n\n\ndiscover printers\n\n\nprint a single receipt or a collection of receipts\n\n\ncheck the paper status of a printer", 
            "title": "Printer Manager Overview"
        }, 
        {
            "location": "/int-printer-overview/#printer-manager-overview", 
            "text": "This section shows you how to use the Printer Manager component, which is one of four hardware-related components. Specifically, the sample code demonstrates how to:   discover printers  print a single receipt or a collection of receipts  check the paper status of a printer", 
            "title": "Printer Manager Overview"
        }, 
        {
            "location": "/int-printer-discovery/", 
            "text": "Printer Discovery\n\n\nThe discover devices functionality of Printer Manager:\n\n\n\n\ndiscovers any connected Datecs DPP-250 handheld printers\n\n\nregisters to receive device status updates\n\n\nregisters to receive action result updates\n\n\nprepares Printer Manager for the reception of the data after a barcode is scanned\n\n\n\n\nSo, related to the last point above, the main task for you is to implement a method that handles the \ndataReceived\n. \n\n\nThe User Interface\n\n\nA typical user interface might look like this:\n\n\n\n\nThe Sample Code\n\n\nFor simplicity, the sample code utilizes the first printer that is found, however, if necessary you can handle this in a more sophisticated way and deal with more than one printer.\n\n\n\n\nWarning\n\n\nIn the iOS code, the base class needs to conform to \nWDAcceptPrinting\n. \n\n\n\n\nInsert GIST here and remove Objective-C below.\n\n\n//Discover active devices\n\n\n[[\nsdk\n \nprinterManager\n]\n \ndiscoverDevices\n:\nWDADatecsPrinterExtensionUUID\n \n//Get the active Datecs DPP-250 handheld printer\n\n                           \ncompletion\n:\n^\n(\nNSArray\n \nWDAcceptTerminal\n \n*\n*\n \n_Nullable\n \ndevices\n,\n \nNSError\n*\n \n_Nullable\n \ndevicesError\n){\n\n                               \n//Register for updates on device statuses and action results\n\n                               \n//Add Printer delegate to receive notifications about the paper status\n\n                               \n//Implement the method: -(void)device:(WDAcceptTerminal*)device paperStatusUpdated:(AcceptPrinterPaperStatus)status\n\n                               \n[[\nsdk\n \nprinterManager\n]\n \naddPrinterManagerDelegate\n:\nself\n\n                                                             \nforPrinter\n:[\ndevices\n \nfirstObject\n]];\n//for simplicity we use the first active DPP-250\n\n                           \n}];", 
            "title": "Printer Discovery"
        }, 
        {
            "location": "/int-printer-discovery/#printer-discovery", 
            "text": "The discover devices functionality of Printer Manager:   discovers any connected Datecs DPP-250 handheld printers  registers to receive device status updates  registers to receive action result updates  prepares Printer Manager for the reception of the data after a barcode is scanned   So, related to the last point above, the main task for you is to implement a method that handles the  dataReceived .", 
            "title": "Printer Discovery"
        }, 
        {
            "location": "/int-printer-discovery/#the-user-interface", 
            "text": "A typical user interface might look like this:", 
            "title": "The User Interface"
        }, 
        {
            "location": "/int-printer-discovery/#the-sample-code", 
            "text": "For simplicity, the sample code utilizes the first printer that is found, however, if necessary you can handle this in a more sophisticated way and deal with more than one printer.   Warning  In the iOS code, the base class needs to conform to  WDAcceptPrinting .    Insert GIST here and remove Objective-C below.  //Discover active devices  [[ sdk   printerManager ]   discoverDevices : WDADatecsPrinterExtensionUUID   //Get the active Datecs DPP-250 handheld printer \n                            completion : ^ ( NSArray   WDAcceptTerminal   * *   _Nullable   devices ,   NSError *   _Nullable   devicesError ){ \n                                //Register for updates on device statuses and action results \n                                //Add Printer delegate to receive notifications about the paper status \n                                //Implement the method: -(void)device:(WDAcceptTerminal*)device paperStatusUpdated:(AcceptPrinterPaperStatus)status \n                                [[ sdk   printerManager ]   addPrinterManagerDelegate : self \n                                                              forPrinter :[ devices   firstObject ]]; //for simplicity we use the first active DPP-250 \n                            }];", 
            "title": "The Sample Code"
        }, 
        {
            "location": "/int-print/", 
            "text": "Print Receipt\n\n\nThe \nprevious chapter\n examined a simple device discovery for a printer that is paired. This chapter builds on that with more sophisticated receipt printing functionality, including:\n\n\n\n\nreporting on the status of a print job\n\n\nreporting on the final status of a print job\n\n\n\n\nAccept Receipt and UIImage\n\n\nAs the code comments indicate, the Accept Receipt object tends to print quicker than the UIImage (which is a bitmap) so the sample code shown here prints an AcceptReceipt object. The \nnext chapter\n demonstrates how to handle printing of a UIImage. \n\n\nThe input for a receipt can either be:\n\n\n\n\na Sale Response object from the payment method of Sales Manager\n\n\na Query object from the Sales Manager\n\n\n\n\nThe sample code uses a Sale Response because this is the usual type of information that you will want to print in a receipt.\n\n\nA single receipt, or a collection of receipts, can be printed. \n\n\nThe Sample Code\n\n\nAs is the case with much of the sample code in GIST, we start with the first printer object that is found. \n\n\n//End of printing process\n\n\nPrintCompletion\n \ncompletion\n \n=\n \n^\n(\nBOOL\n \nprintStatusOK\n,\n \nNSError\n*\n \n_Nullable\n \nprintError\n){\n\n    \n//printStatusOK is true if printing ended with OK status\n\n\n};\n\n\n\nPrinterStateUpdate\n \nprogress\n \n=\n \n^\n(\nAcceptPrinterStateUpdate\n \nprintProgress\n){\n\n    \n//printProgress - print progress Initialisation | Printing | Finished\n\n\n};\n\n\n\n//Discover active devices\n\n\n[[\nsdk\n \nprinterManager\n]\n \ndiscoverDevices\n:\nWDADatecsPrinterExtensionUUID\n \n//Get the active Datecs DPP-250 handheld printer\n\n                           \ncompletion\n:\n^\n(\nNSArray\n \nWDAcceptTerminal\n \n*\n*\n \n_Nullable\n \ndevices\n,\n \nNSError\n*\n \n_Nullable\n \ndevicesError\n){\n\n                               \n//Register for updates on device statuses and action results\n\n                               \n//Add Printer delegate to receive notifications about the paper status\n\n                               \n//Implement the method: -(void)device:(WDAcceptTerminal*)device paperStatusUpdated:(AcceptPrinterPaperStatus)status\n\n                               \nWDAcceptPrinterConfig\n \n*\nprintConfig\n \n=\n \n[\nWDAcceptPrinterConfig\n \nnew\n];\n\n\n                               \nprintConfig\n.\nprinter\n \n=\n \n[\ndevices\n \nfirstObject\n];\n \n//for simplicity we use the first active Printer\n\n                               \n//Datecs Printer is able to print AcceptReceipt object and also UIImage\n\n                               \n//As for UIImage the DPP-250 can be a bit slow in printing bitmaps so we recommend to use AcceptReceipt object for printing\n\n                               \n//To obtain the AcceptReceipt object one can use method of WDAcceptSaleResponse receipt:showReturns:format:dpi:completion\n\n                               \n//WDAcceptSaleResponse is a sale response obtained either from saleManager pay method or saleManager querySales method\n\n                               \n//Let\ns assume WDAcceptSaleResponse below is the sale response obtained from the completion of saleManager pay method\n\n                               \nWDAcceptSaleResponse\n \n*\nsaleResponse\n;\n \n//here just empty sale response - you need to obtain it from payment flow or sale query\n\n                                                                   \n//lets assume the saleResponse is valid object obtained from pay or saleQuery\n\n                               \n[\nsaleResponse\n \nreceipt\n:\nYES\n \n//Is the receipt for cardholder use\n\n                                 \nshowReturns\n:\nNO\n \n//Should the receipt contain returns ?\n\n                                      \nformat\n:\nAcceptReceiptFormatDatecs\n \n//The receipt format is AcceptReceipt object for Datecs\n\n                                         \ndpi\n:\nAcceptReceiptDPIDefault\n \n//The dots per width is set to Default - valid for Datecs or AirPrint\n\n                                  \ncompletion\n:\n^\n(\nid\n  \n_Nullable\n \nreceipt\n,\n \nNSError\n \n*\n \n_Nullable\n \nerror\n)\n \n{\n\n                                      \n//Receipt as per format specified HTML | PDF | UIImage | AcceptReceipt object\n\n                                      \nprintConfig\n.\nreceipts\n \n=\n \n@[\nreceipt\n]\n;\n//printer can print single receipt or bulk - based on receipt objects in the arrays\n\n\n                                      \n//Print on the selected printer\n\n                                      \n[[\nsdk\n \nprinterManager\n]\n \nprint\n:\nprintConfig\n \n//Print connfiguration\n\n                                                         \nprogress\n:\nprogress\n \n//Print progress\n\n                                                       \ncompletion\n:\ncompletion\n];\n \n//End of print process\n\n                                  \n}];\n\n                           \n}];", 
            "title": "Print Receipt"
        }, 
        {
            "location": "/int-print/#print-receipt", 
            "text": "The  previous chapter  examined a simple device discovery for a printer that is paired. This chapter builds on that with more sophisticated receipt printing functionality, including:   reporting on the status of a print job  reporting on the final status of a print job", 
            "title": "Print Receipt"
        }, 
        {
            "location": "/int-print/#accept-receipt-and-uiimage", 
            "text": "As the code comments indicate, the Accept Receipt object tends to print quicker than the UIImage (which is a bitmap) so the sample code shown here prints an AcceptReceipt object. The  next chapter  demonstrates how to handle printing of a UIImage.   The input for a receipt can either be:   a Sale Response object from the payment method of Sales Manager  a Query object from the Sales Manager   The sample code uses a Sale Response because this is the usual type of information that you will want to print in a receipt.  A single receipt, or a collection of receipts, can be printed.", 
            "title": "Accept Receipt and UIImage"
        }, 
        {
            "location": "/int-print/#the-sample-code", 
            "text": "As is the case with much of the sample code in GIST, we start with the first printer object that is found.   //End of printing process  PrintCompletion   completion   =   ^ ( BOOL   printStatusOK ,   NSError *   _Nullable   printError ){ \n     //printStatusOK is true if printing ended with OK status  };  PrinterStateUpdate   progress   =   ^ ( AcceptPrinterStateUpdate   printProgress ){ \n     //printProgress - print progress Initialisation | Printing | Finished  };  //Discover active devices  [[ sdk   printerManager ]   discoverDevices : WDADatecsPrinterExtensionUUID   //Get the active Datecs DPP-250 handheld printer \n                            completion : ^ ( NSArray   WDAcceptTerminal   * *   _Nullable   devices ,   NSError *   _Nullable   devicesError ){ \n                                //Register for updates on device statuses and action results \n                                //Add Printer delegate to receive notifications about the paper status \n                                //Implement the method: -(void)device:(WDAcceptTerminal*)device paperStatusUpdated:(AcceptPrinterPaperStatus)status \n                                WDAcceptPrinterConfig   * printConfig   =   [ WDAcceptPrinterConfig   new ]; \n\n                                printConfig . printer   =   [ devices   firstObject ];   //for simplicity we use the first active Printer \n                                //Datecs Printer is able to print AcceptReceipt object and also UIImage \n                                //As for UIImage the DPP-250 can be a bit slow in printing bitmaps so we recommend to use AcceptReceipt object for printing \n                                //To obtain the AcceptReceipt object one can use method of WDAcceptSaleResponse receipt:showReturns:format:dpi:completion \n                                //WDAcceptSaleResponse is a sale response obtained either from saleManager pay method or saleManager querySales method \n                                //Let s assume WDAcceptSaleResponse below is the sale response obtained from the completion of saleManager pay method \n                                WDAcceptSaleResponse   * saleResponse ;   //here just empty sale response - you need to obtain it from payment flow or sale query \n                                                                    //lets assume the saleResponse is valid object obtained from pay or saleQuery \n                                [ saleResponse   receipt : YES   //Is the receipt for cardholder use \n                                  showReturns : NO   //Should the receipt contain returns ? \n                                       format : AcceptReceiptFormatDatecs   //The receipt format is AcceptReceipt object for Datecs \n                                          dpi : AcceptReceiptDPIDefault   //The dots per width is set to Default - valid for Datecs or AirPrint \n                                   completion : ^ ( id    _Nullable   receipt ,   NSError   *   _Nullable   error )   { \n                                       //Receipt as per format specified HTML | PDF | UIImage | AcceptReceipt object \n                                       printConfig . receipts   =   @[ receipt ] ; //printer can print single receipt or bulk - based on receipt objects in the arrays \n\n                                       //Print on the selected printer \n                                       [[ sdk   printerManager ]   print : printConfig   //Print connfiguration \n                                                          progress : progress   //Print progress \n                                                        completion : completion ];   //End of print process \n                                   }]; \n                            }];", 
            "title": "The Sample Code"
        }, 
        {
            "location": "/int-print-receipt/", 
            "text": "Print Receipt (UIImage)\n\n\nThis chapter, like the \nprevious one\n, describes how to print a receipt, but here we use the UIImage object. A single receipt, or a collection of receipts, can be printed. \n\n\nThe Sample Code\n\n\nThe code is largely the same as the \nprevious chapter\n, except that the format in the \nshowReturns\n object of Sale Response now uses: \nAcceptReceiptFormatDatecs\n.\n\n\nPrinterStateUpdate\n \nprogress\n \n=\n \n^\n(\nAcceptPrinterStateUpdate\n \nprintProgress\n){\n\n    \n//printProgress - print progress Initialisation | Printing | Finished\n\n\n};\n\n\n\n//Discover active devices\n\n\n[[\nsdk\n \nprinterManager\n]\n \ndiscoverDevices\n:\nWDAMPOPExtensionUUID\n \n//Get the active mPOP cash drawer with built in printer\n\n                           \ncompletion\n:\n^\n(\nNSArray\n \nWDAcceptTerminal\n \n*\n*\n \n_Nullable\n \ndevices\n,\n \nNSError\n*\n \n_Nullable\n \ndevicesError\n){\n\n\n                               \nWDAcceptPrinterConfig\n \n*\nprintConfig\n \n=\n \n[\nWDAcceptPrinterConfig\n \nnew\n];\n\n\n                               \nprintConfig\n.\nprinter\n \n=\n \n[\ndevices\n \nfirstObject\n];\n \n//for simplicity we use the first active Printer\n\n                                                                            \n//mPOP Printer is able to print UIImage or PDF object\n\n                                                                            \n//To obtain the Receipt object one can use method of WDAcceptSaleResponse receipt:showReturns:format:dpi:completion\n\n                                                                            \n//WDAcceptSaleResponse is a sale response obtained either from saleManager pay method or saleManager querySales method\n\n                                                                            \n//Let\ns assume WDAcceptSaleResponse below is the sale response obtained from the completion of saleManager pay method\n\n                               \nWDAcceptSaleResponse\n \n*\nsaleResponse\n;\n \n//here just empty sale response - you need to obtain it from payment flow or sale query\n\n                                                                   \n//lets assume the saleResponse is valid object obtained from pay or saleQuery\n\n                               \n[\nsaleResponse\n \nreceipt\n:\nYES\n \n//Is the receipt for cardholder use ?\n\n                                         \nshowReturns\n:\nNO\n \n//Should the receipt contain returns ?\n\n                                              \nformat\n:\nAcceptReceiptFormatUIImage\n \n//The receipt format is UIImage object for mPOP\n\n                                                 \ndpi\n:\nAcceptReceiptDPIDefault\n \n//The dots per width is set to mPOP supported resolution\n\n                                          \ncompletion\n:\n^\n(\nid\n  \n_Nullable\n \nreceipt\n,\n \nNSError\n \n*\n \n_Nullable\n \nerror\n)\n \n{\n\n                                              \n//Returned receipt object is now a UIImage that can be printed by mPOP\n\n                                              \nprintConfig\n.\nreceipts\n \n=\n \n@[\nreceipt\n]\n;\n//printer can print single receipt or bulk - based on receipt objects in the arrays\n\n\n                                              \n//Print on the selected printer\n\n                                              \n[[\nsdk\n \nprinterManager\n]\n \nprint\n:\nprintConfig\n \n//Print connfiguration\n\n                                                                 \nprogress\n:\nprogress\n \n//Print progress\n\n                                                               \ncompletion\n:\ncompletion\n];\n \n//End of print process\n\n                                          \n}];\n\n                           \n}];", 
            "title": "Print Receipt (UIImage)"
        }, 
        {
            "location": "/int-print-receipt/#print-receipt-uiimage", 
            "text": "This chapter, like the  previous one , describes how to print a receipt, but here we use the UIImage object. A single receipt, or a collection of receipts, can be printed.", 
            "title": "Print Receipt (UIImage)"
        }, 
        {
            "location": "/int-print-receipt/#the-sample-code", 
            "text": "The code is largely the same as the  previous chapter , except that the format in the  showReturns  object of Sale Response now uses:  AcceptReceiptFormatDatecs .  PrinterStateUpdate   progress   =   ^ ( AcceptPrinterStateUpdate   printProgress ){ \n     //printProgress - print progress Initialisation | Printing | Finished  };  //Discover active devices  [[ sdk   printerManager ]   discoverDevices : WDAMPOPExtensionUUID   //Get the active mPOP cash drawer with built in printer \n                            completion : ^ ( NSArray   WDAcceptTerminal   * *   _Nullable   devices ,   NSError *   _Nullable   devicesError ){ \n\n                                WDAcceptPrinterConfig   * printConfig   =   [ WDAcceptPrinterConfig   new ]; \n\n                                printConfig . printer   =   [ devices   firstObject ];   //for simplicity we use the first active Printer \n                                                                             //mPOP Printer is able to print UIImage or PDF object \n                                                                             //To obtain the Receipt object one can use method of WDAcceptSaleResponse receipt:showReturns:format:dpi:completion \n                                                                             //WDAcceptSaleResponse is a sale response obtained either from saleManager pay method or saleManager querySales method \n                                                                             //Let s assume WDAcceptSaleResponse below is the sale response obtained from the completion of saleManager pay method \n                                WDAcceptSaleResponse   * saleResponse ;   //here just empty sale response - you need to obtain it from payment flow or sale query \n                                                                    //lets assume the saleResponse is valid object obtained from pay or saleQuery \n                                [ saleResponse   receipt : YES   //Is the receipt for cardholder use ? \n                                          showReturns : NO   //Should the receipt contain returns ? \n                                               format : AcceptReceiptFormatUIImage   //The receipt format is UIImage object for mPOP \n                                                  dpi : AcceptReceiptDPIDefault   //The dots per width is set to mPOP supported resolution \n                                           completion : ^ ( id    _Nullable   receipt ,   NSError   *   _Nullable   error )   { \n                                               //Returned receipt object is now a UIImage that can be printed by mPOP \n                                               printConfig . receipts   =   @[ receipt ] ; //printer can print single receipt or bulk - based on receipt objects in the arrays \n\n                                               //Print on the selected printer \n                                               [[ sdk   printerManager ]   print : printConfig   //Print connfiguration \n                                                                  progress : progress   //Print progress \n                                                                completion : completion ];   //End of print process \n                                           }]; \n                            }];", 
            "title": "The Sample Code"
        }, 
        {
            "location": "/int-print-paperstatus/", 
            "text": "Check Paper Status\n\n\nThis sample code illustrates how to report on the paper status of an active mPOP printer.\n\n\nThe Sample Code\n\n\n\n\nNote\n\n\nThe Android sample code is not yet implemented.\n\n\n\n\nInsert GIST here and remove Objective-C below.\n\n\n//The base class needs to conform to WDAcceptPrinting\n\n\n//Discover active devices\n\n\n[[\nsdk\n \nprinterManager\n]\n \ndiscoverDevices\n:\nWDAMPOPExtensionUUID\n \n//Get the active mPOP printer\n\n                           \ncompletion\n:\n^\n(\nNSArray\n \nWDAcceptTerminal\n \n*\n*\n \n_Nullable\n \ndevices\n,\n \nNSError\n*\n \n_Nullable\n \ndevicesError\n){\n\n                               \n//Register for updates on device statuses and action results\n\n                               \n//Add Printer delegate to receive notifications about the paper status\n\n                               \n//Implement the method: -(void)device:(WDAcceptTerminal*)device paperStatusUpdated:(AcceptPrinterPaperStatus)status\n\n                               \n[[\nsdk\n \nprinterManager\n]\n \naddPrinterManagerDelegate\n:\nself\n\n                                                             \nforPrinter\n:[\ndevices\n \nfirstObject\n]];\n//for simplicity we use the first active DPP-250\n\n                           \n}];", 
            "title": "Check Paper Status"
        }, 
        {
            "location": "/int-print-paperstatus/#check-paper-status", 
            "text": "This sample code illustrates how to report on the paper status of an active mPOP printer.", 
            "title": "Check Paper Status"
        }, 
        {
            "location": "/int-print-paperstatus/#the-sample-code", 
            "text": "Note  The Android sample code is not yet implemented.   Insert GIST here and remove Objective-C below.  //The base class needs to conform to WDAcceptPrinting  //Discover active devices  [[ sdk   printerManager ]   discoverDevices : WDAMPOPExtensionUUID   //Get the active mPOP printer \n                            completion : ^ ( NSArray   WDAcceptTerminal   * *   _Nullable   devices ,   NSError *   _Nullable   devicesError ){ \n                                //Register for updates on device statuses and action results \n                                //Add Printer delegate to receive notifications about the paper status \n                                //Implement the method: -(void)device:(WDAcceptTerminal*)device paperStatusUpdated:(AcceptPrinterPaperStatus)status \n                                [[ sdk   printerManager ]   addPrinterManagerDelegate : self \n                                                              forPrinter :[ devices   firstObject ]]; //for simplicity we use the first active DPP-250 \n                            }];", 
            "title": "The Sample Code"
        }, 
        {
            "location": "/int-scanner-overview/", 
            "text": "Scanner Manager Overview\n\n\nThis section shows you how to use the Terminal Manager component, which is one of four hardware-related components. Specifically it describes how to discover scanner devices.", 
            "title": "Scanner Manager Overview"
        }, 
        {
            "location": "/int-scanner-overview/#scanner-manager-overview", 
            "text": "This section shows you how to use the Terminal Manager component, which is one of four hardware-related components. Specifically it describes how to discover scanner devices.", 
            "title": "Scanner Manager Overview"
        }, 
        {
            "location": "/int-scanner-discovery/", 
            "text": "Scanner Discovery\n\n\nThe discover devices functionality of Scanner Manager:\n\n\n\n\ndiscovers any connected handheld barcode scanning devices\n\n\nregisters to receive device status updates\n\n\nregisters to receive action result updates\n\n\nprepares Scanner Manager for the reception of the data after the barcode is scanned\n\n\n\n\nSo, related to the last point above, the main task for you is to implement a method that handles the \ndataReceived\n. \n\n\nThe User Interface\n\n\nA typical user interface might look like this:\n\n\n\n\nThe Sample Code\n\n\nFor simplicity, the sample code utilizes the first scanner that is found, however, if necessary you can handle this in a more sophisticated way and deal with more than one scanner.\n\n\n\n\nWarning\n\n\nThe base class needs to conform to \nWDAcceptScanning\n. \n\n\n\n\n\n\nNote\n\n\nThe Android sample code is not yet implemented.\n\n\n\n\nInsert GIST here and remove Objective-C below.\n\n\n//The base class needs to conform to WDAcceptPrinting, WDAcceptScanning, WDAcceptManagerDelegate respectively\n\n\n//Discover active devices\n\n\n[[\nsdk\n \nscannerManager\n]\n \ndiscoverDevices\n:\nWDASocketExtensionUUID\n \n//Get the active SocketScanner handheld barcode scanner\n\n                           \ncompletion\n:\n^\n(\nNSArray\n \nWDAcceptTerminal\n \n*\n*\n \n_Nullable\n \ndevices\n,\n \nNSError\n*\n \n_Nullable\n \ndevicesError\n){\n\n                               \n//Register for updates on device statuses and action results\n\n                               \n//Add Scanner delegate to receive the data after the barcode was read\n\n                               \n//Implement the method: -(void)device:(WDAcceptTerminal*)device dataReceived:(NSData *)dataReceived;\n\n                               \n[[\nsdk\n \nscannerManager\n]\n \naddScannerManagerDelegate\n:\nself\n\n                                                             \nforScanner\n:[\ndevices\n \nfirstObject\n]];\n//for simplicity we will use the first active SocketScanner device\n\n                           \n}];", 
            "title": "Scanner Discovery"
        }, 
        {
            "location": "/int-scanner-discovery/#scanner-discovery", 
            "text": "The discover devices functionality of Scanner Manager:   discovers any connected handheld barcode scanning devices  registers to receive device status updates  registers to receive action result updates  prepares Scanner Manager for the reception of the data after the barcode is scanned   So, related to the last point above, the main task for you is to implement a method that handles the  dataReceived .", 
            "title": "Scanner Discovery"
        }, 
        {
            "location": "/int-scanner-discovery/#the-user-interface", 
            "text": "A typical user interface might look like this:", 
            "title": "The User Interface"
        }, 
        {
            "location": "/int-scanner-discovery/#the-sample-code", 
            "text": "For simplicity, the sample code utilizes the first scanner that is found, however, if necessary you can handle this in a more sophisticated way and deal with more than one scanner.   Warning  The base class needs to conform to  WDAcceptScanning .     Note  The Android sample code is not yet implemented.   Insert GIST here and remove Objective-C below.  //The base class needs to conform to WDAcceptPrinting, WDAcceptScanning, WDAcceptManagerDelegate respectively  //Discover active devices  [[ sdk   scannerManager ]   discoverDevices : WDASocketExtensionUUID   //Get the active SocketScanner handheld barcode scanner \n                            completion : ^ ( NSArray   WDAcceptTerminal   * *   _Nullable   devices ,   NSError *   _Nullable   devicesError ){ \n                                //Register for updates on device statuses and action results \n                                //Add Scanner delegate to receive the data after the barcode was read \n                                //Implement the method: -(void)device:(WDAcceptTerminal*)device dataReceived:(NSData *)dataReceived; \n                                [[ sdk   scannerManager ]   addScannerManagerDelegate : self \n                                                              forScanner :[ devices   firstObject ]]; //for simplicity we will use the first active SocketScanner device \n                            }];", 
            "title": "The Sample Code"
        }, 
        {
            "location": "/int-customermanager/", 
            "text": "Customer Manager (ERP)\n\n\nIf the merchant chooses to integrate its ERP system, and they have set up all members (i.e. customers), for example, using SAP Business ByDesign, then you can obtain information about a member based on:\n\n\n\n\nthe unique identifier for the member\n\n\nthe first name\n\n\nthe surname\n\n\n\n\nThe unique identifier for a member can typically be collected by:\n\n\n\n\nscanning a membership card belonging to the consumer\n\n\nscanning a barcode belonging to the consumer\n\n\n\n\nYou can also specify whether you want only exact matches are not, as shown in the sample code. \n\n\nThe User Interface\n\n\nA typical interface might look like this:\n\n\n\n\n\n\nNote\n\n\nIn this example, a consumer's membership card is shown, but a card with a barcode is also usable. \n\n\n\n\nThe Sample Code\n\n\nIn the sample code, a unique identifier for the member is used to obtain information for that member. \n\n\nInsert GIST here and remove Objective-C below.\n\n\n//End of members process\n\n\nMembersCompletion\n \ncompletion\n \n=\n \n^\n(\nNSArray\n \nWDAcceptMember\n \n*\n*\nmembers\n,\n \nNSError\n \n*\nerr\n)\n \n{\n\n    \n//members - list of Members as set by the Merchant in their ERP system\n\n\n};\n\n\n\n//Query the Members base\n\n\n[[\nsdk\n \ncustomerManager\n]\n \nmemberInformation\n:\n@\nMember ID\n \n// ERP Member Id - may be printed on the membership card, or in the form of barcode\n\n                                 \nsurname\n:\nnil\n \n// Surname or Family Name\n\n                               \nfirstName\n:\nnil\n \n// First name or give name\n\n                              \nexactMatch\n:\nNO\n \n// flag if exact match of member id, first name, surname should be used\n\n                              \ncompletion\n:\ncompletion\n];\n// End of members process", 
            "title": "Customer Manager (ERP)"
        }, 
        {
            "location": "/int-customermanager/#customer-manager-erp", 
            "text": "If the merchant chooses to integrate its ERP system, and they have set up all members (i.e. customers), for example, using SAP Business ByDesign, then you can obtain information about a member based on:   the unique identifier for the member  the first name  the surname   The unique identifier for a member can typically be collected by:   scanning a membership card belonging to the consumer  scanning a barcode belonging to the consumer   You can also specify whether you want only exact matches are not, as shown in the sample code.", 
            "title": "Customer Manager (ERP)"
        }, 
        {
            "location": "/int-customermanager/#the-user-interface", 
            "text": "A typical interface might look like this:    Note  In this example, a consumer's membership card is shown, but a card with a barcode is also usable.", 
            "title": "The User Interface"
        }, 
        {
            "location": "/int-customermanager/#the-sample-code", 
            "text": "In the sample code, a unique identifier for the member is used to obtain information for that member.   Insert GIST here and remove Objective-C below.  //End of members process  MembersCompletion   completion   =   ^ ( NSArray   WDAcceptMember   * * members ,   NSError   * err )   { \n     //members - list of Members as set by the Merchant in their ERP system  };  //Query the Members base  [[ sdk   customerManager ]   memberInformation : @ Member ID   // ERP Member Id - may be printed on the membership card, or in the form of barcode \n                                  surname : nil   // Surname or Family Name \n                                firstName : nil   // First name or give name \n                               exactMatch : NO   // flag if exact match of member id, first name, surname should be used \n                               completion : completion ]; // End of members process", 
            "title": "The Sample Code"
        }, 
        {
            "location": "/int-usermanager/", 
            "text": "User Manager\n\n\nThe merchant's staff who use the payment acceptance app that you create are referred to as the \nusers\n. Each user needs to be authenticated before they can use the app, typically through a login screen. A login screen is not provided as part of the SDK, but the User Manager component does provides a variety of handy functionality for managing and modifying the user's credentials:\n\n\n\n\npassword policy - lets you access the password rules\n\n\npassword reset - sends instructions to the user's email address so that they can reset their password (if there is a valid email available)\n\n\nremind username - sends the user name to a specified email address\n\n\nchange password - enables an authenticated user to change their password\n\n\n\n\nThe User Interface\n\n\nA typical interface might look like this:\n\n\n\n\nThe Sample Code\n\n\nIn the iOS code, there are three key methods that are used: \n\n\n\n\npasswordPolicy\n\n\nmanageCredentials\n\n\nchangePassword\n\n\n\n\nThe \nmanageCredentials\n method used is in three different ways, which correspond to three parameters you can pass it:\n\n\n\n\nremindUserName\n\n\nresetPassword\n\n\nchangePassword\n\n\n\n\n\n\nNote\n\n\nIn the sample code, the SDK is instantiated with a name of \nsdkNoUser\n, in contrast with the usual object name of \nsdk\n. This makes sense because the operations are different when you do not have an authenticated user. See the Initialization chapters for information about instantiating the \nAcceptSDK\n object when you have an authenticated user.\n\n\n\n\nInsert GIST here and remove Objective-C below.\n\n\n// The SDK is initialized as shared instance so can be accessed\n\n\n// from multiple View Controllers\n\n\nAcceptSDK\n \n*\nsdkNoUser\n \n=\n \n[\nAcceptSDK\n \nsharedInstance\n];\n\n\n\n// Set the SDK target environment - in this case Public Test\n\n\n// for remind username and reset password the SDK does not need to be authenticated\n\n\n[\nsdkNoUser\n \nsetupWithEnvironment\n:\nAcceptEnvironmentPublicTest\n\n                       \nusername\n:\nnil\n\n                       \npassword\n:\nnil\n];\n\n\n\n//End of credential management process\n\n\nCredentialManagementCompletion\n \ncompletion\n \n=\n \n^\n(\nWDAcceptResult\n \n*\n \n_Nullable\n \nresult\n,\n \nNSError\n*\n \n_Nullable\n \nerror\n){\n\n    \n//result - details from the credential management process\n\n    \n// AcceptResultStatusOK indicates the process ended with OK status\n\n    \n// AcceptResultStatusPasswordCriteriaNotMet - in the case of changing the password indicates that the new password does not\n\n    \n//                                            meet the criteria\n\n    \n// AcceptResultStatusPasswordValidationFailure - in the case of changing password indicates the password validation failure\n\n    \n//                                               old and new password mismatch\n\n\n};\n\n\n\n//******************* PASSWORD POLICY *******************//\n\n\n//End of password policy process\n\n\nPasswordPolicyCompletion\n \npolicyCompletion\n \n=\n \n^\n(\nWDPasswordPolicyResult\n \n*\n \n_Nullable\n \npolicy\n,\n \nNSError\n*\n \n_Nullable\n \nerror\n){\n\n    \n//policy - the details of the password policy\n\n\n};\n\n\n\n//Obtain the password policy valid for the user credentials on this system\n\n\n[\nsdkNoUser\n.\nuserManager\n \npasswordPolicy\n:\npolicyCompletion\n];\n\n\n\n//******************* REMIND USERNAME *******************//\n\n\n//Remind username\n\n\nWDAcceptRemindUsername\n \n*\nremindUserName\n \n=\n \n[\nWDAcceptRemindUsername\n \nnew\n];\n\n\nremindUserName\n.\nemail\n \n=\n \n@\nUser@Email\n;\n \n// email address to send the remind message to\n\n\n\n// Remind username - the message will be sent to specified email address\n\n\n[\nsdkNoUser\n.\nuserManager\n \nmanageCredentials\n:\nremindUserName\n \n// Remind username object\n\n                              \ncompletion\n:\ncompletion\n];\n \n// End of credential management process\n\n\n\n//******************* RESET PASSWORD *******************//\n\n\nWDAcceptRequestPasswordReset\n \n*\nresetPassword\n \n=\n \n[\nWDAcceptRequestPasswordReset\n \nnew\n];\n\n\nresetPassword\n.\nusername\n \n=\n \n@\nUserName\n;\n \n// username for which to reset the password\n\n\n\n//Reset password - instructions will be sent to the specified user email address (as stored on the backend)\n\n\n[\nsdkNoUser\n.\nuserManager\n \nmanageCredentials\n:\nresetPassword\n \n// Reset password object\n\n                              \ncompletion\n:\ncompletion\n];\n \n// End of credential management process\n\n\n\n//******************* CHANGE PASSWORD *******************//\n\n\n// Change Password details - available only to the AUTHENTICATED user\n\n\nWDAcceptChangePassword\n \n*\nchangePassword\n \n=\n \n[\nWDAcceptChangePassword\n \nnew\n];\n\n\nchangePassword\n.\ncurrentPassword\n \n=\n \n@\nOld Password\n;\n \n// old password of the current user\n\n\nchangePassword\n.\nsetNewPassword\n \n=\n \n@\nNew Password\n;\n \n// new password of the current user\n\n\n\n// Change password for the AUTHENTICATED user\n\n\n[\nsdk\n.\nuserManager\n \nmanageCredentials\n:\nchangePassword\n \n// Change password object\n\n                        \ncompletion\n:\ncompletion\n];\n//End of credential management process", 
            "title": "User Manager"
        }, 
        {
            "location": "/int-usermanager/#user-manager", 
            "text": "The merchant's staff who use the payment acceptance app that you create are referred to as the  users . Each user needs to be authenticated before they can use the app, typically through a login screen. A login screen is not provided as part of the SDK, but the User Manager component does provides a variety of handy functionality for managing and modifying the user's credentials:   password policy - lets you access the password rules  password reset - sends instructions to the user's email address so that they can reset their password (if there is a valid email available)  remind username - sends the user name to a specified email address  change password - enables an authenticated user to change their password", 
            "title": "User Manager"
        }, 
        {
            "location": "/int-usermanager/#the-user-interface", 
            "text": "A typical interface might look like this:", 
            "title": "The User Interface"
        }, 
        {
            "location": "/int-usermanager/#the-sample-code", 
            "text": "In the iOS code, there are three key methods that are used:    passwordPolicy  manageCredentials  changePassword   The  manageCredentials  method used is in three different ways, which correspond to three parameters you can pass it:   remindUserName  resetPassword  changePassword    Note  In the sample code, the SDK is instantiated with a name of  sdkNoUser , in contrast with the usual object name of  sdk . This makes sense because the operations are different when you do not have an authenticated user. See the Initialization chapters for information about instantiating the  AcceptSDK  object when you have an authenticated user.   Insert GIST here and remove Objective-C below.  // The SDK is initialized as shared instance so can be accessed  // from multiple View Controllers  AcceptSDK   * sdkNoUser   =   [ AcceptSDK   sharedInstance ];  // Set the SDK target environment - in this case Public Test  // for remind username and reset password the SDK does not need to be authenticated  [ sdkNoUser   setupWithEnvironment : AcceptEnvironmentPublicTest \n                        username : nil \n                        password : nil ];  //End of credential management process  CredentialManagementCompletion   completion   =   ^ ( WDAcceptResult   *   _Nullable   result ,   NSError *   _Nullable   error ){ \n     //result - details from the credential management process \n     // AcceptResultStatusOK indicates the process ended with OK status \n     // AcceptResultStatusPasswordCriteriaNotMet - in the case of changing the password indicates that the new password does not \n     //                                            meet the criteria \n     // AcceptResultStatusPasswordValidationFailure - in the case of changing password indicates the password validation failure \n     //                                               old and new password mismatch  };  //******************* PASSWORD POLICY *******************//  //End of password policy process  PasswordPolicyCompletion   policyCompletion   =   ^ ( WDPasswordPolicyResult   *   _Nullable   policy ,   NSError *   _Nullable   error ){ \n     //policy - the details of the password policy  };  //Obtain the password policy valid for the user credentials on this system  [ sdkNoUser . userManager   passwordPolicy : policyCompletion ];  //******************* REMIND USERNAME *******************//  //Remind username  WDAcceptRemindUsername   * remindUserName   =   [ WDAcceptRemindUsername   new ];  remindUserName . email   =   @ User@Email ;   // email address to send the remind message to  // Remind username - the message will be sent to specified email address  [ sdkNoUser . userManager   manageCredentials : remindUserName   // Remind username object \n                               completion : completion ];   // End of credential management process  //******************* RESET PASSWORD *******************//  WDAcceptRequestPasswordReset   * resetPassword   =   [ WDAcceptRequestPasswordReset   new ];  resetPassword . username   =   @ UserName ;   // username for which to reset the password  //Reset password - instructions will be sent to the specified user email address (as stored on the backend)  [ sdkNoUser . userManager   manageCredentials : resetPassword   // Reset password object \n                               completion : completion ];   // End of credential management process  //******************* CHANGE PASSWORD *******************//  // Change Password details - available only to the AUTHENTICATED user  WDAcceptChangePassword   * changePassword   =   [ WDAcceptChangePassword   new ];  changePassword . currentPassword   =   @ Old Password ;   // old password of the current user  changePassword . setNewPassword   =   @ New Password ;   // new password of the current user  // Change password for the AUTHENTICATED user  [ sdk . userManager   manageCredentials : changePassword   // Change password object \n                         completion : completion ]; //End of credential management process", 
            "title": "The Sample Code"
        }, 
        {
            "location": "/androidref/", 
            "text": "Android Class Reference\n\n\nReplace with javadoc index.", 
            "title": "Reference - Android SDK"
        }, 
        {
            "location": "/androidref/#android-class-reference", 
            "text": "Replace with javadoc index.", 
            "title": "Android Class Reference"
        }, 
        {
            "location": "/iosref/", 
            "text": "iOS Class Reference\n\n\nReplace with doxygen index.", 
            "title": "Reference - iOS SDK"
        }, 
        {
            "location": "/iosref/#ios-class-reference", 
            "text": "Replace with doxygen index.", 
            "title": "iOS Class Reference"
        }, 
        {
            "location": "/glossary/", 
            "text": "Glossary\n\n\nGlossary of Acronyms\n\n\nCNP\n \u2013 Chip and PIN\n\n\nCVM\n - Card Verification Method\n\n\nDUKPT\n \u2013 Derived Unique Key Per Transaction\n\n\nEFT\n - Electronic Funds Transfer\n\n\nEMV\n - Europay, Mastercard, Visa. See \nEMV\n below.\n\n\nERP\n \u2013 Enterprise Resource Planning\n\n\nFW\n - Firmware\n\n\nHSM\n - Hardware Security Module. See \nHSM\n below.  \n\n\nmPOS\n - mobile Point of Sale\n\n\nMFI\n \u2013 Made for iPhone.\n\n\nPCI DSS\n \u2013 Payment Card Industry Data Security Standard\n\n\nREST\n \u2013 Representational State Transfer\n\n\nSEPA\n - Single Euro Payments Area\n\n\nUUID\n \u2013 Unique User Identifier\n\n\nGlossary of Terminology\n\n\nA\n\n\nAcquiring Platform\n \u2013 This is the primary payment facilitation component in the overall payment processing architecture. The Acquiring Platform is operated by the \nAcquirer\n and handles the \ninterchange\n with the \ncard schemes\n so that, ultimately, the transaction is debited from the account of the Cardholder. For SUPR Accept SDK, a \nmerchant\n requires a contract with an Acquiring Platform so that they have an account through which to route transactions. Wirecard's \nPayment \n Risk\n division provides its own Acquiring Platform with the Wirecard \nAcquiring and Processing\n unit.\n\n\nAcquirer\n - Entities that collect card payments that have been accepted by merchants, and then aggregrate and separate those payments and forward them on to \nIssuers\n for processing. Also known as \nMerchant Acquirers\n.\n\n\nAcquiring and Processing\n - Unit of Wirecard that provides an \nAcquiring Platform\n.\n\n\nAlipay\n \u2013 The largest mobile and online payment platform in the world, with 400 million users in China alone. Individual users receive a unique QR code which they use when making a payment to a merchant. The SUPR Accept SDK supports payments made through Alipay.\n\n\nauthorize\n - One type of sale request. To allocate a certain amount on a credit card prior to completion of a sale. \n\n\nB\n\n\nback-end\n - Refers to the new \nSwitch\n back-end. With SUPR Accept SDK, you create a \nfront-end\n \npayment acceptance app\n and Switch is the corresponding back-end. The Switch back-end itself forwards transactions on to the \nGateway\n, which in turn, forwards the transaction on to the \nAcquirer\n and, ultimately, to the \nIssuer\n so that the consumer can pay the Issuer. In addition, many merchants also have an \nERP\n system connected which augments the back-end functionality provided by Switch.\n\n\nbarcode\n - One of two possible types of codes that can be scanned with a \npistol scanner\n. The other type is a \nQR code\n.\n\n\nbasket\n - A user-defined collection of items for purchase, also referred to as a \ncart\n or \nshopping cart\n.\n\n\nBusiness ByDesign\n - See \nSAP Business ByDesign\n.\n\n\nC\n\n\ncardholder\n - Consumer who uses a debit or credit card as their method of payment.\n\n\nCard Issuer\n - See \nIssuer\n.\n\n\ncard reader\n - See \nterminal\n.\n\n\ncart\n - See \nbasket\n.\n\n\ncash\n - Physical money in the form of bank notes or coins.\n\n\ncash in/out\n - See \npay in/out\n.\n\n\ncash payments\n - Payment with bank notes or coins. The opposite of \ncashless payments\n.\n\n\ncash register\n - Refers to an actual piece of hardware that provides cash register functionality. \nCash Register\n (i.e. spelled with a capital C and a capital R) refers to the object in the SDK code.\n\n\nCash Register\n - Object in the SDK code that represents a real-life cash register. Each merchant may have one or more Cash Registers, each of which is identified by a unique identifier. Each Cashier must be associated with a Cash Register. Cash Registers are part of the Cash Manager component.\n\n\nCashier\n - User of a cash register. Each Cashier must be associated with a Cash Register.\n\n\ncashless payment\n - Payment that involves a card, and does not involve bank notes or coins. The opposite of \ncash payments\n.\n\n\nChip and PIN cards\n - See \nEMV cards\n.\n\n\nChip and Signature cards\n - See \nEMV cards\n.\n\n\nconsumer\n - Person involved in a sale with a merchant. For example, a customer dining in a restaurant. If the consumer uses a card to pay, they are also referred to as a \ncardholder\n.\n\n\ncustomer\n - Identifier in a back-end ERP system. Also referred to as a member in some ERP systems, including \nSAP Business By Design\n. See \nmember\n.\n\n\nD\n\n\ndevice\n - The physical hardware used by the merchant who has the payment acceptance app installed.\n\n\nE\n\n\nelectronic payments\n - Same as \ncashless payments\n. Contrast with \ncash payments\n.\n\n\nEMV\n - A global standard for credit cards that use chips to authenticate and secure chip-card transactions. Currently, EMV is managed by EMVCo which includes American Express, China UnionPay, Discover and others.\n\n\nEMV Cards\n \u2013 Smart cards, chip cards and IC cards, which include magnetic stripes for backward compatibility. Also includes contactless cards, which can be read over a short distance. EMV-compliant cards are often called \nChip and PIN\n or \nChip and Signature\n cards.\n\n\nF\n\n\nFirmware\n \u2013 Permanent software that resides in memory of a hardware device. In terms of the SDK, firmware is significant because you can, and should, provide users with the ability to update their firmware from within the \npayment acceptance app\n that you create.\n\n\nfront-end\n - The \npayment acceptance app\n that is created by \npartners\n using the SUPR Accept SDK is typically referred to as the front-end to distinguish it from the \nSwitch\n \nback-end\n, which handles the processing and routing of transactions.\n\n\nfull refund\n - A return to the consumer of the full amount that they paid in the original sale. \n\n\nG\n\n\nGateway\n - Wirecard component that is responsible for the initial processing of the transaction and then routing to the \nAcquirer\n. Initial processing includes handling the secure decryption of \nMagStripe\n, \nEMV\n and both offline and online PIN transactions. An \nHSM\n is hosted to support decryption of card holder data. The Gateway is fully PCI DSS certified. For our partners developing with the SUPR Accept SDK, there is a \nTest Gateway\n to help with initial development and testing. It allows you to simulate the full end-to-end payment process during development.\n\n\ngift card\n \u2013 Physical or online card that provides the consumer with a discount on a purchase.\n\n\nH\n\n\nHSM\n -  A physical device that helps with the decryption of PIN and other card holder data.\n\n\nI\n\n\nInventory Manager\n - Component of the SDK that enables the set up and maintenance of product catalogues, product categories and sub-categories, and products (including product images).\n\n\nIssuing Bank\n - See \nCard Issuer\n.\n\n\nIssuer\n - See \nCard Issuer\n.\n\n\nM\n\n\nmerchant\n - A seller of products, typically with a physical location, which is known as a \nstore\n or \nshop\n. The SUPR Accept SDK is used by our \npartners\n to create \npayment acceptance apps\n for merchants.\n\n\nMerchant Acquirer\n - See \nAcquirer\n.\n\n\nmember\n - A term that is sometimes used by ERP back-end systems to refer to customers. See \ncustomer\n.\n\n\nmobile device\n \u2013 Hardware on which apps created with the SUPR Accept SDK run. Currently, iOS and Android devices are supported and Windows Mobile is coming soon.\n\n\nSwitch Portal\n - Graphical User Interface provided to merchants that can be used to maintain their data that is stored in the Switch back-end.\n\n\nO\n\n\nObjective-C\n - One of the programming languages that is available on the iOS platform. It is also available in the  \nSwift\n language.\n\n\nP\n\n\npartial refund\n - A return to the consumer of a portion of the amount they paid in the original sale.\n\n\npartner\n - Refers to companies that collaborate with Wirecard to create \npayment acceptance apps\n for \nmerchants\n using the SUPR Accept SDK.\n\n\npartner team\n - One or more persons at a partner company responsible for creating a \npayment acceptance app\n using the SUPR Accept SDK. Typically, a partner team consists of a project manager and one or more developers. This SUPR Accept SDK documentation was created for our partner teams.\n\n\npay in/out\n \u2013 Cash that is either put in or taken out of a cash register. Also referred to as cash in and cash out, or cash in/out.\n\n\npayment gateway\n - See \nGateway\n.\n\n\npayment method\n - Form of payment used in a sale. With the SUPR Accept SDK, the form can be cash, card, SEPA, Alipay or WeChat Pay.\n\n\nPayment \n Risk\n - Division of Wirecard that handles \nAcquiring and Processing\n services.\n\n\npayment acceptance app\n - App that Wirecard \npartners\n create with the SUPR Accept SDK. This may be a fully-standalone app, or it could be a sub-component of a larger app. For example, a logistics company would already have an app that handles logistics, such as deliveries, storage and so forth, but they may want to add payment acceptance functionality so that their drivers can accept cards and cash. So, in this case, the SUPR Accept SDK would be used to create a sub-component of the logistics app. For simplicity though, throughout this documentation, the app created with the SUPR Accept SDK is always referred to as the \npayment acceptance app\n. \n\n\npayment gateway\n \u2013 Transaction processing and routing. See \nGateway\n.\n\n\npistol scanner\n - Handheld scanner used to scan \nbarcodes\n and \nQR codes\n.\n\n\nplatform\n - Refers to the operating system on which the SUPR Accept SDK is used. Also refers to the operating system on which the application functionality created with the SDK will run. For example, iOS is one of the platforms that is supported by the SDK.\n\n\nproduct catalogue\n - A set of products. Also commonly referred to as inventory. See \nInventory Manager\n.\n\n\nPublic Test\n \u2013 Switch back-end testing environment provided by Wirecard that is ideal for testing and validation of application functionality that you build with the SDK.\n\n\npurchase\n - The most common \ntransaction type\n. A purchase involves the \nconsumer\n buying something from a \nmerchant\n. Other types of transactions include \nreturn\n, \nauthorize\n, \npre-authorize\n.\n\n\nQ\n\n\nQR code\n - Commonly used abbreviation for Quick Response (QR) code. A matrix-type barcode consisting of black and white squares. Most mobile devices have free QR code reader apps. A QR code is one of two types of codes that can be scanned using a \npistol scanner\n. See also \nbarcode\n.\n\n\nR\n\n\nreturn\n - Can be a \nreverse\n or a \nrefund\n.\n\n\nreverse\n - A cancellation of a sale, which can be performed if the sale has not yet been processed by the \nAcquiring Platform\n.\n\n\nrefund\n - A cancellation of a sale and a return of the payment to the consumer. The SDK supports both full and partial refunds.\n\n\nS\n\n\nsale\n - The initial interaction between the merchant user and a \nconsumer\n. In terms of the SDK code, sales begin with a \nSale Request\n and completes with a \nSale Response\n.\n\n\nSale Response\n - SDK object that has the results of the sale after processing by the back-end.\n\n\nSale Request\n - SDK object that is used in the initial phase of a sale to a consumer. This object has the particulars of a sale, including price, quantity and tax rate. Note that a Sale Request is typically a \npurchase\n, but it can also be a \nreturn\n, an \nauthorize\n, or a \npre-authorize\n.\n\n\nSAP Business ByDesign\n - A cloud-based \nERP\n solution for small to medium-sized businesses. This software can be used to augment the \nSwitch\n \nback-end\n which is provided as part of the SDK.\n\n\nscanner\n - See \npistol scanner\n.\n\n\nSEPA\n \u2013 The\u00a0Single Euro Payments Area\u00a0(SEPA) is a payment-integration initiative of the European Union for simplification of bank transfers denominated in euros.\n\n\nshift\n \u2013 Working time of a merchant user. Starts with the open and ends with the close.\n\n\nshop\n - The physical location of a merchant. In terms of the SDK, this is significant if the merchant has more than one physical location.\n\n\nshopping cart\n - See \nbasket\n.\n\n\nShift Report\n - Detailed information about transaction activity between the opening of a shift and its closing. Also known as a Z-Report.\n\n\nShift Activity\n \u2013 \nPay in/out\n activity between the open and close of a shift.\n\n\nStar Micronics\n - Vendor of payment acceptance hardware.\n\n\nStarIO\n - See \nStar Micronics\n.\n\n\nstore\n - See \nshop\n.\n\n\nSwift\n - One of the programming languages that is available on the iOS platform. See also \nObjective-C\n. \n\n\nSwitch\n - The back-end of the SUPR Accept SDK front-end. Transactions are processed through the Switch back-end. As part of the setup process for a merchant, they will need to set up the appropriate users, products, product catalogues, terminals and so forth. Consult your Wirecard representative for more information. Also, note that some customers may also have an ERP system connected to Switch, which provides more back-end functionality, such as Price list management and Stock level management. Once again, consult your Wirecard representative for complete information.\n\n\nT\n\n\nterminal\n \u2013 Card reading hardware device that enables the acceptance of cashless payments using credit and debit cards. Also known as a card reader.\n\n\ntransaction\n - The financial and payment details related to a sale. A sale may have more than one transaction if, for example, the consumer pays with two methods, such as cash and credit.\n\n\ntransaction type\n - Indicates the nature of a transaction, such as a \npurchase\n or an \nauthorize\n.\n\n\nU\n\n\nuser\n - The end-user of the payment acceptance app that you will create for a merchant with the SDK. Merchants usually have one or more users. Users are typically staff at a merchant's place of business, for example, sales staff in a retail store or drivers in a transportation/logistics company. Users who deal with cash are typically referred to as \nCashiers\n.\n\n\nV\n\n\nvendor\n \u2013 Refers to hardware vendors who make terminals (i.e. card readers), scanner pistols, cash registers and printers that can be used with the SDK. The most popular vendors of these hardware devices include Miura, BBPOS, Star and Datecs.\n\n\nW\n\n\nWeChat Pay\n - One of the most popular alternative payment methods available in China, this is a digital wallet service.\n\n\nZ\n\n\nZ-Report\n \u2013 See \nShift Report\n.", 
            "title": "Glossary"
        }, 
        {
            "location": "/glossary/#glossary", 
            "text": "", 
            "title": "Glossary"
        }, 
        {
            "location": "/glossary/#glossary-of-acronyms", 
            "text": "CNP  \u2013 Chip and PIN  CVM  - Card Verification Method  DUKPT  \u2013 Derived Unique Key Per Transaction  EFT  - Electronic Funds Transfer  EMV  - Europay, Mastercard, Visa. See  EMV  below.  ERP  \u2013 Enterprise Resource Planning  FW  - Firmware  HSM  - Hardware Security Module. See  HSM  below.    mPOS  - mobile Point of Sale  MFI  \u2013 Made for iPhone.  PCI DSS  \u2013 Payment Card Industry Data Security Standard  REST  \u2013 Representational State Transfer  SEPA  - Single Euro Payments Area  UUID  \u2013 Unique User Identifier", 
            "title": "Glossary of Acronyms"
        }, 
        {
            "location": "/glossary/#glossary-of-terminology", 
            "text": "", 
            "title": "Glossary of Terminology"
        }, 
        {
            "location": "/glossary/#a", 
            "text": "Acquiring Platform  \u2013 This is the primary payment facilitation component in the overall payment processing architecture. The Acquiring Platform is operated by the  Acquirer  and handles the  interchange  with the  card schemes  so that, ultimately, the transaction is debited from the account of the Cardholder. For SUPR Accept SDK, a  merchant  requires a contract with an Acquiring Platform so that they have an account through which to route transactions. Wirecard's  Payment   Risk  division provides its own Acquiring Platform with the Wirecard  Acquiring and Processing  unit.  Acquirer  - Entities that collect card payments that have been accepted by merchants, and then aggregrate and separate those payments and forward them on to  Issuers  for processing. Also known as  Merchant Acquirers .  Acquiring and Processing  - Unit of Wirecard that provides an  Acquiring Platform .  Alipay  \u2013 The largest mobile and online payment platform in the world, with 400 million users in China alone. Individual users receive a unique QR code which they use when making a payment to a merchant. The SUPR Accept SDK supports payments made through Alipay.  authorize  - One type of sale request. To allocate a certain amount on a credit card prior to completion of a sale.", 
            "title": "A"
        }, 
        {
            "location": "/glossary/#b", 
            "text": "back-end  - Refers to the new  Switch  back-end. With SUPR Accept SDK, you create a  front-end   payment acceptance app  and Switch is the corresponding back-end. The Switch back-end itself forwards transactions on to the  Gateway , which in turn, forwards the transaction on to the  Acquirer  and, ultimately, to the  Issuer  so that the consumer can pay the Issuer. In addition, many merchants also have an  ERP  system connected which augments the back-end functionality provided by Switch.  barcode  - One of two possible types of codes that can be scanned with a  pistol scanner . The other type is a  QR code .  basket  - A user-defined collection of items for purchase, also referred to as a  cart  or  shopping cart .  Business ByDesign  - See  SAP Business ByDesign .", 
            "title": "B"
        }, 
        {
            "location": "/glossary/#c", 
            "text": "cardholder  - Consumer who uses a debit or credit card as their method of payment.  Card Issuer  - See  Issuer .  card reader  - See  terminal .  cart  - See  basket .  cash  - Physical money in the form of bank notes or coins.  cash in/out  - See  pay in/out .  cash payments  - Payment with bank notes or coins. The opposite of  cashless payments .  cash register  - Refers to an actual piece of hardware that provides cash register functionality.  Cash Register  (i.e. spelled with a capital C and a capital R) refers to the object in the SDK code.  Cash Register  - Object in the SDK code that represents a real-life cash register. Each merchant may have one or more Cash Registers, each of which is identified by a unique identifier. Each Cashier must be associated with a Cash Register. Cash Registers are part of the Cash Manager component.  Cashier  - User of a cash register. Each Cashier must be associated with a Cash Register.  cashless payment  - Payment that involves a card, and does not involve bank notes or coins. The opposite of  cash payments .  Chip and PIN cards  - See  EMV cards .  Chip and Signature cards  - See  EMV cards .  consumer  - Person involved in a sale with a merchant. For example, a customer dining in a restaurant. If the consumer uses a card to pay, they are also referred to as a  cardholder .  customer  - Identifier in a back-end ERP system. Also referred to as a member in some ERP systems, including  SAP Business By Design . See  member .", 
            "title": "C"
        }, 
        {
            "location": "/glossary/#d", 
            "text": "device  - The physical hardware used by the merchant who has the payment acceptance app installed.", 
            "title": "D"
        }, 
        {
            "location": "/glossary/#e", 
            "text": "electronic payments  - Same as  cashless payments . Contrast with  cash payments .  EMV  - A global standard for credit cards that use chips to authenticate and secure chip-card transactions. Currently, EMV is managed by EMVCo which includes American Express, China UnionPay, Discover and others.  EMV Cards  \u2013 Smart cards, chip cards and IC cards, which include magnetic stripes for backward compatibility. Also includes contactless cards, which can be read over a short distance. EMV-compliant cards are often called  Chip and PIN  or  Chip and Signature  cards.", 
            "title": "E"
        }, 
        {
            "location": "/glossary/#f", 
            "text": "Firmware  \u2013 Permanent software that resides in memory of a hardware device. In terms of the SDK, firmware is significant because you can, and should, provide users with the ability to update their firmware from within the  payment acceptance app  that you create.  front-end  - The  payment acceptance app  that is created by  partners  using the SUPR Accept SDK is typically referred to as the front-end to distinguish it from the  Switch   back-end , which handles the processing and routing of transactions.  full refund  - A return to the consumer of the full amount that they paid in the original sale.", 
            "title": "F"
        }, 
        {
            "location": "/glossary/#g", 
            "text": "Gateway  - Wirecard component that is responsible for the initial processing of the transaction and then routing to the  Acquirer . Initial processing includes handling the secure decryption of  MagStripe ,  EMV  and both offline and online PIN transactions. An  HSM  is hosted to support decryption of card holder data. The Gateway is fully PCI DSS certified. For our partners developing with the SUPR Accept SDK, there is a  Test Gateway  to help with initial development and testing. It allows you to simulate the full end-to-end payment process during development.  gift card  \u2013 Physical or online card that provides the consumer with a discount on a purchase.", 
            "title": "G"
        }, 
        {
            "location": "/glossary/#h", 
            "text": "HSM  -  A physical device that helps with the decryption of PIN and other card holder data.", 
            "title": "H"
        }, 
        {
            "location": "/glossary/#i", 
            "text": "Inventory Manager  - Component of the SDK that enables the set up and maintenance of product catalogues, product categories and sub-categories, and products (including product images).  Issuing Bank  - See  Card Issuer .  Issuer  - See  Card Issuer .", 
            "title": "I"
        }, 
        {
            "location": "/glossary/#m", 
            "text": "merchant  - A seller of products, typically with a physical location, which is known as a  store  or  shop . The SUPR Accept SDK is used by our  partners  to create  payment acceptance apps  for merchants.  Merchant Acquirer  - See  Acquirer .  member  - A term that is sometimes used by ERP back-end systems to refer to customers. See  customer .  mobile device  \u2013 Hardware on which apps created with the SUPR Accept SDK run. Currently, iOS and Android devices are supported and Windows Mobile is coming soon.  Switch Portal  - Graphical User Interface provided to merchants that can be used to maintain their data that is stored in the Switch back-end.", 
            "title": "M"
        }, 
        {
            "location": "/glossary/#o", 
            "text": "Objective-C  - One of the programming languages that is available on the iOS platform. It is also available in the   Swift  language.", 
            "title": "O"
        }, 
        {
            "location": "/glossary/#p", 
            "text": "partial refund  - A return to the consumer of a portion of the amount they paid in the original sale.  partner  - Refers to companies that collaborate with Wirecard to create  payment acceptance apps  for  merchants  using the SUPR Accept SDK.  partner team  - One or more persons at a partner company responsible for creating a  payment acceptance app  using the SUPR Accept SDK. Typically, a partner team consists of a project manager and one or more developers. This SUPR Accept SDK documentation was created for our partner teams.  pay in/out  \u2013 Cash that is either put in or taken out of a cash register. Also referred to as cash in and cash out, or cash in/out.  payment gateway  - See  Gateway .  payment method  - Form of payment used in a sale. With the SUPR Accept SDK, the form can be cash, card, SEPA, Alipay or WeChat Pay.  Payment   Risk  - Division of Wirecard that handles  Acquiring and Processing  services.  payment acceptance app  - App that Wirecard  partners  create with the SUPR Accept SDK. This may be a fully-standalone app, or it could be a sub-component of a larger app. For example, a logistics company would already have an app that handles logistics, such as deliveries, storage and so forth, but they may want to add payment acceptance functionality so that their drivers can accept cards and cash. So, in this case, the SUPR Accept SDK would be used to create a sub-component of the logistics app. For simplicity though, throughout this documentation, the app created with the SUPR Accept SDK is always referred to as the  payment acceptance app .   payment gateway  \u2013 Transaction processing and routing. See  Gateway .  pistol scanner  - Handheld scanner used to scan  barcodes  and  QR codes .  platform  - Refers to the operating system on which the SUPR Accept SDK is used. Also refers to the operating system on which the application functionality created with the SDK will run. For example, iOS is one of the platforms that is supported by the SDK.  product catalogue  - A set of products. Also commonly referred to as inventory. See  Inventory Manager .  Public Test  \u2013 Switch back-end testing environment provided by Wirecard that is ideal for testing and validation of application functionality that you build with the SDK.  purchase  - The most common  transaction type . A purchase involves the  consumer  buying something from a  merchant . Other types of transactions include  return ,  authorize ,  pre-authorize .", 
            "title": "P"
        }, 
        {
            "location": "/glossary/#q", 
            "text": "QR code  - Commonly used abbreviation for Quick Response (QR) code. A matrix-type barcode consisting of black and white squares. Most mobile devices have free QR code reader apps. A QR code is one of two types of codes that can be scanned using a  pistol scanner . See also  barcode .", 
            "title": "Q"
        }, 
        {
            "location": "/glossary/#r", 
            "text": "return  - Can be a  reverse  or a  refund .  reverse  - A cancellation of a sale, which can be performed if the sale has not yet been processed by the  Acquiring Platform .  refund  - A cancellation of a sale and a return of the payment to the consumer. The SDK supports both full and partial refunds.", 
            "title": "R"
        }, 
        {
            "location": "/glossary/#s", 
            "text": "sale  - The initial interaction between the merchant user and a  consumer . In terms of the SDK code, sales begin with a  Sale Request  and completes with a  Sale Response .  Sale Response  - SDK object that has the results of the sale after processing by the back-end.  Sale Request  - SDK object that is used in the initial phase of a sale to a consumer. This object has the particulars of a sale, including price, quantity and tax rate. Note that a Sale Request is typically a  purchase , but it can also be a  return , an  authorize , or a  pre-authorize .  SAP Business ByDesign  - A cloud-based  ERP  solution for small to medium-sized businesses. This software can be used to augment the  Switch   back-end  which is provided as part of the SDK.  scanner  - See  pistol scanner .  SEPA  \u2013 The\u00a0Single Euro Payments Area\u00a0(SEPA) is a payment-integration initiative of the European Union for simplification of bank transfers denominated in euros.  shift  \u2013 Working time of a merchant user. Starts with the open and ends with the close.  shop  - The physical location of a merchant. In terms of the SDK, this is significant if the merchant has more than one physical location.  shopping cart  - See  basket .  Shift Report  - Detailed information about transaction activity between the opening of a shift and its closing. Also known as a Z-Report.  Shift Activity  \u2013  Pay in/out  activity between the open and close of a shift.  Star Micronics  - Vendor of payment acceptance hardware.  StarIO  - See  Star Micronics .  store  - See  shop .  Swift  - One of the programming languages that is available on the iOS platform. See also  Objective-C .   Switch  - The back-end of the SUPR Accept SDK front-end. Transactions are processed through the Switch back-end. As part of the setup process for a merchant, they will need to set up the appropriate users, products, product catalogues, terminals and so forth. Consult your Wirecard representative for more information. Also, note that some customers may also have an ERP system connected to Switch, which provides more back-end functionality, such as Price list management and Stock level management. Once again, consult your Wirecard representative for complete information.", 
            "title": "S"
        }, 
        {
            "location": "/glossary/#t", 
            "text": "terminal  \u2013 Card reading hardware device that enables the acceptance of cashless payments using credit and debit cards. Also known as a card reader.  transaction  - The financial and payment details related to a sale. A sale may have more than one transaction if, for example, the consumer pays with two methods, such as cash and credit.  transaction type  - Indicates the nature of a transaction, such as a  purchase  or an  authorize .", 
            "title": "T"
        }, 
        {
            "location": "/glossary/#u", 
            "text": "user  - The end-user of the payment acceptance app that you will create for a merchant with the SDK. Merchants usually have one or more users. Users are typically staff at a merchant's place of business, for example, sales staff in a retail store or drivers in a transportation/logistics company. Users who deal with cash are typically referred to as  Cashiers .", 
            "title": "U"
        }, 
        {
            "location": "/glossary/#v", 
            "text": "vendor  \u2013 Refers to hardware vendors who make terminals (i.e. card readers), scanner pistols, cash registers and printers that can be used with the SDK. The most popular vendors of these hardware devices include Miura, BBPOS, Star and Datecs.", 
            "title": "V"
        }, 
        {
            "location": "/glossary/#w", 
            "text": "WeChat Pay  - One of the most popular alternative payment methods available in China, this is a digital wallet service.", 
            "title": "W"
        }, 
        {
            "location": "/glossary/#z", 
            "text": "Z-Report  \u2013 See  Shift Report .", 
            "title": "Z"
        }
    ]
}